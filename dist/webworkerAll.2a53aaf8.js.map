{"mappings":"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","sources":["<anon>","node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs","node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"i6XA8\", function(module, exports) {\nparcelRequire(\"54Ykb\");\nparcelRequire(\"cqGna\");\nparcelRequire(\"6PbjS\");\nparcelRequire(\"jjbq7\");\nparcelRequire(\"l3cJr\");\nparcelRequire(\"2dQTG\");\nparcelRequire(\"68VbR\");\nparcelRequire(\"b3jdr\");\nparcelRequire(\"hmfYL\");\nparcelRequire(\"ibWjW\");\nparcelRequire(\"9q1mQ\");\nparcelRequire(\"1LtXF\");\n\"use strict\";\n\n});\n\nparcelRegister(\"lK0KY\", function(module, exports) {\n\n$parcel$export(module.exports, \"State\", function () { return $63d92d438b53d4bd$export$7254cc27399e90bd; });\n\"use strict\";\nconst $63d92d438b53d4bd$var$blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    \"normal-npm\": 6,\n    \"add-npm\": 7,\n    \"screen-npm\": 8,\n    min: 9,\n    max: 10\n};\nconst $63d92d438b53d4bd$var$BLEND = 0;\nconst $63d92d438b53d4bd$var$OFFSET = 1;\nconst $63d92d438b53d4bd$var$CULLING = 2;\nconst $63d92d438b53d4bd$var$DEPTH_TEST = 3;\nconst $63d92d438b53d4bd$var$WINDING = 4;\nconst $63d92d438b53d4bd$var$DEPTH_MASK = 5;\nconst $63d92d438b53d4bd$var$_State = class _State {\n    constructor(){\n        this.data = 0;\n        this.blendMode = \"normal\";\n        this.polygonOffset = 0;\n        this.blend = true;\n        this.depthMask = true;\n    }\n    /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */ get blend() {\n        return !!(this.data & 1 << $63d92d438b53d4bd$var$BLEND);\n    }\n    set blend(value) {\n        if (!!(this.data & 1 << $63d92d438b53d4bd$var$BLEND) !== value) this.data ^= 1 << $63d92d438b53d4bd$var$BLEND;\n    }\n    /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */ get offsets() {\n        return !!(this.data & 1 << $63d92d438b53d4bd$var$OFFSET);\n    }\n    set offsets(value) {\n        if (!!(this.data & 1 << $63d92d438b53d4bd$var$OFFSET) !== value) this.data ^= 1 << $63d92d438b53d4bd$var$OFFSET;\n    }\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */ set cullMode(value) {\n        if (value === \"none\") {\n            this.culling = false;\n            return;\n        }\n        this.culling = true;\n        this.clockwiseFrontFace = value === \"front\";\n    }\n    get cullMode() {\n        if (!this.culling) return \"none\";\n        return this.clockwiseFrontFace ? \"front\" : \"back\";\n    }\n    /**\n   * Activates culling of polygons.\n   * @default false\n   */ get culling() {\n        return !!(this.data & 1 << $63d92d438b53d4bd$var$CULLING);\n    }\n    set culling(value) {\n        if (!!(this.data & 1 << $63d92d438b53d4bd$var$CULLING) !== value) this.data ^= 1 << $63d92d438b53d4bd$var$CULLING;\n    }\n    /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */ get depthTest() {\n        return !!(this.data & 1 << $63d92d438b53d4bd$var$DEPTH_TEST);\n    }\n    set depthTest(value) {\n        if (!!(this.data & 1 << $63d92d438b53d4bd$var$DEPTH_TEST) !== value) this.data ^= 1 << $63d92d438b53d4bd$var$DEPTH_TEST;\n    }\n    /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */ get depthMask() {\n        return !!(this.data & 1 << $63d92d438b53d4bd$var$DEPTH_MASK);\n    }\n    set depthMask(value) {\n        if (!!(this.data & 1 << $63d92d438b53d4bd$var$DEPTH_MASK) !== value) this.data ^= 1 << $63d92d438b53d4bd$var$DEPTH_MASK;\n    }\n    /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */ get clockwiseFrontFace() {\n        return !!(this.data & 1 << $63d92d438b53d4bd$var$WINDING);\n    }\n    set clockwiseFrontFace(value) {\n        if (!!(this.data & 1 << $63d92d438b53d4bd$var$WINDING) !== value) this.data ^= 1 << $63d92d438b53d4bd$var$WINDING;\n    }\n    /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */ get blendMode() {\n        return this._blendMode;\n    }\n    set blendMode(value) {\n        this.blend = value !== \"none\";\n        this._blendMode = value;\n        this._blendModeId = $63d92d438b53d4bd$var$blendModeIds[value] || 0;\n    }\n    /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */ get polygonOffset() {\n        return this._polygonOffset;\n    }\n    set polygonOffset(value) {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n    toString() {\n        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n    }\n    /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */ static for2d() {\n        const state = new _State();\n        state.depthTest = false;\n        state.blend = true;\n        return state;\n    }\n};\n$63d92d438b53d4bd$var$_State.default2d = $63d92d438b53d4bd$var$_State.for2d();\nlet $63d92d438b53d4bd$export$7254cc27399e90bd = $63d92d438b53d4bd$var$_State;\n\n});\n\nparcelRegister(\"8n8Vu\", function(module, exports) {\n\n$parcel$export(module.exports, \"color32BitToUniform\", function () { return $8b10cef2a02ebfd5$export$2c68e848c5b81f5; });\n\"use strict\";\nfunction $8b10cef2a02ebfd5$export$d13a52631f102a23(rgb, alpha, out, offset) {\n    out[offset++] = (rgb >> 16 & 255) / 255;\n    out[offset++] = (rgb >> 8 & 255) / 255;\n    out[offset++] = (rgb & 255) / 255;\n    out[offset++] = alpha;\n}\nfunction $8b10cef2a02ebfd5$export$2c68e848c5b81f5(abgr, out, offset) {\n    const alpha = (abgr >> 24 & 255) / 255;\n    out[offset++] = (abgr & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n    out[offset++] = alpha;\n}\n\n});\n\nparcelRegister(\"dXAM5\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableSprite\", function () { return $b4029079f203f9a4$export$fe4bdc7069ee0b9c; });\n\"use strict\";\nclass $b4029079f203f9a4$export$fe4bdc7069ee0b9c {\n    constructor(){\n        this.batcherName = \"default\";\n        this.topology = \"triangle-list\";\n        // batch specific..\n        this.attributeSize = 4;\n        this.indexSize = 6;\n        this.packAsQuad = true;\n        this.roundPixels = 0;\n        this._attributeStart = 0;\n        // location in the buffer\n        this._batcher = null;\n        this._batch = null;\n    }\n    get blendMode() {\n        return this.renderable.groupBlendMode;\n    }\n    get color() {\n        return this.renderable.groupColorAlpha;\n    }\n    reset() {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n\n});\n\nparcelRegister(\"dvARM\", function(module, exports) {\n\n$parcel$export(module.exports, \"localUniformBit\", function () { return $c21c586e316ed6c6$export$1723ac05bd5e9336; });\n$parcel$export(module.exports, \"localUniformBitGroup2\", function () { return $c21c586e316ed6c6$export$adb0f80794f644d9; });\n$parcel$export(module.exports, \"localUniformBitGl\", function () { return $c21c586e316ed6c6$export$36099520d0a716a; });\n\"use strict\";\nconst $c21c586e316ed6c6$export$1723ac05bd5e9336 = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* wgsl */ `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */ `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */ `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    }\n};\nconst $c21c586e316ed6c6$export$adb0f80794f644d9 = {\n    ...$c21c586e316ed6c6$export$1723ac05bd5e9336,\n    vertex: {\n        ...$c21c586e316ed6c6$export$1723ac05bd5e9336.vertex,\n        // replace the group!\n        header: $c21c586e316ed6c6$export$1723ac05bd5e9336.vertex.header.replace(\"group(1)\", \"group(2)\")\n    }\n};\nconst $c21c586e316ed6c6$export$36099520d0a716a = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* glsl */ `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */ `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */ `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    }\n};\n\n});\n\n\n//# sourceMappingURL=webworkerAll.2a53aaf8.js.map\n","import '../app/init.mjs';\nimport '../spritesheet/init.mjs';\nimport '../rendering/init.mjs';\nimport '../scene/graphics/init.mjs';\nimport '../scene/mesh/init.mjs';\nimport '../scene/particle-container/init.mjs';\nimport '../scene/text/init.mjs';\nimport '../scene/text-bitmap/init.mjs';\nimport '../scene/text-html/init.mjs';\nimport '../scene/sprite-tiling/init.mjs';\nimport '../scene/sprite-nine-slice/init.mjs';\nimport '../filters/init.mjs';\n\n\"use strict\";\n//# sourceMappingURL=webworkerAll.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","$63d92d438b53d4bd$export$7254cc27399e90bd","$63d92d438b53d4bd$var$blendModeIds","normal","add","multiply","screen","overlay","erase","min","max","$63d92d438b53d4bd$var$_State","_State","constructor","data","blendMode","polygonOffset","blend","depthMask","value","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","state","default2d","$8b10cef2a02ebfd5$export$2c68e848c5b81f5","abgr","out","offset","alpha","$b4029079f203f9a4$export$fe4bdc7069ee0b9c","batcherName","topology","attributeSize","indexSize","packAsQuad","roundPixels","_attributeStart","_batcher","_batch","renderable","groupBlendMode","color","groupColorAlpha","reset","texture","bounds","$c21c586e316ed6c6$export$1723ac05bd5e9336","$c21c586e316ed6c6$export$adb0f80794f644d9","$c21c586e316ed6c6$export$36099520d0a716a","name","vertex","header","main","end","replace"],"version":3,"file":"webworkerAll.2a53aaf8.js.map"}