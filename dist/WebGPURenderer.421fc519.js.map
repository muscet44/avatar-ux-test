{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I,E,A,C,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,C,E,iB,C,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,a,W,O,C,G,E,E,O,C,e,W,O,C,GEAO,IAAM,EAAa,CACtB,KAAM,cACN,OAAQ,CACJ,OAAkB;A;A;A;A;A;A;AAAA,QAAA,CAAA,CAQlB,KAAgB;A;AAAA,QAAA,CAAA,AAAA,EAIpB,SAAU,CACN,OAAkB;A;A;A;A;AAAA,QAAA,CAAA,CAMlB,KAAgB;A;AAAA,QAAA,CAAA,AAAA,CAIxB,EAEa,EAAe,CACxB,KAAM,cACN,OAAQ,CACJ,OAAkB;A;AAAA,QAAA,CAAA,CAGlB,KAAgB;A;AAAA,QAAA,CAAA,AAAA,EAIpB,SAAU,CACN,OAAkB;A;A;A;AAAA,QAAA,CAAA,CAKlB,KAAgB;A;AAAA,QAAA,CAAA,AAAA,CAIxB,C,G,E,Q,S,C,C,C,E,E,E,O,C,gB,W,O,C,G,E,E,O,C,oB,W,O,C,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SE1BO,IAAM,EAAgB,CACzB,EAAA,gBAAA,CACA,EAAA,mBAAA,CACA,EAAA,WAAA,CACA,EAAA,UAAA,CACA,EAAA,iBAAA,CACA,EAAA,eAAA,CACA,EAAA,qBAAA,CACA,EAAA,aAAA,CACA,EAAA,gBAAA,CACA,EAAA,kBAAA,CACA,EAAA,eAAA,CACJ,CAEa,EAAoB,CAC7B,EAAA,aAAA,CACA,EAAA,WAAA,CACA,EAAA,UAAA,CACA,EAAA,eAAA,CACA,EAAA,aAAA,CACA,EAAA,eAAA,CACA,EAAA,aAAA,CACA,EAAA,gBAAA,CACJ,A,G,E,Q,S,C,C,C,E,E,E,O,C,mB,W,O,C,G,I,E,E,QEzBO,OAAM,EAaT,YAAY,CACZ,CAAA,CACI,IAAA,CAAK,SAAY,CAAA,CAAA,CAGd,kBAAmB,CAAA,CACnB,m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","sources":["<anon>","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts","node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs","node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts","node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs","node_modules/pixi.js/src/scene/container/CustomRenderPipe.ts","node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs","node_modules/pixi.js/src/scene/container/RenderGroupPipe.ts","node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs","node_modules/pixi.js/src/scene/container/utils/executeInstructions.ts","node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs","node_modules/pixi.js/src/scene/container/RenderGroupSystem.ts","node_modules/pixi.js/lib/scene/container/utils/clearList.mjs","node_modules/pixi.js/src/scene/container/utils/clearList.ts","node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs","node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts","node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs","node_modules/pixi.js/src/scene/container/utils/validateRenderables.ts","node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","node_modules/pixi.js/src/scene/sprite/SpritePipe.ts","node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs","node_modules/pixi.js/src/rendering/batcher/shared/BatcherPipe.ts","node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs","node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts","node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","node_modules/pixi.js/src/filters/mask/MaskFilter.ts","node_modules/pixi.js/lib/filters/Filter.mjs","node_modules/pixi.js/src/filters/Filter.ts","node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs","node_modules/pixi.js/src/rendering/mask/color/ColorMaskPipe.ts","node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs","node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts","node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts","node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs","node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts","node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts","node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts","node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts","node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts","node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts","node_modules/pixi.js/lib/utils/sayHello.mjs","node_modules/pixi.js/src/utils/sayHello.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts","node_modules/pixi.js/lib/utils/data/clean.mjs","node_modules/pixi.js/src/utils/data/clean.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts","node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts","node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs","node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts","node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs","node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts","node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs","node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"dUkOw\", function(module, exports) {\n\n$parcel$export(module.exports, \"textureBit\", function () { return $a501a60afdc99415$export$db13c76603bca4d1; });\n$parcel$export(module.exports, \"textureBitGl\", function () { return $a501a60afdc99415$export$dfbe934dc5760b41; });\n\"use strict\";\nconst $a501a60afdc99415$export$db13c76603bca4d1 = {\n    name: \"texture-bit\",\n    vertex: {\n        header: /* wgsl */ `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */ `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */ `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `,\n        main: /* wgsl */ `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\nconst $a501a60afdc99415$export$dfbe934dc5760b41 = {\n    name: \"texture-bit\",\n    vertex: {\n        header: /* glsl */ `\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */ `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */ `\n        uniform sampler2D uTexture;\n\n         \n        `,\n        main: /* glsl */ `\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n});\n\nparcelRegister(\"8xGs2\", function(module, exports) {\n\n$parcel$export(module.exports, \"SharedSystems\", function () { return $0fb3c38788095636$export$556f4f9086226a47; });\n$parcel$export(module.exports, \"SharedRenderPipes\", function () { return $0fb3c38788095636$export$4804359c3f750499; });\n\nvar $g2j5H = parcelRequire(\"g2j5H\");\n\nvar $28aiy = parcelRequire(\"28aiy\");\n\nvar $ddKkB = parcelRequire(\"ddKkB\");\n\nvar $5k7Pa = parcelRequire(\"5k7Pa\");\n\nvar $d6zIN = parcelRequire(\"d6zIN\");\n\nvar $8CF7d = parcelRequire(\"8CF7d\");\n\nvar $aEM94 = parcelRequire(\"aEM94\");\n\nvar $2Xi2U = parcelRequire(\"2Xi2U\");\n\nvar $kQDDm = parcelRequire(\"kQDDm\");\n\nvar $gHW7P = parcelRequire(\"gHW7P\");\n\nvar $5DBVc = parcelRequire(\"5DBVc\");\n\nvar $l24yk = parcelRequire(\"l24yk\");\n\nvar $a81eN = parcelRequire(\"a81eN\");\n\nvar $4fWAX = parcelRequire(\"4fWAX\");\n\nvar $edAuX = parcelRequire(\"edAuX\");\n\nvar $gR8f7 = parcelRequire(\"gR8f7\");\n\nvar $7aCaM = parcelRequire(\"7aCaM\");\n\nvar $hriU1 = parcelRequire(\"hriU1\");\n\nvar $k3485 = parcelRequire(\"k3485\");\n\"use strict\";\nconst $0fb3c38788095636$export$556f4f9086226a47 = [\n    (0, $gHW7P.BackgroundSystem),\n    (0, $4fWAX.GlobalUniformSystem),\n    (0, $gR8f7.HelloSystem),\n    (0, $k3485.ViewSystem),\n    (0, $ddKkB.RenderGroupSystem),\n    (0, $hriU1.TextureGCSystem),\n    (0, $a81eN.GenerateTextureSystem),\n    (0, $l24yk.ExtractSystem),\n    (0, $d6zIN.RendererInitHook),\n    (0, $7aCaM.RenderableGCSystem),\n    (0, $edAuX.SchedulerSystem)\n];\nconst $0fb3c38788095636$export$4804359c3f750499 = [\n    (0, $5DBVc.BlendModePipe),\n    (0, $8CF7d.BatcherPipe),\n    (0, $5k7Pa.SpritePipe),\n    (0, $28aiy.RenderGroupPipe),\n    (0, $aEM94.AlphaMaskPipe),\n    (0, $kQDDm.StencilMaskPipe),\n    (0, $2Xi2U.ColorMaskPipe),\n    (0, $g2j5H.CustomRenderPipe)\n];\n\n});\nparcelRegister(\"g2j5H\", function(module, exports) {\n\n$parcel$export(module.exports, \"CustomRenderPipe\", function () { return $e76b9ad86b228e10$export$e576ade34298fbbb; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nclass $e76b9ad86b228e10$export$e576ade34298fbbb {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    updateRenderable() {}\n    destroyRenderable() {}\n    validateRenderable() {\n        return false;\n    }\n    addRenderable(container, instructionSet) {\n        this._renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(container);\n    }\n    execute(container) {\n        if (!container.isRenderable) return;\n        container.render(this._renderer);\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n$e76b9ad86b228e10$export$e576ade34298fbbb.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLPipes,\n        (0, $kFA6i.ExtensionType).WebGPUPipes,\n        (0, $kFA6i.ExtensionType).CanvasPipes\n    ],\n    name: \"customRender\"\n};\n\n});\n\nparcelRegister(\"28aiy\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderGroupPipe\", function () { return $9bff709278747486$export$9d1db8757b18c590; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $dLv5L = parcelRequire(\"dLv5L\");\n\nvar $dXAM5 = parcelRequire(\"dXAM5\");\n\nvar $87MHd = parcelRequire(\"87MHd\");\n\"use strict\";\nconst $9bff709278747486$var$tempMatrix = new (0, $0kbcf.Matrix)();\nclass $9bff709278747486$export$9d1db8757b18c590 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    addRenderGroup(renderGroup, instructionSet) {\n        if (renderGroup.isCachedAsTexture) this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        else this._addRenderableDirect(renderGroup, instructionSet);\n    }\n    execute(renderGroup) {\n        if (!renderGroup.isRenderable) return;\n        if (renderGroup.isCachedAsTexture) this._executeCacheAsTexture(renderGroup);\n        else this._executeDirect(renderGroup);\n    }\n    destroy() {\n        this._renderer = null;\n    }\n    _addRenderableDirect(renderGroup, instructionSet) {\n        this._renderer.renderPipes.batch.break(instructionSet);\n        if (renderGroup._batchableRenderGroup) {\n            (0, $dLv5L.BigPool).return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n        instructionSet.add(renderGroup);\n    }\n    _addRenderableCacheAsTexture(renderGroup, instructionSet) {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = (0, $dLv5L.BigPool).get((0, $dXAM5.BatchableSprite)));\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n        instructionSet.add(renderGroup);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    }\n    _executeCacheAsTexture(renderGroup) {\n        if (renderGroup.textureNeedsUpdate) {\n            renderGroup.textureNeedsUpdate = false;\n            const worldTransformMatrix = $9bff709278747486$var$tempMatrix.identity().translate(-renderGroup._textureBounds.x, -renderGroup._textureBounds.y);\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix: worldTransformMatrix,\n                worldColor: 4294967295\n            });\n            (0, $87MHd.executeInstructions)(renderGroup, this._renderer.renderPipes);\n            this._renderer.renderTarget.finishRenderPass();\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n    _executeDirect(renderGroup) {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha\n        });\n        (0, $87MHd.executeInstructions)(renderGroup, this._renderer.renderPipes);\n        this._renderer.globalUniforms.pop();\n    }\n}\n$9bff709278747486$export$9d1db8757b18c590.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLPipes,\n        (0, $kFA6i.ExtensionType).WebGPUPipes,\n        (0, $kFA6i.ExtensionType).CanvasPipes\n    ],\n    name: \"renderGroup\"\n};\n\n});\nparcelRegister(\"87MHd\", function(module, exports) {\n\n$parcel$export(module.exports, \"executeInstructions\", function () { return $aae9797cc2f076d1$export$de87bf58cb76142c; });\n\"use strict\";\nfunction $aae9797cc2f076d1$export$de87bf58cb76142c(renderGroup, renderer) {\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n    for(let i = 0; i < instructionSet.instructionSize; i++){\n        const instruction = instructions[i];\n        renderer[instruction.renderPipeId].execute(instruction);\n    }\n}\n\n});\n\n\nparcelRegister(\"ddKkB\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderGroupSystem\", function () { return $a6ec671d9ad127d2$export$e48941ab3223d0e5; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $2zAQe = parcelRequire(\"2zAQe\");\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $c4BxA = parcelRequire(\"c4BxA\");\n\nvar $87MHd = parcelRequire(\"87MHd\");\n\nvar $h0MOH = parcelRequire(\"h0MOH\");\n\nvar $gZmuI = parcelRequire(\"gZmuI\");\n\"use strict\";\nconst $a6ec671d9ad127d2$var$tempMatrix = new (0, $0kbcf.Matrix)();\nclass $a6ec671d9ad127d2$export$e48941ab3223d0e5 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    render({ container: container, transform: transform }) {\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n        const renderer = this._renderer;\n        let originalLocalTransform = $a6ec671d9ad127d2$var$tempMatrix;\n        if (transform) {\n            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n        const renderPipes = renderer.renderPipes;\n        this._updateCachedRenderGroups(container.renderGroup, null);\n        this._updateRenderGroups(container.renderGroup);\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha\n        });\n        (0, $87MHd.executeInstructions)(container.renderGroup, renderPipes);\n        if (renderPipes.uniformBatch) renderPipes.uniformBatch.renderEnd();\n        if (transform) container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n    destroy() {\n        this._renderer = null;\n    }\n    _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n        if (renderGroup.isCachedAsTexture) {\n            if (!renderGroup.updateCacheTexture) return;\n            closestCacheAsTexture = renderGroup;\n        }\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n        for(let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        renderGroup.invalidateMatrices();\n        if (renderGroup.isCachedAsTexture) {\n            if (renderGroup.textureNeedsUpdate) {\n                const bounds = renderGroup.root.getLocalBounds();\n                bounds.ceil();\n                const lastTexture = renderGroup.texture;\n                if (renderGroup.texture) (0, $2zAQe.TexturePool).returnTexture(renderGroup.texture);\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n                renderGroup.texture = (0, $2zAQe.TexturePool).getOptimalTexture(bounds.width, bounds.height, resolution, antialias);\n                renderGroup._textureBounds || (renderGroup._textureBounds = new (0, $dtW0p.Bounds)());\n                renderGroup._textureBounds.copyFrom(bounds);\n                if (lastTexture !== renderGroup.texture) {\n                    if (renderGroup.renderGroupParent) renderGroup.renderGroupParent.structureDidChange = true;\n                }\n            }\n        } else if (renderGroup.texture) {\n            (0, $2zAQe.TexturePool).returnTexture(renderGroup.texture);\n            renderGroup.texture = null;\n        }\n    }\n    _updateRenderGroups(renderGroup) {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n        renderGroup.runOnRender(renderer);\n        renderGroup.instructionSet.renderPipes = renderPipes;\n        if (!renderGroup.structureDidChange) (0, $gZmuI.validateRenderables)(renderGroup, renderPipes);\n        else (0, $c4BxA.clearList)(renderGroup.childrenRenderablesToUpdate.list, 0);\n        (0, $h0MOH.updateRenderGroupTransforms)(renderGroup);\n        if (renderGroup.structureDidChange) {\n            renderGroup.structureDidChange = false;\n            this._buildInstructions(renderGroup, renderer);\n        } else this._updateRenderables(renderGroup);\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n        for(let i = 0; i < renderGroup.renderGroupChildren.length; i++)this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n    _updateRenderables(renderGroup) {\n        const { list: list, index: index } = renderGroup.childrenRenderablesToUpdate;\n        for(let i = 0; i < index; i++){\n            const container = list[i];\n            if (container.didViewUpdate) renderGroup.updateRenderable(container);\n        }\n        (0, $c4BxA.clearList)(list, index);\n    }\n    _buildInstructions(renderGroup, rendererOrPipes) {\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n        instructionSet.reset();\n        const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n        const renderPipes = renderer.renderPipes;\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n        if (root.sortableChildren) root.sortChildren();\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n/** @ignore */ $a6ec671d9ad127d2$export$e48941ab3223d0e5.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem,\n        (0, $kFA6i.ExtensionType).CanvasSystem\n    ],\n    name: \"renderGroup\"\n};\n\n});\nparcelRegister(\"c4BxA\", function(module, exports) {\n\n$parcel$export(module.exports, \"clearList\", function () { return $433042607578a9a7$export$ff1832761d063f24; });\n\"use strict\";\nfunction $433042607578a9a7$export$ff1832761d063f24(list, index) {\n    index || (index = 0);\n    for(let j = index; j < list.length; j++){\n        if (list[j]) list[j] = null;\n        else break;\n    }\n}\n\n});\n\nparcelRegister(\"h0MOH\", function(module, exports) {\n\n$parcel$export(module.exports, \"updateRenderGroupTransforms\", function () { return $d68b8eb9e5e57e06$export$1c1e67f49974a5b5; });\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\n\nvar $c4BxA = parcelRequire(\"c4BxA\");\n\nvar $8KIbM = parcelRequire(\"8KIbM\");\n\"use strict\";\nconst $d68b8eb9e5e57e06$var$tempContainer = new (0, $gRXu9.Container)();\nconst $d68b8eb9e5e57e06$var$UPDATE_BLEND_COLOR_VISIBLE = (0, $gRXu9.UPDATE_VISIBLE) | (0, $gRXu9.UPDATE_COLOR) | (0, $gRXu9.UPDATE_BLEND);\nfunction $d68b8eb9e5e57e06$export$1c1e67f49974a5b5(renderGroup, updateChildRenderGroups = false) {\n    $d68b8eb9e5e57e06$export$50ad8695661e3665(renderGroup);\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n    const updateTick = renderGroup.updateTick++;\n    for(const j in childrenToUpdate){\n        const renderGroupDepth = Number(j);\n        const childrenAtDepth = childrenToUpdate[j];\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n        for(let i = 0; i < index; i++){\n            const child = list[i];\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) $d68b8eb9e5e57e06$export$cf7b65c878eb783a(child, updateTick, 0);\n        }\n        (0, $c4BxA.clearList)(list, index);\n        childrenAtDepth.index = 0;\n    }\n    if (updateChildRenderGroups) for(let i = 0; i < renderGroup.renderGroupChildren.length; i++)$d68b8eb9e5e57e06$export$1c1e67f49974a5b5(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n}\nfunction $d68b8eb9e5e57e06$export$50ad8695661e3665(renderGroup) {\n    const root = renderGroup.root;\n    let worldAlpha;\n    if (renderGroup.renderGroupParent) {\n        const renderGroupParent = renderGroup.renderGroupParent;\n        renderGroup.worldTransform.appendFrom(root.relativeGroupTransform, renderGroupParent.worldTransform);\n        renderGroup.worldColor = (0, $8KIbM.multiplyColors)(root.groupColor, renderGroupParent.worldColor);\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    } else {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n    worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n    renderGroup.worldAlpha = worldAlpha;\n    renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction $d68b8eb9e5e57e06$export$cf7b65c878eb783a(container, updateTick, updateFlags) {\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n    container.didChange = false;\n    const localTransform = container.localTransform;\n    container.updateLocalTransform();\n    const parent = container.parent;\n    if (parent && !parent.renderGroup) {\n        updateFlags |= container._updateFlags;\n        container.relativeGroupTransform.appendFrom(localTransform, parent.relativeGroupTransform);\n        if (updateFlags & $d68b8eb9e5e57e06$var$UPDATE_BLEND_COLOR_VISIBLE) $d68b8eb9e5e57e06$var$updateColorBlendVisibility(container, parent, updateFlags);\n    } else {\n        updateFlags = container._updateFlags;\n        container.relativeGroupTransform.copyFrom(localTransform);\n        if (updateFlags & $d68b8eb9e5e57e06$var$UPDATE_BLEND_COLOR_VISIBLE) $d68b8eb9e5e57e06$var$updateColorBlendVisibility(container, $d68b8eb9e5e57e06$var$tempContainer, updateFlags);\n    }\n    if (!container.renderGroup) {\n        const children = container.children;\n        const length = children.length;\n        for(let i = 0; i < length; i++)$d68b8eb9e5e57e06$export$cf7b65c878eb783a(children[i], updateTick, updateFlags);\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container;\n        if (renderable.renderPipeId && !renderGroup.structureDidChange) renderGroup.updateRenderable(renderable);\n    }\n}\nfunction $d68b8eb9e5e57e06$var$updateColorBlendVisibility(container, parent, updateFlags) {\n    if (updateFlags & (0, $gRXu9.UPDATE_COLOR)) {\n        container.groupColor = (0, $8KIbM.multiplyColors)(container.localColor, parent.groupColor);\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n        groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n    }\n    if (updateFlags & (0, $gRXu9.UPDATE_BLEND)) container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n    if (updateFlags & (0, $gRXu9.UPDATE_VISIBLE)) container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    container._updateFlags = 0;\n}\n\n});\n\nparcelRegister(\"gZmuI\", function(module, exports) {\n\n$parcel$export(module.exports, \"validateRenderables\", function () { return $fa75833e253876b0$export$40044447708e4acc; });\n\"use strict\";\nfunction $fa75833e253876b0$export$40044447708e4acc(renderGroup, renderPipes) {\n    const { list: list, index: index } = renderGroup.childrenRenderablesToUpdate;\n    let rebuildRequired = false;\n    for(let i = 0; i < index; i++){\n        const container = list[i];\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId];\n        rebuildRequired = pipe.validateRenderable(container);\n        if (rebuildRequired) break;\n    }\n    renderGroup.structureDidChange = rebuildRequired;\n    return rebuildRequired;\n}\n\n});\n\n\nparcelRegister(\"5k7Pa\", function(module, exports) {\n\n$parcel$export(module.exports, \"SpritePipe\", function () { return $4e32db524195383e$export$ffb847f6753f2536; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $dLv5L = parcelRequire(\"dLv5L\");\n\nvar $dXAM5 = parcelRequire(\"dXAM5\");\n\"use strict\";\nclass $4e32db524195383e$export$ffb847f6753f2536 {\n    constructor(renderer){\n        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n        this._destroyRenderableBound = this.destroyRenderable.bind(this);\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, \"_gpuSpriteHash\");\n    }\n    addRenderable(sprite, instructionSet) {\n        const gpuSprite = this._getGpuSprite(sprite);\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n    updateRenderable(sprite) {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n    validateRenderable(sprite) {\n        const gpuSprite = this._getGpuSprite(sprite);\n        return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, sprite._texture);\n    }\n    destroyRenderable(sprite) {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n        (0, $dLv5L.BigPool).return(batchableSprite);\n        this._gpuSpriteHash[sprite.uid] = null;\n        sprite.off(\"destroyed\", this._destroyRenderableBound);\n    }\n    _updateBatchableSprite(sprite, batchableSprite) {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n    _getGpuSprite(sprite) {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n    _initGPUSprite(sprite) {\n        const batchableSprite = (0, $dLv5L.BigPool).get((0, $dXAM5.BatchableSprite));\n        batchableSprite.renderable = sprite;\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n        this._gpuSpriteHash[sprite.uid] = batchableSprite;\n        sprite.on(\"destroyed\", this._destroyRenderableBound);\n        return batchableSprite;\n    }\n    destroy() {\n        for(const i in this._gpuSpriteHash)(0, $dLv5L.BigPool).return(this._gpuSpriteHash[i]);\n        this._gpuSpriteHash = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $4e32db524195383e$export$ffb847f6753f2536.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLPipes,\n        (0, $kFA6i.ExtensionType).WebGPUPipes,\n        (0, $kFA6i.ExtensionType).CanvasPipes\n    ],\n    name: \"sprite\"\n};\n\n});\n\nparcelRegister(\"8CF7d\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatcherPipe\", function () { return $c93f83e965240bfe$export$3cdd191b816b3f8a; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $lK0KY = parcelRequire(\"lK0KY\");\n\nvar $c0cbH = parcelRequire(\"c0cbH\");\n\"use strict\";\nconst $c93f83e965240bfe$var$_BatcherPipe = class _BatcherPipe {\n    constructor(renderer, adaptor){\n        this.state = (0, $lK0KY.State).for2d();\n        this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n        /** A record of all active batchers, keyed by their names */ this._activeBatches = /* @__PURE__ */ Object.create(null);\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this._adaptor.init?.(this);\n    }\n    static getBatcher(name) {\n        return new this._availableBatchers[name]();\n    }\n    buildStart(instructionSet) {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n        if (!batchers) {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n            batchers.default || (batchers.default = new (0, $c0cbH.DefaultBatcher)());\n        }\n        this._activeBatches = batchers;\n        this._activeBatch = this._activeBatches.default;\n        for(const i in this._activeBatches)this._activeBatches[i].begin();\n    }\n    addToBatch(batchableObject, instructionSet) {\n        if (this._activeBatch.name !== batchableObject.batcherName) {\n            this._activeBatch.break(instructionSet);\n            let batch = this._activeBatches[batchableObject.batcherName];\n            if (!batch) {\n                batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n            this._activeBatch = batch;\n        }\n        this._activeBatch.add(batchableObject);\n    }\n    break(instructionSet) {\n        this._activeBatch.break(instructionSet);\n    }\n    buildEnd(instructionSet) {\n        this._activeBatch.break(instructionSet);\n        const batches = this._activeBatches;\n        for(const i in batches){\n            const batch = batches[i];\n            const geometry = batch.geometry;\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n    upload(instructionSet) {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n        for(const i in batchers){\n            const batcher = batchers[i];\n            const geometry = batcher.geometry;\n            if (batcher.dirty) {\n                batcher.dirty = false;\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n    execute(batch) {\n        if (batch.action === \"startBatch\") {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n            this._adaptor.start(this, geometry, shader);\n        }\n        this._adaptor.execute(this, batch);\n    }\n    destroy() {\n        this.state = null;\n        this.renderer = null;\n        this._adaptor = null;\n        for(const i in this._activeBatches)this._activeBatches[i].destroy();\n        this._activeBatches = null;\n    }\n};\n/** @ignore */ $c93f83e965240bfe$var$_BatcherPipe.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLPipes,\n        (0, $kFA6i.ExtensionType).WebGPUPipes,\n        (0, $kFA6i.ExtensionType).CanvasPipes\n    ],\n    name: \"batch\"\n};\n$c93f83e965240bfe$var$_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet $c93f83e965240bfe$export$3cdd191b816b3f8a = $c93f83e965240bfe$var$_BatcherPipe;\n(0, $kFA6i.extensions).handleByMap((0, $kFA6i.ExtensionType).Batcher, $c93f83e965240bfe$export$3cdd191b816b3f8a._availableBatchers);\n(0, $kFA6i.extensions).add((0, $c0cbH.DefaultBatcher));\n\n});\n\nparcelRegister(\"aEM94\", function(module, exports) {\n\n$parcel$export(module.exports, \"AlphaMaskPipe\", function () { return $feb69f837ba6694a$export$cf1e9fa5acb94ac4; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $4kixb = parcelRequire(\"4kixb\");\n\nvar $hWIbe = parcelRequire(\"hWIbe\");\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $71eSK = parcelRequire(\"71eSK\");\n\nvar $6NgLT = parcelRequire(\"6NgLT\");\n\nvar $dLv5L = parcelRequire(\"dLv5L\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $2zAQe = parcelRequire(\"2zAQe\");\n\nvar $28usv = parcelRequire(\"28usv\");\n\"use strict\";\nconst $feb69f837ba6694a$var$tempBounds = new (0, $dtW0p.Bounds)();\nclass $feb69f837ba6694a$var$AlphaMaskEffect extends (0, $4kixb.FilterEffect) {\n    constructor(){\n        super();\n        this.filters = [\n            new (0, $hWIbe.MaskFilter)({\n                sprite: new (0, $6NgLT.Sprite)((0, $4YnyE.Texture).EMPTY),\n                inverse: false,\n                resolution: \"inherit\",\n                antialias: \"inherit\"\n            })\n        ];\n    }\n    get sprite() {\n        return this.filters[0].sprite;\n    }\n    set sprite(value) {\n        this.filters[0].sprite = value;\n    }\n    get inverse() {\n        return this.filters[0].inverse;\n    }\n    set inverse(value) {\n        this.filters[0].inverse = value;\n    }\n}\nclass $feb69f837ba6694a$export$cf1e9fa5acb94ac4 {\n    constructor(renderer){\n        this._activeMaskStage = [];\n        this._renderer = renderer;\n    }\n    push(mask, maskedContainer, instructionSet) {\n        const renderer = this._renderer;\n        renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"alphaMask\",\n            action: \"pushMaskBegin\",\n            mask: mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer: maskedContainer\n        });\n        mask.inverse = maskedContainer._maskOptions.inverse;\n        if (mask.renderMaskToTexture) {\n            const maskContainer = mask.mask;\n            maskContainer.includeInBuild = true;\n            maskContainer.collectRenderables(instructionSet, renderer, null);\n            maskContainer.includeInBuild = false;\n        }\n        renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"alphaMask\",\n            action: \"pushMaskEnd\",\n            mask: mask,\n            maskedContainer: maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false\n        });\n    }\n    pop(mask, _maskedContainer, instructionSet) {\n        const renderer = this._renderer;\n        renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"alphaMask\",\n            action: \"popMaskEnd\",\n            mask: mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false\n        });\n    }\n    execute(instruction) {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n        if (instruction.action === \"pushMaskBegin\") {\n            const filterEffect = (0, $dLv5L.BigPool).get($feb69f837ba6694a$var$AlphaMaskEffect);\n            filterEffect.inverse = instruction.inverse;\n            if (renderMask) {\n                instruction.mask.mask.measurable = true;\n                const bounds = (0, $71eSK.getGlobalBounds)(instruction.mask.mask, true, $feb69f837ba6694a$var$tempBounds);\n                instruction.mask.mask.measurable = false;\n                bounds.ceil();\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = (0, $2zAQe.TexturePool).getOptimalTexture(bounds.width, bounds.height, colorTextureSource._resolution, colorTextureSource.antialias);\n                renderer.renderTarget.push(filterTexture, true);\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 4294967295\n                });\n                const sprite = filterEffect.sprite;\n                sprite.texture = filterTexture;\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n                this._activeMaskStage.push({\n                    filterEffect: filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture: filterTexture\n                });\n            } else {\n                filterEffect.sprite = instruction.mask.mask;\n                this._activeMaskStage.push({\n                    filterEffect: filterEffect,\n                    maskedContainer: instruction.maskedContainer\n                });\n            }\n        } else if (instruction.action === \"pushMaskEnd\") {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n            if (renderMask) {\n                if (renderer.type === (0, $28usv.RendererType).WEBGL) renderer.renderTarget.finishRenderPass();\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n            renderer.filter.push({\n                renderPipeId: \"filter\",\n                action: \"pushFilter\",\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false\n            });\n        } else if (instruction.action === \"popMaskEnd\") {\n            renderer.filter.pop();\n            const maskData = this._activeMaskStage.pop();\n            if (renderMask) (0, $2zAQe.TexturePool).returnTexture(maskData.filterTexture);\n            (0, $dLv5L.BigPool).return(maskData.filterEffect);\n        }\n    }\n    destroy() {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n/** @ignore */ $feb69f837ba6694a$export$cf1e9fa5acb94ac4.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLPipes,\n        (0, $kFA6i.ExtensionType).WebGPUPipes,\n        (0, $kFA6i.ExtensionType).CanvasPipes\n    ],\n    name: \"alphaMask\"\n};\n\n});\nparcelRegister(\"hWIbe\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaskFilter\", function () { return $3609ed1daf09bc77$export$6d9155deae913447; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $022Ud = parcelRequire(\"022Ud\");\n\nvar $4WM3f = parcelRequire(\"4WM3f\");\n\nvar $7ZovY = parcelRequire(\"7ZovY\");\n\nvar $aDwba = parcelRequire(\"aDwba\");\n\nvar $buSTo = parcelRequire(\"buSTo\");\n\nvar $aF6YU = parcelRequire(\"aF6YU\");\n\nvar $e0KyB = parcelRequire(\"e0KyB\");\n\nvar $9zLZG = parcelRequire(\"9zLZG\");\n\"use strict\";\nclass $3609ed1daf09bc77$export$6d9155deae913447 extends (0, $buSTo.Filter) {\n    constructor(options){\n        const { sprite: sprite, ...rest } = options;\n        const textureMatrix = new (0, $aDwba.TextureMatrix)(sprite.texture);\n        const filterUniforms = new (0, $7ZovY.UniformGroup)({\n            uFilterMatrix: {\n                value: new (0, $0kbcf.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uMaskClamp: {\n                value: textureMatrix.uClampFrame,\n                type: \"vec4<f32>\"\n            },\n            uAlpha: {\n                value: 1,\n                type: \"f32\"\n            },\n            uInverse: {\n                value: options.inverse ? 1 : 0,\n                type: \"f32\"\n            }\n        });\n        const gpuProgram = (0, $4WM3f.GpuProgram).from({\n            vertex: {\n                source: $9zLZG.default,\n                entryPoint: \"mainVertex\"\n            },\n            fragment: {\n                source: $9zLZG.default,\n                entryPoint: \"mainFragment\"\n            }\n        });\n        const glProgram = (0, $022Ud.GlProgram).from({\n            vertex: $e0KyB.default,\n            fragment: $aF6YU.default,\n            name: \"mask-filter\"\n        });\n        super({\n            ...rest,\n            gpuProgram: gpuProgram,\n            glProgram: glProgram,\n            resources: {\n                filterUniforms: filterUniforms,\n                uMaskTexture: sprite.texture.source\n            }\n        });\n        this.sprite = sprite;\n        this._textureMatrix = textureMatrix;\n    }\n    set inverse(value) {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n    get inverse() {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n    apply(filterManager, input, output, clearMode) {\n        this._textureMatrix.texture = this.sprite.texture;\n        filterManager.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord);\n        this.resources.uMaskTexture = this.sprite.texture.source;\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n\n});\nparcelRegister(\"buSTo\", function(module, exports) {\n\n$parcel$export(module.exports, \"Filter\", function () { return $ef0e1a74e377e668$export$ec91da630f36d5ea; });\n\nvar $022Ud = parcelRequire(\"022Ud\");\n\nvar $4WM3f = parcelRequire(\"4WM3f\");\n\nvar $kmaR2 = parcelRequire(\"kmaR2\");\n\nvar $lK0KY = parcelRequire(\"lK0KY\");\n\"use strict\";\nconst $ef0e1a74e377e668$var$_Filter = class _Filter extends (0, $kmaR2.Shader) {\n    /**\n   * @param options - The optional parameters of this filter.\n   */ constructor(options){\n        options = {\n            ..._Filter.defaultOptions,\n            ...options\n        };\n        super(options);\n        /** If enabled is true the filter is applied, if false it will not. */ this.enabled = true;\n        /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */ this._state = (0, $lK0KY.State).for2d();\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n        if (typeof options.antialias === \"boolean\") this.antialias = options.antialias ? \"on\" : \"off\";\n        else this.antialias = options.antialias;\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n        this.addResource(\"uTexture\", 0, 1);\n    }\n    /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */ apply(filterManager, input, output, clearMode) {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n    /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */ get blendMode() {\n        return this._state.blendMode;\n    }\n    /** Sets the blend mode of the filter. */ set blendMode(value) {\n        this._state.blendMode = value;\n    }\n    /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */ static from(options) {\n        const { gpu: gpu, gl: gl, ...rest } = options;\n        let gpuProgram;\n        let glProgram;\n        if (gpu) gpuProgram = (0, $4WM3f.GpuProgram).from(gpu);\n        if (gl) glProgram = (0, $022Ud.GlProgram).from(gl);\n        return new _Filter({\n            gpuProgram: gpuProgram,\n            glProgram: glProgram,\n            ...rest\n        });\n    }\n};\n/**\n * The default filter settings\n * @static\n */ $ef0e1a74e377e668$var$_Filter.defaultOptions = {\n    blendMode: \"normal\",\n    resolution: 1,\n    padding: 0,\n    antialias: \"off\",\n    blendRequired: false,\n    clipToViewport: true\n};\nlet $ef0e1a74e377e668$export$ec91da630f36d5ea = $ef0e1a74e377e668$var$_Filter;\n\n});\n\nparcelRegister(\"aF6YU\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $ded3ae5cf2f06acd$export$2e2bcd8739ae039; });\nvar $ded3ae5cf2f06acd$export$2e2bcd8739ae039 = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\n});\n\nparcelRegister(\"e0KyB\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $89de36e8de039d6f$export$2e2bcd8739ae039; });\nvar $89de36e8de039d6f$export$2e2bcd8739ae039 = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\n});\n\nparcelRegister(\"9zLZG\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $63a973ed2c62b87c$export$2e2bcd8739ae039; });\nvar $63a973ed2c62b87c$export$2e2bcd8739ae039 = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\n});\n\n\n\nparcelRegister(\"2Xi2U\", function(module, exports) {\n\n$parcel$export(module.exports, \"ColorMaskPipe\", function () { return $fbcc864106d5c850$export$d4c3af11a9f163be; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nclass $fbcc864106d5c850$export$d4c3af11a9f163be {\n    constructor(renderer){\n        this._colorStack = [];\n        this._colorStackIndex = 0;\n        this._currentColor = 0;\n        this._renderer = renderer;\n    }\n    buildStart() {\n        this._colorStack[0] = 15;\n        this._colorStackIndex = 1;\n        this._currentColor = 15;\n    }\n    push(mask, _container, instructionSet) {\n        const renderer = this._renderer;\n        renderer.renderPipes.batch.break(instructionSet);\n        const colorStack = this._colorStack;\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n        const currentColor = this._colorStack[this._colorStackIndex];\n        if (currentColor !== this._currentColor) {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: \"colorMask\",\n                colorMask: currentColor,\n                canBundle: false\n            });\n        }\n        this._colorStackIndex++;\n    }\n    pop(_mask, _container, instructionSet) {\n        const renderer = this._renderer;\n        renderer.renderPipes.batch.break(instructionSet);\n        const colorStack = this._colorStack;\n        this._colorStackIndex--;\n        const currentColor = colorStack[this._colorStackIndex - 1];\n        if (currentColor !== this._currentColor) {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: \"colorMask\",\n                colorMask: currentColor,\n                canBundle: false\n            });\n        }\n    }\n    execute(instruction) {\n        const renderer = this._renderer;\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n    destroy() {\n        this._colorStack = null;\n    }\n}\n/** @ignore */ $fbcc864106d5c850$export$d4c3af11a9f163be.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLPipes,\n        (0, $kFA6i.ExtensionType).WebGPUPipes,\n        (0, $kFA6i.ExtensionType).CanvasPipes\n    ],\n    name: \"colorMask\"\n};\n\n});\n\nparcelRegister(\"kQDDm\", function(module, exports) {\n\n$parcel$export(module.exports, \"StencilMaskPipe\", function () { return $dca00021d25990d4$export$6875bb6e3a32089e; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $7gR5c = parcelRequire(\"7gR5c\");\n\nvar $6MbTD = parcelRequire(\"6MbTD\");\n\"use strict\";\nclass $dca00021d25990d4$export$6875bb6e3a32089e {\n    constructor(renderer){\n        // used when building and also when executing..\n        this._maskStackHash = {};\n        this._maskHash = /* @__PURE__ */ new WeakMap();\n        this._renderer = renderer;\n    }\n    push(mask, _container, instructionSet) {\n        var _a;\n        const effect = mask;\n        const renderer = this._renderer;\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n        instructionSet.add({\n            renderPipeId: \"stencilMask\",\n            action: \"pushMaskBegin\",\n            mask: mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false\n        });\n        const maskContainer = effect.mask;\n        maskContainer.includeInBuild = true;\n        if (!this._maskHash.has(effect)) this._maskHash.set(effect, {\n            instructionsStart: 0,\n            instructionsLength: 0\n        });\n        const maskData = this._maskHash.get(effect);\n        maskData.instructionsStart = instructionSet.instructionSize;\n        maskContainer.collectRenderables(instructionSet, renderer, null);\n        maskContainer.includeInBuild = false;\n        renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"stencilMask\",\n            action: \"pushMaskEnd\",\n            mask: mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false\n        });\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n        maskData.instructionsLength = instructionsLength;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n        (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    }\n    pop(mask, _container, instructionSet) {\n        const effect = mask;\n        const renderer = this._renderer;\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n        instructionSet.add({\n            renderPipeId: \"stencilMask\",\n            action: \"popMaskBegin\",\n            inverse: _container._maskOptions.inverse,\n            canBundle: false\n        });\n        const maskData = this._maskHash.get(mask);\n        for(let i = 0; i < maskData.instructionsLength; i++)instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        instructionSet.add({\n            renderPipeId: \"stencilMask\",\n            action: \"popMaskEnd\",\n            canBundle: false\n        });\n    }\n    execute(instruction) {\n        var _a;\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n        let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n        if (instruction.action === \"pushMaskBegin\") {\n            renderer.renderTarget.ensureDepthStencil();\n            renderer.stencil.setStencilMode((0, $6MbTD.STENCIL_MODES).RENDERING_MASK_ADD, maskStackIndex);\n            maskStackIndex++;\n            renderer.colorMask.setMask(0);\n        } else if (instruction.action === \"pushMaskEnd\") {\n            if (instruction.inverse) renderer.stencil.setStencilMode((0, $6MbTD.STENCIL_MODES).INVERSE_MASK_ACTIVE, maskStackIndex);\n            else renderer.stencil.setStencilMode((0, $6MbTD.STENCIL_MODES).MASK_ACTIVE, maskStackIndex);\n            renderer.colorMask.setMask(15);\n        } else if (instruction.action === \"popMaskBegin\") {\n            renderer.colorMask.setMask(0);\n            if (maskStackIndex !== 0) renderer.stencil.setStencilMode((0, $6MbTD.STENCIL_MODES).RENDERING_MASK_REMOVE, maskStackIndex);\n            else {\n                renderer.renderTarget.clear(null, (0, $7gR5c.CLEAR).STENCIL);\n                renderer.stencil.setStencilMode((0, $6MbTD.STENCIL_MODES).DISABLED, maskStackIndex);\n            }\n            maskStackIndex--;\n        } else if (instruction.action === \"popMaskEnd\") {\n            if (instruction.inverse) renderer.stencil.setStencilMode((0, $6MbTD.STENCIL_MODES).INVERSE_MASK_ACTIVE, maskStackIndex);\n            else renderer.stencil.setStencilMode((0, $6MbTD.STENCIL_MODES).MASK_ACTIVE, maskStackIndex);\n            renderer.colorMask.setMask(15);\n        }\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n    destroy() {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n$dca00021d25990d4$export$6875bb6e3a32089e.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLPipes,\n        (0, $kFA6i.ExtensionType).WebGPUPipes,\n        (0, $kFA6i.ExtensionType).CanvasPipes\n    ],\n    name: \"stencilMask\"\n};\n\n});\n\nparcelRegister(\"gHW7P\", function(module, exports) {\n\n$parcel$export(module.exports, \"BackgroundSystem\", function () { return $9b37bae8666c4298$export$c69cd65c8827ac23; });\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nconst $9b37bae8666c4298$var$_BackgroundSystem = class _BackgroundSystem {\n    constructor(){\n        this.clearBeforeRender = true;\n        this._backgroundColor = new (0, $hFslp.Color)(0);\n        this.color = this._backgroundColor;\n        this.alpha = 1;\n    }\n    /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */ init(options) {\n        options = {\n            ..._BackgroundSystem.defaultOptions,\n            ...options\n        };\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor;\n        this.alpha = options.backgroundAlpha;\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n    /** The background color to fill if not transparent */ get color() {\n        return this._backgroundColor;\n    }\n    set color(value) {\n        this._backgroundColor.setValue(value);\n    }\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */ get alpha() {\n        return this._backgroundColor.alpha;\n    }\n    set alpha(value) {\n        this._backgroundColor.setAlpha(value);\n    }\n    /** The background color as an [R, G, B, A] array. */ get colorRgba() {\n        return this._backgroundColor.toArray();\n    }\n    /**\n   * destroys the background system\n   * @internal\n   * @ignore\n   */ destroy() {}\n};\n/** @ignore */ $9b37bae8666c4298$var$_BackgroundSystem.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem,\n        (0, $kFA6i.ExtensionType).CanvasSystem\n    ],\n    name: \"background\",\n    priority: 0\n};\n/** default options used by the system */ $9b37bae8666c4298$var$_BackgroundSystem.defaultOptions = {\n    /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */ backgroundAlpha: 1,\n    /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */ backgroundColor: 0,\n    /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */ clearBeforeRender: true\n};\nlet $9b37bae8666c4298$export$c69cd65c8827ac23 = $9b37bae8666c4298$var$_BackgroundSystem;\n\n});\n\nparcelRegister(\"5DBVc\", function(module, exports) {\n\n$parcel$export(module.exports, \"BlendModePipe\", function () { return $88c4a63cbc1f5501$export$fee7195ef0d08bcf; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $4kixb = parcelRequire(\"4kixb\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\"use strict\";\nconst $88c4a63cbc1f5501$var$BLEND_MODE_FILTERS = {};\n(0, $kFA6i.extensions).handle((0, $kFA6i.ExtensionType).BlendMode, (value)=>{\n    if (!value.name) throw new Error(\"BlendMode extension must have a name property\");\n    $88c4a63cbc1f5501$var$BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value)=>{\n    delete $88c4a63cbc1f5501$var$BLEND_MODE_FILTERS[value.name];\n});\nclass $88c4a63cbc1f5501$export$fee7195ef0d08bcf {\n    constructor(renderer){\n        this._isAdvanced = false;\n        this._filterHash = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    /**\n   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n   * @param renderable - The renderable we are adding to the instruction set\n   * @param blendMode - The blend mode of the renderable\n   * @param instructionSet - The instruction set we are adding to\n   */ setBlendMode(renderable, blendMode, instructionSet) {\n        if (this._activeBlendMode === blendMode) {\n            if (this._isAdvanced) this._renderableList.push(renderable);\n            return;\n        }\n        this._activeBlendMode = blendMode;\n        if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);\n        this._isAdvanced = !!$88c4a63cbc1f5501$var$BLEND_MODE_FILTERS[blendMode];\n        if (this._isAdvanced) {\n            this._beginAdvancedBlendMode(instructionSet);\n            this._renderableList.push(renderable);\n        }\n    }\n    _beginAdvancedBlendMode(instructionSet) {\n        this._renderer.renderPipes.batch.break(instructionSet);\n        const blendMode = this._activeBlendMode;\n        if (!$88c4a63cbc1f5501$var$BLEND_MODE_FILTERS[blendMode]) {\n            (0, $c9aw6.warn)(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            return;\n        }\n        let filterEffect = this._filterHash[blendMode];\n        if (!filterEffect) {\n            filterEffect = this._filterHash[blendMode] = new (0, $4kixb.FilterEffect)();\n            filterEffect.filters = [\n                new $88c4a63cbc1f5501$var$BLEND_MODE_FILTERS[blendMode]()\n            ];\n        }\n        const instruction = {\n            renderPipeId: \"filter\",\n            action: \"pushFilter\",\n            renderables: [],\n            filterEffect: filterEffect,\n            canBundle: false\n        };\n        this._renderableList = instruction.renderables;\n        instructionSet.add(instruction);\n    }\n    _endAdvancedBlendMode(instructionSet) {\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"filter\",\n            action: \"popFilter\",\n            canBundle: false\n        });\n    }\n    /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   * @ignore\n   */ buildStart() {\n        this._isAdvanced = false;\n    }\n    /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   * @ignore\n   */ buildEnd(instructionSet) {\n        if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);\n    }\n    /**\n   * @internal\n   * @ignore\n   */ destroy() {\n        this._renderer = null;\n        this._renderableList = null;\n        for(const i in this._filterHash)this._filterHash[i].destroy();\n        this._filterHash = null;\n    }\n}\n/** @ignore */ $88c4a63cbc1f5501$export$fee7195ef0d08bcf.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLPipes,\n        (0, $kFA6i.ExtensionType).WebGPUPipes,\n        (0, $kFA6i.ExtensionType).CanvasPipes\n    ],\n    name: \"blendMode\"\n};\n\n});\n\nparcelRegister(\"l24yk\", function(module, exports) {\n\n$parcel$export(module.exports, \"ExtractSystem\", function () { return $4d12fdae2746e245$export$14c75b573db98096; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\"use strict\";\nconst $4d12fdae2746e245$var$imageTypes = {\n    png: \"image/png\",\n    jpg: \"image/jpeg\",\n    webp: \"image/webp\"\n};\nconst $4d12fdae2746e245$var$_ExtractSystem = class _ExtractSystem {\n    /** @param renderer - The renderer this System works for. */ constructor(renderer){\n        this._renderer = renderer;\n    }\n    _normalizeOptions(options, defaults = {}) {\n        if (options instanceof (0, $gRXu9.Container) || options instanceof (0, $4YnyE.Texture)) return {\n            target: options,\n            ...defaults\n        };\n        return {\n            ...defaults,\n            ...options\n        };\n    }\n    /**\n   * Will return a HTML Image of the target\n   * @param options - The options for creating the image, or the target to extract\n   * @returns - HTML Image of the target\n   */ async image(options) {\n        const image = new Image();\n        image.src = await this.base64(options);\n        return image;\n    }\n    /**\n   * Will return a base64 encoded string of this target. It works by calling\n   * `Extract.canvas` and then running toDataURL on that.\n   * @param options - The options for creating the image, or the target to extract\n   */ async base64(options) {\n        options = this._normalizeOptions(options, _ExtractSystem.defaultImageOptions);\n        const { format: format, quality: quality } = options;\n        const canvas = this.canvas(options);\n        if (canvas.toBlob !== void 0) return new Promise((resolve, reject)=>{\n            canvas.toBlob((blob)=>{\n                if (!blob) {\n                    reject(new Error(\"ICanvas.toBlob failed!\"));\n                    return;\n                }\n                const reader = new FileReader();\n                reader.onload = ()=>resolve(reader.result);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            }, $4d12fdae2746e245$var$imageTypes[format], quality);\n        });\n        if (canvas.toDataURL !== void 0) return canvas.toDataURL($4d12fdae2746e245$var$imageTypes[format], quality);\n        if (canvas.convertToBlob !== void 0) {\n            const blob = await canvas.convertToBlob({\n                type: $4d12fdae2746e245$var$imageTypes[format],\n                quality: quality\n            });\n            return new Promise((resolve, reject)=>{\n                const reader = new FileReader();\n                reader.onload = ()=>resolve(reader.result);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n        throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n    }\n    /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns - A Canvas element with the texture rendered on.\n   */ canvas(options) {\n        options = this._normalizeOptions(options);\n        const target = options.target;\n        const renderer = this._renderer;\n        if (target instanceof (0, $4YnyE.Texture)) return renderer.texture.generateCanvas(target);\n        const texture = renderer.textureGenerator.generateTexture(options);\n        const canvas = renderer.texture.generateCanvas(texture);\n        texture.destroy(true);\n        return canvas;\n    }\n    /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns - One-dimensional array containing the pixel data of the entire texture\n   */ pixels(options) {\n        options = this._normalizeOptions(options);\n        const target = options.target;\n        const renderer = this._renderer;\n        const texture = target instanceof (0, $4YnyE.Texture) ? target : renderer.textureGenerator.generateTexture(options);\n        const pixelInfo = renderer.texture.getPixels(texture);\n        if (target instanceof (0, $gRXu9.Container)) texture.destroy(true);\n        return pixelInfo;\n    }\n    /**\n   * Will return a texture of the target\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns - A texture of the target\n   */ texture(options) {\n        options = this._normalizeOptions(options);\n        if (options.target instanceof (0, $4YnyE.Texture)) return options.target;\n        return this._renderer.textureGenerator.generateTexture(options);\n    }\n    /**\n   * Will extract a HTMLImage of the target and download it\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   */ download(options) {\n        options = this._normalizeOptions(options);\n        const canvas = this.canvas(options);\n        const link = document.createElement(\"a\");\n        link.download = options.filename ?? \"image.png\";\n        link.href = canvas.toDataURL(\"image/png\");\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n    /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * @param options - The options for logging the image, or the target to log\n   */ log(options) {\n        const width = options.width ?? 200;\n        options = this._normalizeOptions(options);\n        const canvas = this.canvas(options);\n        const base64 = canvas.toDataURL();\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n        const style = [\n            \"font-size: 1px;\",\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            \"background-size: contain;\"\n        ].join(\" \");\n        console.log(\"%c \", style);\n    }\n    destroy() {\n        this._renderer = null;\n    }\n};\n/** @ignore */ $4d12fdae2746e245$var$_ExtractSystem.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem\n    ],\n    name: \"extract\"\n};\n/** Default options for creating an image. */ $4d12fdae2746e245$var$_ExtractSystem.defaultImageOptions = {\n    /** The format of the image. */ format: \"png\",\n    /** The quality of the image. */ quality: 1\n};\nlet $4d12fdae2746e245$export$14c75b573db98096 = $4d12fdae2746e245$var$_ExtractSystem;\n\n});\n\nparcelRegister(\"a81eN\", function(module, exports) {\n\n$parcel$export(module.exports, \"GenerateTextureSystem\", function () { return $f3b15137a4f45c81$export$690776504ee197a6; });\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $4316K = parcelRequire(\"4316K\");\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\n\nvar $67iQf = parcelRequire(\"67iQf\");\n\"use strict\";\nconst $f3b15137a4f45c81$var$tempRect = new (0, $ec4lc.Rectangle)();\nconst $f3b15137a4f45c81$var$tempBounds = new (0, $dtW0p.Bounds)();\nconst $f3b15137a4f45c81$var$noColor = [\n    0,\n    0,\n    0,\n    0\n];\nclass $f3b15137a4f45c81$export$690776504ee197a6 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    /**\n   * A Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your container is complicated and needs to be reused multiple times.\n   * @param {GenerateTextureOptions | Container} options - Generate texture options.\n   * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n   * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n   * @param {number} [options.resolution] - The resolution of the texture being generated.\n   *        if no region is specified, defaults to the local bounds of the container.\n   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n   * @returns a shiny new texture of the container passed in\n   */ generateTexture(options) {\n        if (options instanceof (0, $gRXu9.Container)) options = {\n            target: options,\n            frame: void 0,\n            textureSourceOptions: {},\n            resolution: void 0\n        };\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n        const container = options.target;\n        let clearColor = options.clearColor;\n        if (clearColor) {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n            clearColor = isRGBAArray ? clearColor : (0, $hFslp.Color).shared.setValue(clearColor).toArray();\n        } else clearColor = $f3b15137a4f45c81$var$noColor;\n        const region = options.frame?.copyTo($f3b15137a4f45c81$var$tempRect) || (0, $4316K.getLocalBounds)(container, $f3b15137a4f45c81$var$tempBounds).rectangle;\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n        const target = (0, $67iQf.RenderTexture).create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution: resolution,\n            antialias: antialias\n        });\n        const transform = (0, $0kbcf.Matrix).shared.translate(-region.x, -region.y);\n        this._renderer.render({\n            container: container,\n            transform: transform,\n            target: target,\n            clearColor: clearColor\n        });\n        target.source.updateMipmaps();\n        return target;\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $f3b15137a4f45c81$export$690776504ee197a6.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem\n    ],\n    name: \"textureGenerator\"\n};\n\n});\nparcelRegister(\"67iQf\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderTexture\", function () { return $12e34bf3db3ada0e$export$813984f7330b4d72; });\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\"use strict\";\nclass $12e34bf3db3ada0e$export$813984f7330b4d72 extends (0, $4YnyE.Texture) {\n    static create(options) {\n        return new $12e34bf3db3ada0e$export$813984f7330b4d72({\n            source: new (0, $3dWsL.TextureSource)(options)\n        });\n    }\n    /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */ resize(width, height, resolution) {\n        this.source.resize(width, height, resolution);\n        return this;\n    }\n}\n\n});\n\n\nparcelRegister(\"4fWAX\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlobalUniformSystem\", function () { return $6ad9c034e5a8e39d$export$b9b6391a4528dd78; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $hbjPo = parcelRequire(\"hbjPo\");\n\nvar $8n8Vu = parcelRequire(\"8n8Vu\");\n\nvar $lc03N = parcelRequire(\"lc03N\");\n\nvar $28usv = parcelRequire(\"28usv\");\n\nvar $7ZovY = parcelRequire(\"7ZovY\");\n\"use strict\";\nclass $6ad9c034e5a8e39d$export$b9b6391a4528dd78 {\n    constructor(renderer){\n        this._stackIndex = 0;\n        this._globalUniformDataStack = [];\n        this._uniformsPool = [];\n        this._activeUniforms = [];\n        this._bindGroupPool = [];\n        this._activeBindGroups = [];\n        this._renderer = renderer;\n    }\n    reset() {\n        this._stackIndex = 0;\n        for(let i = 0; i < this._activeUniforms.length; i++)this._uniformsPool.push(this._activeUniforms[i]);\n        for(let i = 0; i < this._activeBindGroups.length; i++)this._bindGroupPool.push(this._activeBindGroups[i]);\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n    start(options) {\n        this.reset();\n        this.push(options);\n    }\n    bind({ size: size, projectionMatrix: projectionMatrix, worldTransformMatrix: worldTransformMatrix, worldColor: worldColor, offset: offset }) {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new (0, $0kbcf.Matrix)(),\n            worldColor: 4294967295,\n            offset: new (0, $hbjPo.Point)()\n        };\n        const globalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null\n        };\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n        this._activeUniforms.push(uniformGroup);\n        const uniforms = uniformGroup.uniforms;\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n        uniforms.uResolution = globalUniformData.resolution;\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n        (0, $8n8Vu.color32BitToUniform)(globalUniformData.worldColor, uniforms.uWorldColorAlpha, 0);\n        uniformGroup.update();\n        let bindGroup;\n        if (this._renderer.renderPipes.uniformBatch) bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        else {\n            bindGroup = this._bindGroupPool.pop() || new (0, $lc03N.BindGroup)();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n        globalUniformData.bindGroup = bindGroup;\n        this._currentGlobalUniformData = globalUniformData;\n    }\n    push(options) {\n        this.bind(options);\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n    pop() {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n        if (this._renderer.type === (0, $28usv.RendererType).WEBGL) this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n    get bindGroup() {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n    get globalUniformData() {\n        return this._currentGlobalUniformData;\n    }\n    get uniformGroup() {\n        return this._currentGlobalUniformData.bindGroup.resources[0];\n    }\n    _createUniforms() {\n        const globalUniforms = new (0, $7ZovY.UniformGroup)({\n            uProjectionMatrix: {\n                value: new (0, $0kbcf.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uWorldTransformMatrix: {\n                value: new (0, $0kbcf.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uResolution: {\n                value: [\n                    0,\n                    0\n                ],\n                type: \"vec2<f32>\"\n            }\n        }, {\n            isStatic: true\n        });\n        return globalUniforms;\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $6ad9c034e5a8e39d$export$b9b6391a4528dd78.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem,\n        (0, $kFA6i.ExtensionType).CanvasSystem\n    ],\n    name: \"globalUniforms\"\n};\n\n});\n\nparcelRegister(\"edAuX\", function(module, exports) {\n\n$parcel$export(module.exports, \"SchedulerSystem\", function () { return $442cc62d6f04d660$export$b11154c55e5f16dd; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $k3VU1 = parcelRequire(\"k3VU1\");\n\"use strict\";\nlet $442cc62d6f04d660$var$uid = 1;\nclass $442cc62d6f04d660$export$b11154c55e5f16dd {\n    constructor(){\n        this._tasks = [];\n        /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */ this._offset = 0;\n    }\n    /** Initializes the scheduler system and starts the ticker. */ init() {\n        (0, $k3VU1.Ticker).system.add(this._update, this);\n    }\n    /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */ repeat(func, duration, useOffset = true) {\n        const id = $442cc62d6f04d660$var$uid++;\n        let offset = 0;\n        if (useOffset) {\n            this._offset += 1e3;\n            offset = this._offset;\n        }\n        this._tasks.push({\n            func: func,\n            duration: duration,\n            start: performance.now(),\n            offset: offset,\n            last: performance.now(),\n            repeat: true,\n            id: id\n        });\n        return id;\n    }\n    /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */ cancel(id) {\n        for(let i = 0; i < this._tasks.length; i++)if (this._tasks[i].id === id) {\n            this._tasks.splice(i, 1);\n            return;\n        }\n    }\n    /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */ _update() {\n        const now = performance.now();\n        for(let i = 0; i < this._tasks.length; i++){\n            const task = this._tasks[i];\n            if (now - task.offset - task.last >= task.duration) {\n                const elapsed = now - task.start;\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n    /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   * @ignore\n   */ destroy() {\n        (0, $k3VU1.Ticker).system.remove(this._update, this);\n        this._tasks.length = 0;\n    }\n}\n/** @ignore */ $442cc62d6f04d660$export$b11154c55e5f16dd.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem,\n        (0, $kFA6i.ExtensionType).CanvasSystem\n    ],\n    name: \"scheduler\",\n    priority: 0\n};\n\n});\n\nparcelRegister(\"gR8f7\", function(module, exports) {\n\n$parcel$export(module.exports, \"HelloSystem\", function () { return $4ee7b6e07c3982ee$export$63ce3e62fccb6f39; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $11KLe = parcelRequire(\"11KLe\");\n\nvar $28usv = parcelRequire(\"28usv\");\n\"use strict\";\nclass $4ee7b6e07c3982ee$export$63ce3e62fccb6f39 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */ init(options) {\n        if (options.hello) {\n            let name = this._renderer.name;\n            if (this._renderer.type === (0, $28usv.RendererType).WEBGL) name += ` ${this._renderer.context.webGLVersion}`;\n            (0, $11KLe.sayHello)(name);\n        }\n    }\n}\n/** @ignore */ $4ee7b6e07c3982ee$export$63ce3e62fccb6f39.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem,\n        (0, $kFA6i.ExtensionType).CanvasSystem\n    ],\n    name: \"hello\",\n    priority: -2\n};\n/** The default options for the system. */ $4ee7b6e07c3982ee$export$63ce3e62fccb6f39.defaultOptions = {\n    /** {@link WebGLOptions.hello} */ hello: false\n};\n\n});\nparcelRegister(\"11KLe\", function(module, exports) {\n\n$parcel$export(module.exports, \"sayHello\", function () { return $8b08ee031533c563$export$2c6a96c059a06e7c; });\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $2wPJh = parcelRequire(\"2wPJh\");\n\"use strict\";\nlet $8b08ee031533c563$var$saidHello = false;\nfunction $8b08ee031533c563$export$2c6a96c059a06e7c(type) {\n    if ($8b08ee031533c563$var$saidHello) return;\n    if ((0, $d0V4H.DOMAdapter).get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${(0, $2wPJh.VERSION)} (${type}) http://www.pixijs.com/\n\n`,\n            \"background: #E72264; padding:5px 0;\",\n            \"background: #6CA2EA; padding:5px 0;\",\n            \"background: #B5D33D; padding:5px 0;\",\n            \"background: #FED23F; padding:5px 0;\",\n            \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n            \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n        ];\n        globalThis.console.log(...args);\n    } else if (globalThis.console) globalThis.console.log(`PixiJS ${(0, $2wPJh.VERSION)} - ${type} - http://www.pixijs.com/`);\n    $8b08ee031533c563$var$saidHello = true;\n}\n\n});\n\n\nparcelRegister(\"7aCaM\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderableGCSystem\", function () { return $4a64db30d3a26925$export$a2204aeb1cc3b5ea; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $5ytxW = parcelRequire(\"5ytxW\");\n\"use strict\";\nlet $4a64db30d3a26925$var$renderableGCTick = 0;\nconst $4a64db30d3a26925$var$_RenderableGCSystem = class _RenderableGCSystem {\n    /**\n   * Creates a new RenderableGCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */ constructor(renderer){\n        /** Array of renderables being tracked for garbage collection */ this._managedRenderables = [];\n        /** Array of hash objects being tracked for cleanup */ this._managedHashes = [];\n        /** Array of arrays being tracked for cleanup */ this._managedArrays = [];\n        this._renderer = renderer;\n    }\n    /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options for the renderer\n   */ init(options) {\n        options = {\n            ..._RenderableGCSystem.defaultOptions,\n            ...options\n        };\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n        this.enabled = options.renderableGCActive;\n    }\n    /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */ get enabled() {\n        return !!this._handler;\n    }\n    /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */ set enabled(value) {\n        if (this.enabled === value) return;\n        if (value) {\n            this._handler = this._renderer.scheduler.repeat(()=>this.run(), this._frequency, false);\n            this._hashHandler = this._renderer.scheduler.repeat(()=>{\n                for (const hash of this._managedHashes)hash.context[hash.hash] = (0, $5ytxW.cleanHash)(hash.context[hash.hash]);\n            }, this._frequency);\n            this._arrayHandler = this._renderer.scheduler.repeat(()=>{\n                for (const array of this._managedArrays)(0, $5ytxW.cleanArray)(array.context[array.hash]);\n            }, this._frequency);\n        } else {\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n    /**\n   * Adds a hash table to be managed by the garbage collector.\n   * @param context - The object containing the hash table\n   * @param hash - The property name of the hash table\n   */ addManagedHash(context, hash) {\n        this._managedHashes.push({\n            context: context,\n            hash: hash\n        });\n    }\n    /**\n   * Adds an array to be managed by the garbage collector.\n   * @param context - The object containing the array\n   * @param hash - The property name of the array\n   */ addManagedArray(context, hash) {\n        this._managedArrays.push({\n            context: context,\n            hash: hash\n        });\n    }\n    /**\n   * Updates the GC timestamp and tracking before rendering.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */ prerender({ container: container }) {\n        this._now = performance.now();\n        container.renderGroup.gcTick = $4a64db30d3a26925$var$renderableGCTick++;\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n    /**\n   * Starts tracking a renderable for garbage collection.\n   * @param renderable - The renderable to track\n   */ addRenderable(renderable) {\n        if (!this.enabled) return;\n        if (renderable._lastUsed === -1) {\n            this._managedRenderables.push(renderable);\n            renderable.once(\"destroyed\", this._removeRenderable, this);\n        }\n        renderable._lastUsed = this._now;\n    }\n    /**\n   * Performs garbage collection by cleaning up unused renderables.\n   * Removes renderables that haven't been used for longer than maxUnusedTime.\n   */ run() {\n        const now = this._now;\n        const managedRenderables = this._managedRenderables;\n        const renderPipes = this._renderer.renderPipes;\n        let offset = 0;\n        for(let i = 0; i < managedRenderables.length; i++){\n            const renderable = managedRenderables[i];\n            if (renderable === null) {\n                offset++;\n                continue;\n            }\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n            if ((renderGroup?.gcTick ?? 0) === currentTick) renderable._lastUsed = now;\n            if (now - renderable._lastUsed > this.maxUnusedTime) {\n                if (!renderable.destroyed) {\n                    const rp = renderPipes;\n                    if (renderGroup) renderGroup.structureDidChange = true;\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n                renderable._lastUsed = -1;\n                offset++;\n                renderable.off(\"destroyed\", this._removeRenderable, this);\n            } else managedRenderables[i - offset] = renderable;\n        }\n        managedRenderables.length -= offset;\n    }\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */ destroy() {\n        this.enabled = false;\n        this._renderer = null;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n    /**\n   * Removes a renderable from being tracked when it's destroyed.\n   * @param renderable - The renderable to stop tracking\n   */ _removeRenderable(renderable) {\n        const index = this._managedRenderables.indexOf(renderable);\n        if (index >= 0) {\n            renderable.off(\"destroyed\", this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n    /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */ _updateInstructionGCTick(renderGroup, gcTick) {\n        renderGroup.instructionSet.gcTick = gcTick;\n        for (const child of renderGroup.renderGroupChildren)this._updateInstructionGCTick(child, gcTick);\n    }\n};\n/**\n * Extension metadata for registering this system with the renderer.\n * @ignore\n */ $4a64db30d3a26925$var$_RenderableGCSystem.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem\n    ],\n    name: \"renderableGC\",\n    priority: 0\n};\n/**\n * Default configuration options for the garbage collection system.\n * These can be overridden when initializing the renderer.\n */ $4a64db30d3a26925$var$_RenderableGCSystem.defaultOptions = {\n    /** Enable/disable the garbage collector */ renderableGCActive: true,\n    /** Time in ms before an unused resource is collected (default 1 minute) */ renderableGCMaxUnusedTime: 6e4,\n    /** How often to run garbage collection in ms (default 30 seconds) */ renderableGCFrequency: 3e4\n};\nlet $4a64db30d3a26925$export$a2204aeb1cc3b5ea = $4a64db30d3a26925$var$_RenderableGCSystem;\n\n});\nparcelRegister(\"5ytxW\", function(module, exports) {\n\n$parcel$export(module.exports, \"cleanHash\", function () { return $6d707366e75bfa04$export$e315d661f2bb796; });\n$parcel$export(module.exports, \"cleanArray\", function () { return $6d707366e75bfa04$export$c39b210f955bc1b8; });\n\"use strict\";\nfunction $6d707366e75bfa04$export$e315d661f2bb796(hash) {\n    let clean = false;\n    for(const i in hash)if (hash[i] == void 0) {\n        clean = true;\n        break;\n    }\n    if (!clean) return hash;\n    const cleanHash2 = /* @__PURE__ */ Object.create(null);\n    for(const i in hash){\n        const value = hash[i];\n        if (value) cleanHash2[i] = value;\n    }\n    return cleanHash2;\n}\nfunction $6d707366e75bfa04$export$c39b210f955bc1b8(arr) {\n    let offset = 0;\n    for(let i = 0; i < arr.length; i++)if (arr[i] == void 0) offset++;\n    else arr[i - offset] = arr[i];\n    arr.length -= offset;\n    return arr;\n}\n\n});\n\n\nparcelRegister(\"hriU1\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureGCSystem\", function () { return $649fd78d5232da48$export$a47b032752d8e393; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nconst $649fd78d5232da48$var$_TextureGCSystem = class _TextureGCSystem {\n    /** @param renderer - The renderer this System works for. */ constructor(renderer){\n        this._renderer = renderer;\n        this.count = 0;\n        this.checkCount = 0;\n    }\n    init(options) {\n        options = {\n            ..._TextureGCSystem.defaultOptions,\n            ...options\n        };\n        this.checkCountMax = options.textureGCCheckCountMax;\n        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n        this.active = options.textureGCActive;\n    }\n    /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */ postrender() {\n        if (!this._renderer.renderingToScreen) return;\n        this.count++;\n        if (!this.active) return;\n        this.checkCount++;\n        if (this.checkCount > this.checkCountMax) {\n            this.checkCount = 0;\n            this.run();\n        }\n    }\n    /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */ run() {\n        const managedTextures = this._renderer.texture.managedTextures;\n        for(let i = 0; i < managedTextures.length; i++){\n            const texture = managedTextures[i];\n            if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {\n                texture._touched = -1;\n                texture.unload();\n            }\n        }\n    }\n    destroy() {\n        this._renderer = null;\n    }\n};\n/** @ignore */ $649fd78d5232da48$var$_TextureGCSystem.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem\n    ],\n    name: \"textureGC\"\n};\n/** default options for the TextureGCSystem */ $649fd78d5232da48$var$_TextureGCSystem.defaultOptions = {\n    /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */ textureGCActive: true,\n    /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystem.textureGCMaxIdle}\n   */ textureGCAMaxIdle: null,\n    /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */ textureGCMaxIdle: 3600,\n    /**\n   * Frames between two garbage collections.\n   * @default 600\n   */ textureGCCheckCountMax: 600\n};\nlet $649fd78d5232da48$export$a47b032752d8e393 = $649fd78d5232da48$var$_TextureGCSystem;\n\n});\n\nparcelRegister(\"k3485\", function(module, exports) {\n\n$parcel$export(module.exports, \"ViewSystem\", function () { return $18960edfc482c0eb$export$6f21c3d5af6602af; });\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $5R6vn = parcelRequire(\"5R6vn\");\n\nvar $i26u7 = parcelRequire(\"i26u7\");\n\"use strict\";\nconst $18960edfc482c0eb$var$_ViewSystem = class _ViewSystem {\n    /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * @member {boolean}\n   */ get autoDensity() {\n        return this.texture.source.autoDensity;\n    }\n    set autoDensity(value) {\n        this.texture.source.autoDensity = value;\n    }\n    /** The resolution / device pixel ratio of the renderer. */ get resolution() {\n        return this.texture.source._resolution;\n    }\n    set resolution(value) {\n        this.texture.source.resize(this.texture.source.width, this.texture.source.height, value);\n    }\n    /**\n   * initiates the view system\n   * @param options - the options for the view\n   */ init(options) {\n        options = {\n            ..._ViewSystem.defaultOptions,\n            ...options\n        };\n        if (options.view) {\n            (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"ViewSystem.view has been renamed to ViewSystem.canvas\");\n            options.canvas = options.view;\n        }\n        this.screen = new (0, $ec4lc.Rectangle)(0, 0, options.width, options.height);\n        this.canvas = options.canvas || (0, $d0V4H.DOMAdapter).get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = (0, $i26u7.getCanvasTexture)(this.canvas, options);\n        this.renderTarget = new (0, $5R6vn.RenderTarget)({\n            colorTextures: [\n                this.texture\n            ],\n            depth: !!options.depth,\n            isRoot: true\n        });\n        this.texture.source.transparent = options.backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n    /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */ resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n    /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or \"false\".\n   * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n   */ destroy(options = false) {\n        const removeView = typeof options === \"boolean\" ? options : !!options?.removeView;\n        if (removeView && this.canvas.parentNode) this.canvas.parentNode.removeChild(this.canvas);\n    }\n};\n/** @ignore */ $18960edfc482c0eb$var$_ViewSystem.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem,\n        (0, $kFA6i.ExtensionType).CanvasSystem\n    ],\n    name: \"view\",\n    priority: 0\n};\n/** The default options for the view system. */ $18960edfc482c0eb$var$_ViewSystem.defaultOptions = {\n    /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */ width: 800,\n    /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */ height: 600,\n    /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */ autoDensity: false,\n    /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */ antialias: false\n};\nlet $18960edfc482c0eb$export$6f21c3d5af6602af = $18960edfc482c0eb$var$_ViewSystem;\n\n});\nparcelRegister(\"5R6vn\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderTarget\", function () { return $f7ccc2b6d6689500$export$efcb1f8bf367cbfb; });\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\"use strict\";\nconst $f7ccc2b6d6689500$var$_RenderTarget = class _RenderTarget {\n    /**\n   * @param [descriptor] - Options for creating a render target.\n   */ constructor(descriptor = {}){\n        /** unique id for this render target */ this.uid = (0, $fTJzX.uid)(\"renderTarget\");\n        /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */ this.colorTextures = [];\n        this.dirtyId = 0;\n        this.isRoot = false;\n        this._size = new Float32Array(2);\n        /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */ this._managedColorTextures = false;\n        descriptor = {\n            ..._RenderTarget.defaultOptions,\n            ...descriptor\n        };\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n        if (typeof descriptor.colorTextures === \"number\") {\n            this._managedColorTextures = true;\n            for(let i = 0; i < descriptor.colorTextures; i++)this.colorTextures.push(new (0, $3dWsL.TextureSource)({\n                width: descriptor.width,\n                height: descriptor.height,\n                resolution: descriptor.resolution,\n                antialias: descriptor.antialias\n            }));\n        } else {\n            this.colorTextures = [\n                ...descriptor.colorTextures.map((texture)=>texture.source)\n            ];\n            const colorSource = this.colorTexture.source;\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n        this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n        if (descriptor.depthStencilTexture || this.stencil) {\n            if (descriptor.depthStencilTexture instanceof (0, $4YnyE.Texture) || descriptor.depthStencilTexture instanceof (0, $3dWsL.TextureSource)) this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            else this.ensureDepthStencilTexture();\n        }\n    }\n    get size() {\n        const _size = this._size;\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n        return _size;\n    }\n    get width() {\n        return this.colorTexture.source.width;\n    }\n    get height() {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth() {\n        return this.colorTexture.source.pixelWidth;\n    }\n    get pixelHeight() {\n        return this.colorTexture.source.pixelHeight;\n    }\n    get resolution() {\n        return this.colorTexture.source._resolution;\n    }\n    get colorTexture() {\n        return this.colorTextures[0];\n    }\n    onSourceResize(source) {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n    /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   * @ignore\n   */ ensureDepthStencilTexture() {\n        if (!this.depthStencilTexture) this.depthStencilTexture = new (0, $3dWsL.TextureSource)({\n            width: this.width,\n            height: this.height,\n            resolution: this.resolution,\n            format: \"depth24plus-stencil8\",\n            autoGenerateMipmaps: false,\n            antialias: false,\n            mipLevelCount: 1\n        });\n    }\n    resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n        this.dirtyId++;\n        this.colorTextures.forEach((colorTexture, i)=>{\n            if (skipColorTexture && i === 0) return;\n            colorTexture.source.resize(width, height, resolution);\n        });\n        if (this.depthStencilTexture) this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n    destroy() {\n        this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n        if (this._managedColorTextures) this.colorTextures.forEach((texture)=>{\n            texture.destroy();\n        });\n        if (this.depthStencilTexture) {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n};\n/** The default options for a render target */ $f7ccc2b6d6689500$var$_RenderTarget.defaultOptions = {\n    /** the width of the RenderTarget */ width: 0,\n    /** the height of the RenderTarget */ height: 0,\n    /** the resolution of the RenderTarget */ resolution: 1,\n    /** an array of textures, or a number indicating how many color textures there should be */ colorTextures: 1,\n    /** should this render target have a stencil buffer? */ stencil: false,\n    /** should this render target have a depth buffer? */ depth: false,\n    /** should this render target be antialiased? */ antialias: false,\n    // save on perf by default!\n    /** is this a root element, true if this is gl context owners render target */ isRoot: false\n};\nlet $f7ccc2b6d6689500$export$efcb1f8bf367cbfb = $f7ccc2b6d6689500$var$_RenderTarget;\n\n});\n\nparcelRegister(\"i26u7\", function(module, exports) {\n\n$parcel$export(module.exports, \"getCanvasTexture\", function () { return $6599c9e0f799f365$export$f2bcae39472d9516; });\n\nvar $9HCqA = parcelRequire(\"9HCqA\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\"use strict\";\nconst $6599c9e0f799f365$var$canvasCache = /* @__PURE__ */ new Map();\nfunction $6599c9e0f799f365$export$f2bcae39472d9516(canvas, options) {\n    if (!$6599c9e0f799f365$var$canvasCache.has(canvas)) {\n        const texture = new (0, $4YnyE.Texture)({\n            source: new (0, $9HCqA.CanvasSource)({\n                resource: canvas,\n                ...options\n            })\n        });\n        const onDestroy = ()=>{\n            if ($6599c9e0f799f365$var$canvasCache.get(canvas) === texture) $6599c9e0f799f365$var$canvasCache.delete(canvas);\n        };\n        texture.once(\"destroy\", onDestroy);\n        texture.source.once(\"destroy\", onDestroy);\n        $6599c9e0f799f365$var$canvasCache.set(canvas, texture);\n    }\n    return $6599c9e0f799f365$var$canvasCache.get(canvas);\n}\nfunction $6599c9e0f799f365$export$57935aeb65aa90cf(canvas) {\n    return $6599c9e0f799f365$var$canvasCache.has(canvas);\n}\n\n});\n\n\n\nparcelRegister(\"4Eb2h\", function(module, exports) {\n\n$parcel$export(module.exports, \"UboSystem\", function () { return $f107c1d33cf4bf55$export$649c859891b4f4a9; });\n\nvar $bjxKI = parcelRequire(\"bjxKI\");\n\nvar $3wxNZ = parcelRequire(\"3wxNZ\");\n\nvar $iZU4m = parcelRequire(\"iZU4m\");\n\"use strict\";\nclass $f107c1d33cf4bf55$export$649c859891b4f4a9 {\n    constructor(adaptor){\n        /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */ this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n        this._adaptor = adaptor;\n        this._systemCheck();\n    }\n    /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */ _systemCheck() {\n        if (!(0, $bjxKI.unsafeEvalSupported)()) throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n    ensureUniformGroup(uniformGroup) {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n        uniformGroup.buffer || (uniformGroup.buffer = new (0, $3wxNZ.Buffer)({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: (0, $iZU4m.BufferUsage).UNIFORM | (0, $iZU4m.BufferUsage).COPY_DST\n        }));\n    }\n    getUniformGroupData(uniformGroup) {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n    _initUniformGroup(uniformGroup) {\n        const uniformGroupSignature = uniformGroup._signature;\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n        if (!uniformData) {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i)=>uniformGroup.uniformStructures[i]);\n            const layout = this._adaptor.createUboElements(elements);\n            const syncFunction = this._generateUboSync(layout.uboElements);\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout: layout,\n                syncFunction: syncFunction\n            };\n        }\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n    _generateUboSync(uboElements) {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n    syncUniformGroup(uniformGroup, data, offset) {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n        uniformGroup.buffer || (uniformGroup.buffer = new (0, $3wxNZ.Buffer)({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: (0, $iZU4m.BufferUsage).UNIFORM | (0, $iZU4m.BufferUsage).COPY_DST\n        }));\n        let dataInt32 = null;\n        if (!data) {\n            data = uniformGroup.buffer.data;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset || (offset = 0);\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n        return true;\n    }\n    updateUniformGroup(uniformGroup) {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n        const synced = this.syncUniformGroup(uniformGroup);\n        uniformGroup.buffer.update();\n        return synced;\n    }\n    destroy() {\n        this._syncFunctionHash = null;\n    }\n}\n\n});\n\nparcelRegister(\"bxR1A\", function(module, exports) {\n\n$parcel$export(module.exports, \"createUboSyncFunction\", function () { return $af6de44cf94e2b7c$export$d72cdd5376f8af8e; });\n\nvar $5fn1y = parcelRequire(\"5fn1y\");\n\"use strict\";\nfunction $af6de44cf94e2b7c$export$d72cdd5376f8af8e(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n    const funcFragments = [\n        `\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `\n    ];\n    let prev = 0;\n    for(let i = 0; i < uboElements.length; i++){\n        const uboElement = uboElements[i];\n        const name = uboElement.data.name;\n        let parsed = false;\n        let offset = 0;\n        for(let j = 0; j < (0, $5fn1y.uniformParsers).length; j++){\n            const uniformParser = (0, $5fn1y.uniformParsers)[j];\n            if (uniformParser.test(uboElement.data)) {\n                offset = uboElement.offset / 4;\n                funcFragments.push(`name = \"${name}\";`, `offset += ${offset - prev};`, (0, $5fn1y.uniformParsers)[j][parserCode] || (0, $5fn1y.uniformParsers)[j].ubo);\n                parsed = true;\n                break;\n            }\n        }\n        if (!parsed) {\n            if (uboElement.data.size > 1) {\n                offset = uboElement.offset / 4;\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            } else {\n                const template = singleSettersMap[uboElement.data.type];\n                offset = uboElement.offset / 4;\n                funcFragments.push(/* wgsl */ `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n        prev = offset;\n    }\n    const fragmentSrc = funcFragments.join(\"\\n\");\n    return new Function(\"uv\", \"data\", \"dataInt32\", \"offset\", fragmentSrc);\n}\n\n});\nparcelRegister(\"5fn1y\", function(module, exports) {\n\n$parcel$export(module.exports, \"uniformParsers\", function () { return $91f1219963559a5d$export$cf9f41a7e506e2d2; });\n\"use strict\";\nconst $91f1219963559a5d$export$cf9f41a7e506e2d2 = [\n    // uploading pixi matrix object to mat3\n    {\n        type: \"mat3x3<f32>\",\n        test: (data)=>{\n            const value = data.value;\n            return value.a !== void 0;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: \"vec4<f32>\",\n        test: (data)=>data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: \"vec2<f32>\",\n        test: (data)=>data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: \"vec4<f32>\",\n        test: (data)=>data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: \"vec3<f32>\",\n        test: (data)=>data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    }\n];\n\n});\n\n\nparcelRegister(\"hQZHf\", function(module, exports) {\n\n$parcel$export(module.exports, \"uboSyncFunctionsSTD40\", function () { return $1705d6ce97c95cf0$export$c761ef20854b0b5b; });\n$parcel$export(module.exports, \"uboSyncFunctionsWGSL\", function () { return $1705d6ce97c95cf0$export$53279b3783655315; });\n\"use strict\";\nfunction $1705d6ce97c95cf0$var$loopMatrix(col, row) {\n    const total = col * row;\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst $1705d6ce97c95cf0$export$c761ef20854b0b5b = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    \"vec2<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    \"vec3<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    \"vec4<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    \"mat3x2<f32>\": $1705d6ce97c95cf0$var$loopMatrix(3, 2),\n    \"mat4x2<f32>\": $1705d6ce97c95cf0$var$loopMatrix(4, 2),\n    \"mat2x3<f32>\": $1705d6ce97c95cf0$var$loopMatrix(2, 3),\n    \"mat4x3<f32>\": $1705d6ce97c95cf0$var$loopMatrix(4, 3),\n    \"mat2x4<f32>\": $1705d6ce97c95cf0$var$loopMatrix(2, 4),\n    \"mat3x4<f32>\": $1705d6ce97c95cf0$var$loopMatrix(3, 4)\n};\nconst $1705d6ce97c95cf0$export$53279b3783655315 = {\n    ...$1705d6ce97c95cf0$export$c761ef20854b0b5b,\n    \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\n});\n\nparcelRegister(\"iQXG0\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferResource\", function () { return $4d4f3a3b4dbb7e2a$export$a79ef781de624449; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\"use strict\";\nclass $4d4f3a3b4dbb7e2a$export$a79ef781de624449 extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */ constructor({ buffer: buffer, offset: offset, size: size }){\n        super();\n        /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */ /** a unique id for this uniform group used through the renderer */ this.uid = (0, $fTJzX.uid)(\"buffer\");\n        /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */ this._resourceType = \"bufferResource\";\n        /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */ this._touched = 0;\n        /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */ this._resourceId = (0, $fTJzX.uid)(\"resource\");\n        /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */ this._bufferResource = true;\n        /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */ this.destroyed = false;\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n        this.buffer.on(\"change\", this.onBufferChange, this);\n    }\n    onBufferChange() {\n        this._resourceId = (0, $fTJzX.uid)(\"resource\");\n        this.emit(\"change\", this);\n    }\n    /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */ destroy(destroyBuffer = false) {\n        this.destroyed = true;\n        if (destroyBuffer) this.buffer.destroy();\n        this.emit(\"change\", this);\n        this.buffer = null;\n    }\n}\n\n});\n\nparcelRegister(\"6cHgC\", function(module, exports) {\n\n$parcel$export(module.exports, \"ensureAttributes\", function () { return $2d0a6ed5ddeec85d$export$abe4b4eea56679f6; });\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $6Obke = parcelRequire(\"6Obke\");\n\"use strict\";\nfunction $2d0a6ed5ddeec85d$export$abe4b4eea56679f6(geometry, extractedData) {\n    for(const i in geometry.attributes){\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n        if (attributeData) {\n            attribute.format ?? (attribute.format = attributeData.format);\n            attribute.offset ?? (attribute.offset = attributeData.offset);\n            attribute.instance ?? (attribute.instance = attributeData.instance);\n        } else (0, $c9aw6.warn)(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n    $2d0a6ed5ddeec85d$var$ensureStartAndStride(geometry);\n}\nfunction $2d0a6ed5ddeec85d$var$ensureStartAndStride(geometry) {\n    const { buffers: buffers, attributes: attributes } = geometry;\n    const tempStride = {};\n    const tempStart = {};\n    for(const j in buffers){\n        const buffer = buffers[j];\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n    for(const j in attributes){\n        const attribute = attributes[j];\n        tempStride[attribute.buffer.uid] += (0, $6Obke.getAttributeInfoFromFormat)(attribute.format).stride;\n    }\n    for(const j in attributes){\n        const attribute = attributes[j];\n        attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n        attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n        tempStart[attribute.buffer.uid] += (0, $6Obke.getAttributeInfoFromFormat)(attribute.format).stride;\n    }\n}\n\n});\n\nparcelRegister(\"jqkvN\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuStencilModesToPixi\", function () { return $407244cf3627baae$export$861c1bf8bb2cddc7; });\n\nvar $6MbTD = parcelRequire(\"6MbTD\");\n\"use strict\";\nconst $407244cf3627baae$export$861c1bf8bb2cddc7 = [];\n$407244cf3627baae$export$861c1bf8bb2cddc7[(0, $6MbTD.STENCIL_MODES).NONE] = void 0;\n$407244cf3627baae$export$861c1bf8bb2cddc7[(0, $6MbTD.STENCIL_MODES).DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0\n};\n$407244cf3627baae$export$861c1bf8bb2cddc7[(0, $6MbTD.STENCIL_MODES).RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: \"equal\",\n        passOp: \"increment-clamp\"\n    },\n    stencilBack: {\n        compare: \"equal\",\n        passOp: \"increment-clamp\"\n    }\n};\n$407244cf3627baae$export$861c1bf8bb2cddc7[(0, $6MbTD.STENCIL_MODES).RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: \"equal\",\n        passOp: \"decrement-clamp\"\n    },\n    stencilBack: {\n        compare: \"equal\",\n        passOp: \"decrement-clamp\"\n    }\n};\n$407244cf3627baae$export$861c1bf8bb2cddc7[(0, $6MbTD.STENCIL_MODES).MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: \"equal\",\n        passOp: \"keep\"\n    },\n    stencilBack: {\n        compare: \"equal\",\n        passOp: \"keep\"\n    }\n};\n$407244cf3627baae$export$861c1bf8bb2cddc7[(0, $6MbTD.STENCIL_MODES).INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: \"not-equal\",\n        passOp: \"replace\"\n    },\n    stencilBack: {\n        compare: \"not-equal\",\n        passOp: \"replace\"\n    }\n};\n\n});\n\nparcelRegister(\"iaU5j\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderTargetSystem\", function () { return $04dbce74b0e484cc$export$c555e722a4d2378a; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\nvar $7gR5c = parcelRequire(\"7gR5c\");\n\nvar $6EhkY = parcelRequire(\"6EhkY\");\n\nvar $4EOMD = parcelRequire(\"4EOMD\");\n\nvar $9HCqA = parcelRequire(\"9HCqA\");\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $i26u7 = parcelRequire(\"i26u7\");\n\nvar $L6CRg = parcelRequire(\"L6CRg\");\n\nvar $5R6vn = parcelRequire(\"5R6vn\");\n\"use strict\";\nclass $04dbce74b0e484cc$export$c555e722a4d2378a {\n    constructor(renderer){\n        /** This is the root viewport for the render pass*/ this.rootViewPort = new (0, $ec4lc.Rectangle)();\n        /** the current viewport that the gpu is using */ this.viewport = new (0, $ec4lc.Rectangle)();\n        /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */ this.onRenderTargetChange = new (0, $4EOMD.SystemRunner)(\"onRenderTargetChange\");\n        /** the projection matrix that is used by the shaders based on the active render target and the viewport */ this.projectionMatrix = new (0, $0kbcf.Matrix)();\n        /** the default clear color for render targets */ this.defaultClearColor = [\n            0,\n            0,\n            0,\n            0\n        ];\n        /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */ this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n        /** A hash that stores a gpu render target for a given render target. */ this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n        /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */ this._renderTargetStack = [];\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n    }\n    /** called when dev wants to finish a render pass */ finishRenderPass() {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n    /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */ renderStart({ target: target, clear: clear, clearColor: clearColor, frame: frame }) {\n        this._renderTargetStack.length = 0;\n        this.push(target, clear, clearColor, frame);\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = (0, $L6CRg.isRenderingToScreen)(this.rootRenderTarget);\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n    postrender() {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n    /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */ bind(renderSurface, clear = true, clearColor, frame) {\n        const renderTarget = this.getRenderTarget(renderSurface);\n        const didChange = this.renderTarget !== renderTarget;\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n        if (!frame && renderSurface instanceof (0, $4YnyE.Texture)) frame = renderSurface.frame;\n        if (frame) {\n            const resolution = source._resolution;\n            viewport.x = frame.x * resolution + 0.5 | 0;\n            viewport.y = frame.y * resolution + 0.5 | 0;\n            viewport.width = frame.width * resolution + 0.5 | 0;\n            viewport.height = frame.height * resolution + 0.5 | 0;\n        } else {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n        (0, $6EhkY.calculateProjection)(this.projectionMatrix, 0, 0, viewport.width / source.resolution, viewport.height / source.resolution, !renderTarget.isRoot);\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n        if (didChange) this.onRenderTargetChange.emit(renderTarget);\n        return renderTarget;\n    }\n    clear(target, clear = (0, $7gR5c.CLEAR).ALL, clearColor) {\n        if (!clear) return;\n        if (target) target = this.getRenderTarget(target);\n        this.adaptor.clear(target || this.renderTarget, clear, clearColor, this.viewport);\n    }\n    contextChange() {\n        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    }\n    /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */ push(renderSurface, clear = (0, $7gR5c.CLEAR).ALL, clearColor, frame) {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n        this._renderTargetStack.push({\n            renderTarget: renderTarget,\n            frame: frame\n        });\n        return renderTarget;\n    }\n    /** Pops the current render target from the renderer and restores the previous render target. */ pop() {\n        this._renderTargetStack.pop();\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n    /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */ getRenderTarget(renderSurface) {\n        if (renderSurface.isTexture) renderSurface = renderSurface.source;\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n    }\n    /**\n   * Copies a render surface to another texture\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */ copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n        if (originSrc.x < 0) {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n        if (originSrc.y < 0) {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n        const { pixelWidth: pixelWidth, pixelHeight: pixelHeight } = sourceRenderSurfaceTexture;\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n        return this.adaptor.copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest);\n    }\n    /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */ ensureDepthStencil() {\n        if (!this.renderTarget.stencil) {\n            this.renderTarget.stencil = true;\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n    /** nukes the render target system */ destroy() {\n        this._renderer = null;\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key)=>{\n            if (renderTarget !== key) renderTarget.destroy();\n        });\n        this._renderSurfaceToRenderTargetHash.clear();\n        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    }\n    _initRenderTarget(renderSurface) {\n        let renderTarget = null;\n        if ((0, $9HCqA.CanvasSource).test(renderSurface)) renderSurface = (0, $i26u7.getCanvasTexture)(renderSurface).source;\n        if (renderSurface instanceof (0, $5R6vn.RenderTarget)) renderTarget = renderSurface;\n        else if (renderSurface instanceof (0, $3dWsL.TextureSource)) {\n            renderTarget = new (0, $5R6vn.RenderTarget)({\n                colorTextures: [\n                    renderSurface\n                ]\n            });\n            if ((0, $9HCqA.CanvasSource).test(renderSurface.source.resource)) renderTarget.isRoot = true;\n            renderSurface.once(\"destroy\", ()=>{\n                renderTarget.destroy();\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n                if (gpuRenderTarget) {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n        return renderTarget;\n    }\n    getGpuRenderTarget(renderTarget) {\n        return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n    resetState() {\n        this.renderTarget = null;\n        this.renderSurface = null;\n    }\n}\n\n});\nparcelRegister(\"6EhkY\", function(module, exports) {\n\n$parcel$export(module.exports, \"calculateProjection\", function () { return $34a8cd72a4c09faa$export$fa0a4f720dae18a1; });\n\"use strict\";\nfunction $34a8cd72a4c09faa$export$fa0a4f720dae18a1(pm, x, y, width, height, flipY) {\n    const sign = flipY ? 1 : -1;\n    pm.identity();\n    pm.a = 1 / width * 2;\n    pm.d = sign * (1 / height * 2);\n    pm.tx = -1 - x * pm.a;\n    pm.ty = -sign - y * pm.d;\n    return pm;\n}\n\n});\n\nparcelRegister(\"L6CRg\", function(module, exports) {\n\n$parcel$export(module.exports, \"isRenderingToScreen\", function () { return $be2e3065b62dc233$export$6eeeb7b7562073b1; });\n\"use strict\";\nfunction $be2e3065b62dc233$export$6eeeb7b7562073b1(renderTarget) {\n    const resource = renderTarget.colorTexture.source.resource;\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\n});\n\n\n\n//# sourceMappingURL=WebGPURenderer.421fc519.js.map\n","\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n         \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n//# sourceMappingURL=textureBit.mjs.map\n","export const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n         \n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe.mjs';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe.mjs';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem.mjs';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe.mjs';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks.mjs';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe.mjs';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe.mjs';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe.mjs';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe.mjs';\nimport { BackgroundSystem } from '../background/BackgroundSystem.mjs';\nimport { BlendModePipe } from '../blendModes/BlendModePipe.mjs';\nimport { ExtractSystem } from '../extract/ExtractSystem.mjs';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem.mjs';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem.mjs';\nimport { SchedulerSystem } from '../SchedulerSystem.mjs';\nimport { HelloSystem } from '../startup/HelloSystem.mjs';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem.mjs';\nimport { TextureGCSystem } from '../texture/TextureGCSystem.mjs';\nimport { ViewSystem } from '../view/ViewSystem.mjs';\n\n\"use strict\";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem,\n  RendererInitHook,\n  RenderableGCSystem,\n  SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\nexport { SharedRenderPipes, SharedSystems };\n//# sourceMappingURL=SharedSystems.mjs.map\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @memberof rendering\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  updateRenderable() {\n  }\n  destroyRenderable() {\n  }\n  validateRenderable() {\n    return false;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"customRender\"\n};\n\nexport { CustomRenderPipe };\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @memberof rendering\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../sprite/BatchableSprite.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    if (renderGroup.isCachedAsTexture) {\n      this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n    } else {\n      this._addRenderableDirect(renderGroup, instructionSet);\n    }\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    if (renderGroup.isCachedAsTexture) {\n      this._executeCacheAsTexture(renderGroup);\n    } else {\n      this._executeDirect(renderGroup);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _addRenderableDirect(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    if (renderGroup._batchableRenderGroup) {\n      BigPool.return(renderGroup._batchableRenderGroup);\n      renderGroup._batchableRenderGroup = null;\n    }\n    instructionSet.add(renderGroup);\n  }\n  _addRenderableCacheAsTexture(renderGroup, instructionSet) {\n    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));\n    batchableRenderGroup.renderable = renderGroup.root;\n    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n    batchableRenderGroup.texture = renderGroup.texture;\n    batchableRenderGroup.bounds = renderGroup._textureBounds;\n    instructionSet.add(renderGroup);\n    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n  }\n  _executeCacheAsTexture(renderGroup) {\n    if (renderGroup.textureNeedsUpdate) {\n      renderGroup.textureNeedsUpdate = false;\n      const worldTransformMatrix = tempMatrix.identity().translate(\n        -renderGroup._textureBounds.x,\n        -renderGroup._textureBounds.y\n      );\n      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n      this._renderer.globalUniforms.push({\n        worldTransformMatrix,\n        worldColor: 4294967295\n      });\n      executeInstructions(renderGroup, this._renderer.renderPipes);\n      this._renderer.renderTarget.finishRenderPass();\n      this._renderer.renderTarget.pop();\n      this._renderer.globalUniforms.pop();\n    }\n    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n  }\n  _executeDirect(renderGroup) {\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupPipe };\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = tempMatrix\n                .identity()\n                .translate(\n                    -renderGroup._textureBounds.x,\n                    -renderGroup._textureBounds.y\n                );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n","\"use strict\";\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\nexport { executeInstructions };\n//# sourceMappingURL=executeInstructions.mjs.map\n","import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from './bounds/Bounds.mjs';\nimport { clearList } from './utils/clearList.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms.mjs';\nimport { validateRenderables } from './utils/validateRenderables.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    let originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    this._updateCachedRenderGroups(container.renderGroup, null);\n    this._updateRenderGroups(container.renderGroup);\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n    if (renderGroup.isCachedAsTexture) {\n      if (!renderGroup.updateCacheTexture)\n        return;\n      closestCacheAsTexture = renderGroup;\n    }\n    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {\n      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n    }\n    renderGroup.invalidateMatrices();\n    if (renderGroup.isCachedAsTexture) {\n      if (renderGroup.textureNeedsUpdate) {\n        const bounds = renderGroup.root.getLocalBounds();\n        bounds.ceil();\n        const lastTexture = renderGroup.texture;\n        if (renderGroup.texture) {\n          TexturePool.returnTexture(renderGroup.texture);\n        }\n        const renderer = this._renderer;\n        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n        renderGroup.texture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          resolution,\n          antialias\n        );\n        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());\n        renderGroup._textureBounds.copyFrom(bounds);\n        if (lastTexture !== renderGroup.texture) {\n          if (renderGroup.renderGroupParent) {\n            renderGroup.renderGroupParent.structureDidChange = true;\n          }\n        }\n      }\n    } else if (renderGroup.texture) {\n      TexturePool.returnTexture(renderGroup.texture);\n      renderGroup.texture = null;\n    }\n  }\n  _updateRenderGroups(renderGroup) {\n    const renderer = this._renderer;\n    const renderPipes = renderer.renderPipes;\n    renderGroup.runOnRender(renderer);\n    renderGroup.instructionSet.renderPipes = renderPipes;\n    if (!renderGroup.structureDidChange) {\n      validateRenderables(renderGroup, renderPipes);\n    } else {\n      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n    }\n    updateRenderGroupTransforms(renderGroup);\n    if (renderGroup.structureDidChange) {\n      renderGroup.structureDidChange = false;\n      this._buildInstructions(renderGroup, renderer);\n    } else {\n      this._updateRenderables(renderGroup);\n    }\n    renderGroup.childrenRenderablesToUpdate.index = 0;\n    renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)\n      return;\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n  }\n  _updateRenderables(renderGroup) {\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n    for (let i = 0; i < index; i++) {\n      const container = list[i];\n      if (container.didViewUpdate) {\n        renderGroup.updateRenderable(container);\n      }\n    }\n    clearList(list, index);\n  }\n  _buildInstructions(renderGroup, rendererOrPipes) {\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n    instructionSet.reset();\n    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n    const renderPipes = renderer.renderPipes;\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n    if (root.sortableChildren) {\n      root.sortChildren();\n    }\n    root.collectRenderablesWithEffects(instructionSet, renderer, null);\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupSystem };\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        let originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            // early out as nothing further needs to be updated!\n            if (!renderGroup.updateCacheTexture) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        // now check the cacheAsTexture stuff...\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n\n                renderGroup.texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n","\"use strict\";\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\nexport { clearList };\n//# sourceMappingURL=clearList.mjs.map\n","/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n","import { Container, UPDATE_VISIBLE, UPDATE_COLOR, UPDATE_BLEND } from '../Container.mjs';\nimport { clearList } from './clearList.mjs';\nimport { multiplyColors } from './multiplyColors.mjs';\n\n\"use strict\";\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = multiplyColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags |= container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    const renderable = container;\n    if (renderable.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(renderable);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & UPDATE_COLOR) {\n    container.groupColor = multiplyColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren };\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n","import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n","\"use strict\";\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list, index } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\nexport { validateRenderables };\n//# sourceMappingURL=validateRenderables.mjs.map\n","import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from './BatchableSprite.mjs';\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._destroyRenderableBound = this.destroyRenderable.bind(this);\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_gpuSpriteHash\");\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    BigPool.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n    sprite.off(\"destroyed\", this._destroyRenderableBound);\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = BigPool.get(BatchableSprite);\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableSprite;\n    sprite.on(\"destroyed\", this._destroyRenderableBound);\n    return batchableSprite;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      BigPool.return(this._gpuSpriteHash[i]);\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexport { SpritePipe };\n//# sourceMappingURL=SpritePipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { Sprite } from './Sprite';\n\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuSpriteHash: Record<number, BatchableSprite> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuSpriteHash');\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    public destroyRenderable(sprite: Sprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n\n        sprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = BigPool.get(BatchableSprite);\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableSprite;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', this._destroyRenderableBound);\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            BigPool.return(this._gpuSpriteHash[i] as PoolItem);\n        }\n\n        this._gpuSpriteHash = null;\n        this._renderer = null;\n    }\n}\n","import { ExtensionType, extensions } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { DefaultBatcher } from './DefaultBatcher.mjs';\n\n\"use strict\";\nconst _BatcherPipe = class _BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n    /** A record of all active batchers, keyed by their names */\n    this._activeBatches = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init?.(this);\n  }\n  static getBatcher(name) {\n    return new this._availableBatchers[name]();\n  }\n  buildStart(instructionSet) {\n    let batchers = this._batchersByInstructionSet[instructionSet.uid];\n    if (!batchers) {\n      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n      batchers.default || (batchers.default = new DefaultBatcher());\n    }\n    this._activeBatches = batchers;\n    this._activeBatch = this._activeBatches.default;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].begin();\n    }\n  }\n  addToBatch(batchableObject, instructionSet) {\n    if (this._activeBatch.name !== batchableObject.batcherName) {\n      this._activeBatch.break(instructionSet);\n      let batch = this._activeBatches[batchableObject.batcherName];\n      if (!batch) {\n        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n        batch.begin();\n      }\n      this._activeBatch = batch;\n    }\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    this._activeBatch.break(instructionSet);\n    const batches = this._activeBatches;\n    for (const i in batches) {\n      const batch = batches[i];\n      const geometry = batch.geometry;\n      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n    }\n  }\n  upload(instructionSet) {\n    const batchers = this._batchersByInstructionSet[instructionSet.uid];\n    for (const i in batchers) {\n      const batcher = batchers[i];\n      const geometry = batcher.geometry;\n      if (batcher.dirty) {\n        batcher.dirty = false;\n        geometry.buffers[0].update(batcher.attributeSize * 4);\n      }\n    }\n  }\n  execute(batch) {\n    if (batch.action === \"startBatch\") {\n      const batcher = batch.batcher;\n      const geometry = batcher.geometry;\n      const shader = batcher.shader;\n      this._adaptor.start(this, geometry, shader);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor = null;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].destroy();\n    }\n    this._activeBatches = null;\n  }\n};\n/** @ignore */\n_BatcherPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"batch\"\n};\n_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet BatcherPipe = _BatcherPipe;\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\nextensions.add(DefaultBatcher);\n\nexport { BatcherPipe };\n//# sourceMappingURL=BatcherPipe.mjs.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @memberof rendering\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher();\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../renderers/types.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY),\n      inverse: false,\n      resolution: \"inherit\",\n      antialias: \"inherit\"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      maskContainer.collectRenderables(\n        instructionSet,\n        renderer,\n        null\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === RendererType.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"alphaMask\"\n};\n\nexport { AlphaMaskPipe };\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            maskContainer.collectRenderables(\n                instructionSet,\n                renderer,\n                null\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" },\n      uInverse: { value: options.inverse ? 1 : 0, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexport { MaskFilter };\n//# sourceMappingURL=MaskFilter.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/**\n * The default filter settings\n * @static\n */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * Filters provide additional shading and post-processing effects to any display object and its children\n * they are attached to.\n *\n * You attached filters to a display object using its `filters` array property.\n *\n * ```js\n * import { Sprite, BlurFilter, HardMixBlend } from 'pixi.js';\n *\n * const sprite = Sprite.from('myTexture.png');\n *\n * // single filter\n * sprite.filters = new BlurFilter({ strength: 8 });\n *\n * // or multiple filters\n * sprite.filters = [new BlurFilter({ strength: 8 }), new HardMixBlend()];\n * ```\n *\n * Pixi has a number of built-in filters which can be used in your game or application:\n *\n * - {@link filters.AlphaFilter} - Applies alpha to the display object and any of its children.\n * - {@link filters.BlurFilter} - Applies a Gaussian blur to the display object.\n * - {@link filters.BlurFilterPass} - Applies a blur pass to an object.\n * - {@link filters.ColorBurnBlend} - Blend mode to add color burn to display objects.\n * - {@link filters.ColorDodgeBlend} - Blend mode to add color dodge to display objects.\n * - {@link filters.ColorMatrixFilter} - Transform the color channels by matrix multiplication.\n * - {@link filters.DarkenBlend} - Blend mode to darken display objects.\n * - {@link filters.DisplacementFilter} - Applies a displacement map to distort an object.\n * - {@link filters.DivideBlend} - Blend mode to divide display objects.\n * - {@link filters.HardMixBlend} - Blend mode to hard mix display objects.\n * - {@link filters.LinearBurnBlend} - Blend mode to add linear burn to display objects.\n * - {@link filters.LinearDodgeBlend} - Blend mode to add linear dodge to display objects.\n * - {@link filters.LinearLightBlend} - Blend mode to add linear light to display objects.\n * - {@link filters.NoiseFilter} - Applies random noise to an object.\n * - {@link filters.PinLightBlend} - Blend mode to add pin light to display objects.\n * - {@link filters.SubtractBlend} - Blend mode to subtract display objects.\n *\n * <br/>\n * For more available filters, check out the\n *  {@link https://pixijs.io/filters/docs/ pixi-filters} repository.\n *\n * You can also check out the awesome {@link https://pixijs.io/filters/examples/ Filter demo} to see\n * filters in action and combine them!\n * @namespace filters\n */\n\n/**\n * The options to use when creating a new filter.\n * @memberof filters\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (default 1)\n     * If 'inherit', the resolution of the render target is used.\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number | 'inherit';\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n     * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n     * but you won't see the difference. (default 'off')\n     *\n     * This can be a boolean or [FilterAntialias]{@link filters.FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot of the area being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     */\n    blendRequired?: boolean;\n    /**\n     * If this is set to true, the filter system will clip filter texture into viewport\n     * This is useful for filters that applied to whole texture.\n     * (default true)\n     */\n    clipToViewport?: boolean;\n}\n\n/** Filter options mixed with shader resources. A filter needs a shader and some resources to work. */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @memberof filters\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @class\n * @memberof filters\n */\nexport class Filter extends Shader\n{\n    /**\n     * The default filter settings\n     * @static\n     */\n    public static readonly defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n        clipToViewport: true,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number | 'inherit';\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * Clip texture into viewport or not\n     * @default true\n     */\n    public clipToViewport: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n\n        this.addResource('uTexture', 0, 1);\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n","var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"colorMask\"\n};\n\nexport { ColorMaskPipe };\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        this._colorStack = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    maskContainer.collectRenderables(\n      instructionSet,\n      renderer,\n      null\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexport { StencilMaskPipe };\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        maskContainer.collectRenderables(\n            instructionSet,\n            renderer,\n            null\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   * @ignore\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"background\",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\nexport { BackgroundSystem };\n//# sourceMappingURL=BackgroundSystem.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n\n/**\n * Options for the background system.\n * @property {ColorSource} [backgroundColor='black']\n * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n * @property {ColorSource} [background] - Alias for backgroundColor\n * @property {number} [backgroundAlpha=1] -\n * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n * @property {boolean} [clearBeforeRender=true] - Whether to clear the canvas before new render passes.\n * @memberof rendering\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @memberof rendering.SharedRendererOptions\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /**\n     * Alias for backgroundColor\n     * @memberof rendering.SharedRendererOptions\n     */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @memberof rendering.SharedRendererOptions\n     * @default 1\n     */\n    backgroundAlpha: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @memberof rendering.SharedRendererOptions\n     * @default true\n     */\n    clearBeforeRender: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @memberof rendering\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     * @ignore\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../../filters/FilterEffect.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nextensions.handle(ExtensionType.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  /**\n   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n   * @param renderable - The renderable we are adding to the instruction set\n   * @param blendMode - The blend mode of the renderable\n   * @param instructionSet - The instruction set we are adding to\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced)\n        this._renderableList.push(renderable);\n      return;\n    }\n    this._activeBlendMode = blendMode;\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced) {\n      this._beginAdvancedBlendMode(instructionSet);\n      this._renderableList.push(renderable);\n    }\n  }\n  _beginAdvancedBlendMode(instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      renderables: [],\n      filterEffect,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   * @ignore\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   * @ignore\n   */\n  buildEnd(instructionSet) {\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"blendMode\"\n};\n\nexport { BlendModePipe };\n//# sourceMappingURL=BlendModePipe.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link renderers.InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @memberof rendering\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n     * @param renderable - The renderable we are adding to the instruction set\n     * @param blendMode - The blend mode of the renderable\n     * @param instructionSet - The instruction set we are adding to\n     */\n    public setBlendMode(renderable: Renderable, blendMode: BLEND_MODES, instructionSet: InstructionSet)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced) this._renderableList.push(renderable);\n\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced)\n        {\n            this._beginAdvancedBlendMode(instructionSet);\n\n            this._renderableList.push(renderable);\n        }\n    }\n\n    private _beginAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n            + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        let filterEffect = this._filterHash[blendMode];\n\n        // this does need an execute?\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            renderables: [],\n            filterEffect,\n            canBundle: false,\n        };\n\n        this._renderableList = instruction.renderables;\n        instructionSet.add(instruction);\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     * @ignore\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     * @ignore\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst imageTypes = {\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  webp: \"image/webp\"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container || options instanceof Texture) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Will return a HTML Image of the target\n   * @param options - The options for creating the image, or the target to extract\n   * @returns - HTML Image of the target\n   */\n  async image(options) {\n    const image = new Image();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Will return a base64 encoded string of this target. It works by calling\n   * `Extract.canvas` and then running toDataURL on that.\n   * @param options - The options for creating the image, or the target to extract\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns - A Canvas element with the texture rendered on.\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy(true);\n    return canvas;\n  }\n  /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns - One-dimensional array containing the pixel data of the entire texture\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container) {\n      texture.destroy(true);\n    }\n    return pixelInfo;\n  }\n  /**\n   * Will return a texture of the target\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns - A texture of the target\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Will extract a HTMLImage of the target and download it\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement(\"a\");\n    link.download = options.filename ?? \"image.png\";\n    link.href = canvas.toDataURL(\"image/png\");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * @param options - The options for logging the image, or the target to log\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      \"font-size: 1px;\",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      \"background-size: contain;\"\n    ].join(\" \");\n    console.log(\"%c \", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"extract\"\n};\n/** Default options for creating an image. */\n_ExtractSystem.defaultImageOptions = {\n  /** The format of the image. */\n  format: \"png\",\n  /** The quality of the image. */\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\nexport { ExtractSystem };\n//# sourceMappingURL=ExtractSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * @memberof rendering\n */\nexport interface ImageOptions\n{\n    /** The format of the image. */\n    format?: Formats;\n    /** The quality of the image. */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport interface BaseExtractOptions\n{\n    /** The target to extract. */\n    target: Container | Texture;\n    /** The region of the target to extract. */\n    frame?: Rectangle;\n    /** The resolution of the extracted content. */\n    resolution?: number;\n    /** The color used to clear the extracted content. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * @memberof rendering\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * @memberof rendering\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /** The filename to use when downloading the content. */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.extract` property.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (extract will be auto-added to renderer)\n * const app = new Application();\n * await app.init();\n *\n * // Draw a red circle\n * const graphics = new Graphics()\n *     .circle(0, 0, 50);\n *     .fill(0xFF0000)\n *\n * // Render the graphics as an HTMLImageElement\n * const image = await app.renderer.extract.image(graphics);\n * document.body.appendChild(image);\n * @memberof rendering\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /** Default options for creating an image. */\n    public static defaultImageOptions: ImageOptions = {\n        /** The format of the image. */\n        format: 'png' as Formats,\n        /** The quality of the image. */\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param options - The options for creating the image, or the target to extract\n     * @returns - HTML Image of the target\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<HTMLImageElement>\n    {\n        const image = new Image();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     * `Extract.canvas` and then running toDataURL on that.\n     * @param options - The options for creating the image, or the target to extract\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns - A Canvas element with the texture rendered on.\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns - One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Will return a texture of the target\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns - A texture of the target\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Will extract a HTMLImage of the target and download it\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * @param options - The options for logging the image, or the target to log\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { RenderTexture } from '../texture/RenderTexture.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * A Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your container is complicated and needs to be reused multiple times.\n   * @param {GenerateTextureOptions | Container} options - Generate texture options.\n   * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n   * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n   * @param {number} [options.resolution] - The resolution of the texture being generated.\n   *        if no region is specified, defaults to the local bounds of the container.\n   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n   * @returns a shiny new texture of the container passed in\n   */\n  generateTexture(options) {\n    if (options instanceof Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGenerator\"\n};\n\nexport { GenerateTextureSystem };\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n","import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * @memberof rendering\n */\nexport type GenerateTextureOptions =\n{\n    /** The container to generate the texture from */\n    target: Container;\n    /**\n     * The region of the container, that shall be rendered,\n     * if no region is specified, defaults to the local bounds of the container.\n     */\n    frame?: Rectangle;\n    /** The resolution of the texture being generated. */\n    resolution?: number;\n    /** The color used to clear the texture. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** The options passed to the texture source. */\n    textureSourceOptions?: GenerateTextureSourceOptions,\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from the renderer\n *\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.textureGenerator` property.\n * @memberof rendering\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * A Useful function that returns a texture of the display object that can then be used to create sprites\n     * This can be quite useful if your container is complicated and needs to be reused multiple times.\n     * @param {GenerateTextureOptions | Container} options - Generate texture options.\n     * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n     * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n     * @param {number} [options.resolution] - The resolution of the texture being generated.\n     *        if no region is specified, defaults to the local bounds of the container.\n     * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n     * @returns a shiny new texture of the container passed in\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nclass RenderTexture extends Texture {\n  static create(options) {\n    return new RenderTexture({\n      source: new TextureSource(options)\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\nexport { RenderTexture };\n//# sourceMappingURL=RenderTexture.mjs.map\n","import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link rendering.Texture}\n * @memberof rendering\n */\nexport class RenderTexture extends Texture\n{\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        return new RenderTexture({\n            source: new TextureSource(options)\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../../maths/point/Point.mjs';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix(),\n      worldColor: 4294967295,\n      offset: new Point()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    color32BitToUniform(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === RendererType.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get globalUniformData() {\n    return this._currentGlobalUniformData;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup({\n      uProjectionMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uWorldTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"globalUniforms\"\n};\n\nexport { GlobalUniformSystem };\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @memberof rendering\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../ticker/Ticker.mjs';\n\n\"use strict\";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    this._offset = 0;\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration, useOffset = true) {\n    const id = uid++;\n    let offset = 0;\n    if (useOffset) {\n      this._offset += 1e3;\n      offset = this._offset;\n    }\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      offset,\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.offset - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    Ticker.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"scheduler\",\n  priority: 0\n};\n\nexport { SchedulerSystem };\n//# sourceMappingURL=SchedulerSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @memberof rendering\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     * @ignore\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { sayHello } from '../../../../utils/sayHello.mjs';\nimport { RendererType } from '../../types.mjs';\n\n\"use strict\";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === RendererType.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"hello\",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\nexport { HelloSystem };\n//# sourceMappingURL=HelloSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @memberof rendering\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @memberof rendering.SharedRendererOptions\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @memberof rendering\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n","import { DOMAdapter } from '../environment/adapter.mjs';\nimport { VERSION } from './const.mjs';\n\n\"use strict\";\nlet saidHello = false;\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      \"background: #E72264; padding:5px 0;\",\n      \"background: #6CA2EA; padding:5px 0;\",\n      \"background: #B5D33D; padding:5px 0;\",\n      \"background: #FED23F; padding:5px 0;\",\n      \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n      \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\nexport { sayHello };\n//# sourceMappingURL=sayHello.mjs.map\n","import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { cleanHash, cleanArray } from '../../../../utils/data/clean.mjs';\n\n\"use strict\";\nlet renderableGCTick = 0;\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /**\n   * Creates a new RenderableGCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of renderables being tracked for garbage collection */\n    this._managedRenderables = [];\n    /** Array of hash objects being tracked for cleanup */\n    this._managedHashes = [];\n    /** Array of arrays being tracked for cleanup */\n    this._managedArrays = [];\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options for the renderer\n   */\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    this._frequency = options.renderableGCFrequency;\n    this.enabled = options.renderableGCActive;\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => this.run(),\n        this._frequency,\n        false\n      );\n      this._hashHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const hash of this._managedHashes) {\n            hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n          }\n        },\n        this._frequency\n      );\n      this._arrayHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const array of this._managedArrays) {\n            cleanArray(array.context[array.hash]);\n          }\n        },\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._renderer.scheduler.cancel(this._hashHandler);\n      this._renderer.scheduler.cancel(this._arrayHandler);\n    }\n  }\n  /**\n   * Adds a hash table to be managed by the garbage collector.\n   * @param context - The object containing the hash table\n   * @param hash - The property name of the hash table\n   */\n  addManagedHash(context, hash) {\n    this._managedHashes.push({ context, hash });\n  }\n  /**\n   * Adds an array to be managed by the garbage collector.\n   * @param context - The object containing the array\n   * @param hash - The property name of the array\n   */\n  addManagedArray(context, hash) {\n    this._managedArrays.push({ context, hash });\n  }\n  /**\n   * Updates the GC timestamp and tracking before rendering.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({\n    container\n  }) {\n    this._now = performance.now();\n    container.renderGroup.gcTick = renderableGCTick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /**\n   * Starts tracking a renderable for garbage collection.\n   * @param renderable - The renderable to track\n   */\n  addRenderable(renderable) {\n    if (!this.enabled)\n      return;\n    if (renderable._lastUsed === -1) {\n      this._managedRenderables.push(renderable);\n      renderable.once(\"destroyed\", this._removeRenderable, this);\n    }\n    renderable._lastUsed = this._now;\n  }\n  /**\n   * Performs garbage collection by cleaning up unused renderables.\n   * Removes renderables that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = this._now;\n    const managedRenderables = this._managedRenderables;\n    const renderPipes = this._renderer.renderPipes;\n    let offset = 0;\n    for (let i = 0; i < managedRenderables.length; i++) {\n      const renderable = managedRenderables[i];\n      if (renderable === null) {\n        offset++;\n        continue;\n      }\n      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n      const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n      if ((renderGroup?.gcTick ?? 0) === currentTick) {\n        renderable._lastUsed = now;\n      }\n      if (now - renderable._lastUsed > this.maxUnusedTime) {\n        if (!renderable.destroyed) {\n          const rp = renderPipes;\n          if (renderGroup)\n            renderGroup.structureDidChange = true;\n          rp[renderable.renderPipeId].destroyRenderable(renderable);\n        }\n        renderable._lastUsed = -1;\n        offset++;\n        renderable.off(\"destroyed\", this._removeRenderable, this);\n      } else {\n        managedRenderables[i - offset] = renderable;\n      }\n    }\n    managedRenderables.length -= offset;\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._renderer = null;\n    this._managedRenderables.length = 0;\n    this._managedHashes.length = 0;\n    this._managedArrays.length = 0;\n  }\n  /**\n   * Removes a renderable from being tracked when it's destroyed.\n   * @param renderable - The renderable to stop tracking\n   */\n  _removeRenderable(renderable) {\n    const index = this._managedRenderables.indexOf(renderable);\n    if (index >= 0) {\n      renderable.off(\"destroyed\", this._removeRenderable, this);\n      this._managedRenderables[index] = null;\n    }\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n};\n/**\n * Extension metadata for registering this system with the renderer.\n * @ignore\n */\n_RenderableGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"renderableGC\",\n  priority: 0\n};\n/**\n * Default configuration options for the garbage collection system.\n * These can be overridden when initializing the renderer.\n */\n_RenderableGCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  renderableGCActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  renderableGCMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\nexport { RenderableGCSystem };\n//# sourceMappingURL=RenderableGCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { cleanArray, cleanHash } from '../../../../utils/data/clean';\nimport { type RenderOptions } from '../system/AbstractRenderer';\n\nimport type { Container } from '../../../../scene/container/Container';\nimport type { Renderer } from '../../types';\nimport type { RenderPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\nlet renderableGCTick = 0;\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @memberof rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCFrequency: number;\n}\n\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n *\n * Example:\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @implements {System<RenderableGCSystemOptions>}\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /**\n     * Extension metadata for registering this system with the renderer.\n     * @ignore\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /**\n     * Default configuration options for the garbage collection system.\n     * These can be overridden when initializing the renderer.\n     */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        renderableGCActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        renderableGCMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        renderableGCFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of renderables being tracked for garbage collection */\n    private readonly _managedRenderables: Renderable[] = [];\n    /** ID of the main GC scheduler handler */\n    private _handler: number;\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n    /** Current timestamp used for age calculations */\n    private _now: number;\n\n    /** Array of hash objects being tracked for cleanup */\n    private readonly _managedHashes: {context: any, hash: string}[] = [];\n    /** ID of the hash cleanup scheduler handler */\n    private _hashHandler: number;\n\n    /** Array of arrays being tracked for cleanup */\n    private readonly _managedArrays: {context: any, hash: string}[] = [];\n    /** ID of the array cleanup scheduler handler */\n    private _arrayHandler: number;\n\n    /**\n     * Creates a new RenderableGCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options for the renderer\n     */\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n\n        this.enabled = options.renderableGCActive;\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            // Schedule periodic garbage collection\n            this._handler = this._renderer.scheduler.repeat(\n                () => this.run(),\n                this._frequency,\n                false\n            );\n\n            // Schedule periodic hash table cleanup\n            this._hashHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedHashes)\n                    {\n                        hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n                    }\n                },\n                this._frequency\n            );\n\n            // Schedule periodic array cleanup\n            this._arrayHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const array of this._managedArrays)\n                    {\n                        cleanArray(array.context[array.hash]);\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            // Cancel all scheduled cleanups\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n\n    /**\n     * Adds a hash table to be managed by the garbage collector.\n     * @param context - The object containing the hash table\n     * @param hash - The property name of the hash table\n     */\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        this._managedHashes.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Adds an array to be managed by the garbage collector.\n     * @param context - The object containing the array\n     * @param hash - The property name of the array\n     */\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        this._managedArrays.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Updates the GC timestamp and tracking before rendering.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    public prerender({\n        container\n    }: RenderOptions): void\n    {\n        this._now = performance.now();\n\n        // The gcTick is a monotonically increasing counter that tracks render cycles\n        // Each time we render, we increment the global renderableGCTick counter\n        // and assign the new tick value to the render group being rendered.\n        // This lets us know which render groups were rendered in the current frame\n        // versus ones that haven't been rendered recently.\n        // The instruction set also gets updated with this tick value to track\n        // when its renderables were last used.\n        container.renderGroup.gcTick = renderableGCTick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /**\n     * Starts tracking a renderable for garbage collection.\n     * @param renderable - The renderable to track\n     */\n    public addRenderable(renderable: Renderable): void\n    {\n        if (!this.enabled) return;\n\n        if (renderable._lastUsed === -1)\n        {\n            this._managedRenderables.push(renderable);\n            renderable.once('destroyed', this._removeRenderable, this);\n        }\n\n        renderable._lastUsed = this._now;\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused renderables.\n     * Removes renderables that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = this._now;\n        const managedRenderables = this._managedRenderables;\n        const renderPipes = this._renderer.renderPipes;\n        let offset = 0;\n\n        for (let i = 0; i < managedRenderables.length; i++)\n        {\n            const renderable = managedRenderables[i];\n\n            if (renderable === null)\n            {\n                offset++;\n                continue;\n            }\n\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n            // Update last used time if the renderable's group was rendered this tick\n            if ((renderGroup?.gcTick ?? 0) === currentTick)\n            {\n                renderable._lastUsed = now;\n            }\n\n            // Clean up if unused for too long\n            if (now - renderable._lastUsed > this.maxUnusedTime)\n            {\n                if (!renderable.destroyed)\n                {\n                    const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n                    if (renderGroup)renderGroup.structureDidChange = true;\n\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n\n                renderable._lastUsed = -1;\n                offset++;\n                renderable.off('destroyed', this._removeRenderable, this);\n            }\n            else\n            {\n                managedRenderables[i - (offset)] = renderable;\n            }\n        }\n\n        managedRenderables.length -= offset;\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n        this._renderer = null as any as Renderer;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n\n    /**\n     * Removes a renderable from being tracked when it's destroyed.\n     * @param renderable - The renderable to stop tracking\n     */\n    private _removeRenderable(renderable: Container): void\n    {\n        const index = this._managedRenderables.indexOf(renderable as Renderable);\n\n        if (index >= 0)\n        {\n            renderable.off('destroyed', this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n}\n","\"use strict\";\nfunction cleanHash(hash) {\n  let clean = false;\n  for (const i in hash) {\n    if (hash[i] == void 0) {\n      clean = true;\n      break;\n    }\n  }\n  if (!clean)\n    return hash;\n  const cleanHash2 = /* @__PURE__ */ Object.create(null);\n  for (const i in hash) {\n    const value = hash[i];\n    if (value) {\n      cleanHash2[i] = value;\n    }\n  }\n  return cleanHash2;\n}\nfunction cleanArray(arr) {\n  let offset = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] == void 0) {\n      offset++;\n    } else {\n      arr[i - offset] = arr[i];\n    }\n  }\n  arr.length -= offset;\n  return arr;\n}\n\nexport { cleanArray, cleanHash };\n//# sourceMappingURL=clean.mjs.map\n","/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @memberof utils\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @memberof utils\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n  }\n  init(options) {\n    options = { ..._TextureGCSystem.defaultOptions, ...options };\n    this.checkCountMax = options.textureGCCheckCountMax;\n    this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n    this.active = options.textureGCActive;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    if (!this._renderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (!this.active)\n      return;\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const managedTextures = this._renderer.texture.managedTextures;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {\n        texture._touched = -1;\n        texture.unload();\n      }\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGC\"\n};\n/** default options for the TextureGCSystem */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystem.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\nexport { TextureGCSystem };\n//# sourceMappingURL=TextureGCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @memberof rendering\n * @property {boolean} [textureGCActive=true] - If set to true, this will enable the garbage collector on the GPU.\n * @property {number} [textureGCAMaxIdle=60 * 60] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [textureGCCheckCountMax=600] - Frames between two garbage collections.\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystem.textureGCMaxIdle}\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @memberof rendering\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /** default options for the TextureGCSystem */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystem.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     */\n    public count: number;\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     */\n    public checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     */\n    public maxIdle: number;\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     */\n    public checkCountMax: number;\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     */\n    public active: boolean;\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        this.count = 0;\n        this.checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        options = { ...TextureGCSystem.defaultOptions, ...options };\n\n        this.checkCountMax = options.textureGCCheckCountMax;\n        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n        this.active = options.textureGCActive;\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    protected postrender(): void\n    {\n        if (!this._renderer.renderingToScreen)\n        {\n            return;\n        }\n\n        this.count++;\n\n        if (!this.active) return;\n\n        this.checkCount++;\n\n        if (this.checkCount > this.checkCountMax)\n        {\n            this.checkCount = 0;\n\n            this.run();\n        }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    public run(): void\n    {\n        const managedTextures = this._renderer.texture.managedTextures;\n\n        for (let i = 0; i < managedTextures.length; i++)\n        {\n            const texture = managedTextures[i];\n\n            // Only supports non generated textures at the moment!\n            if (\n                texture.autoGarbageCollect\n                && texture.resource\n                && texture._touched > -1\n                && this.count - texture._touched > this.maxIdle\n            )\n            {\n                texture._touched = -1;\n                texture.unload();\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { RenderTarget } from '../renderTarget/RenderTarget.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\n\n\"use strict\";\nconst _ViewSystem = class _ViewSystem {\n  /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * @member {boolean}\n   */\n  get autoDensity() {\n    return this.texture.source.autoDensity;\n  }\n  set autoDensity(value) {\n    this.texture.source.autoDensity = value;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      deprecation(v8_0_0, \"ViewSystem.view has been renamed to ViewSystem.canvas\");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle(0, 0, options.width, options.height);\n    this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = getCanvasTexture(this.canvas, options);\n    this.renderTarget = new RenderTarget({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or \"false\".\n   * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n   */\n  destroy(options = false) {\n    const removeView = typeof options === \"boolean\" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"view\",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\nexport { ViewSystem };\n//# sourceMappingURL=ViewSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @memberof rendering\n * @property {number} [width=800] - The width of the screen.\n * @property {number} [height=600] - The height of the screen.\n * @property {ICanvas} [canvas] - The canvas to use as a view, optional.\n * @property {boolean} [autoDensity=false] - Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n * @property {number} [resolution] - The resolution / device pixel ratio of the renderer.\n * @property {boolean} [antialias=false] - Whether to enable anti-aliasing. This may affect performance.\n * @property {boolean} [depth] -\n * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n * @property {boolean} [multiView] - TODO: multiView\n * @property {number} [backgroundAlpha] - The alpha of the background.\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     * @memberof rendering.SharedRendererOptions\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    height?: number;\n    /**\n     * The canvas to use as a view, optional.\n     * @memberof rendering.SharedRendererOptions\n     */\n    canvas?: ICanvas;\n    /** @deprecated */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     * @memberof rendering.SharedRendererOptions\n     */\n    autoDensity?: boolean;\n    /**\n     * The resolution / device pixel ratio of the renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    resolution?: number;\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @memberof rendering.SharedRendererOptions\n     */\n    antialias?: boolean;\n    /**\n     * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    depth?: boolean;\n\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @default 1\n     */\n    backgroundAlpha?: number;\n}\n\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions>>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * @member {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = options.backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    /** unique id for this render target */\n    this.uid = uid(\"renderTarget\");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === \"number\") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new TextureSource({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   * @ignore\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new TextureSource({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: \"depth24plus-stencil8\",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0)\n        return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\nexport { RenderTarget };\n//# sourceMappingURL=RenderTarget.mjs.map\n","// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @memberof rendering\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @memberof rendering\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     * @ignore\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n","import { CanvasSource } from '../sources/CanvasSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst canvasCache = /* @__PURE__ */ new Map();\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new Texture({\n      source: new CanvasSource({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once(\"destroy\", onDestroy);\n    texture.source.once(\"destroy\", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\nexport { getCanvasTexture, hasCachedCanvasTexture };\n//# sourceMappingURL=getCanvasTexture.mjs.map\n","import { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { BufferUsage } from '../buffer/const.mjs';\n\n\"use strict\";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n    let dataInt32 = null;\n    if (!data) {\n      data = uniformGroup.buffer.data;\n      dataInt32 = uniformGroup.buffer.dataInt32;\n    }\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId)\n      return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\nexport { UboSystem };\n//# sourceMappingURL=UboSystem.mjs.map\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @memberof rendering\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n","import { uniformParsers } from './uniformParsers.mjs';\n\n\"use strict\";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = \"${name}\";`,\n          `offset += ${offset - prev};`,\n          uniformParsers[j][parserCode] || uniformParsers[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join(\"\\n\");\n  return new Function(\n    \"uv\",\n    \"data\",\n    \"dataInt32\",\n    \"offset\",\n    fragmentSrc\n  );\n}\n\nexport { createUboSyncFunction };\n//# sourceMappingURL=createUboSyncFunction.mjs.map\n","import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n","\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexport { uniformParsers };\n//# sourceMappingURL=uniformParsers.mjs.map\n","// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\nexport interface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n","\"use strict\";\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        dataInt32[offset] = v;`,\n  \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  \"vec2<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n  \"vec3<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n  \"vec4<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  \"mat3x2<f32>\": loopMatrix(3, 2),\n  \"mat4x2<f32>\": loopMatrix(4, 2),\n  \"mat2x3<f32>\": loopMatrix(2, 3),\n  \"mat4x3<f32>\": loopMatrix(4, 3),\n  \"mat2x4<f32>\": loopMatrix(2, 4),\n  \"mat3x4<f32>\": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL };\n//# sourceMappingURL=uboSyncFunctions.mjs.map\n","import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n  }\n}\n\nexport { BufferResource };\n//# sourceMappingURL=BufferResource.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @memberof rendering\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n    }\n}\n","import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexport { ensureAttributes };\n//# sourceMappingURL=ensureAttributes.mjs.map\n","import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in an gaps. WE do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of th etime users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way, you can\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n","import { STENCIL_MODES } from '../../shared/state/const.mjs';\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"not-equal\",\n    passOp: \"replace\"\n  },\n  stencilBack: {\n    compare: \"not-equal\",\n    passOp: \"replace\"\n  }\n};\n\nexport { GpuStencilModesToPixi };\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n","import { STENCIL_MODES } from '../../shared/state/const';\n\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n};\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection.mjs';\nimport { SystemRunner } from '../system/SystemRunner.mjs';\nimport { CanvasSource } from '../texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\nimport { isRenderingToScreen } from './isRenderingToScreen.mjs';\nimport { RenderTarget } from './RenderTarget.mjs';\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n    this.adaptor.prerender?.(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = CLEAR.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource) {\n      renderTarget = new RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (CanvasSource.test(renderSurface.source.resource)) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n  resetState() {\n    this.renderTarget = null;\n    this.renderSurface = null;\n  }\n}\n\nexport { RenderTargetSystem };\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @memberof rendering\n * @see environment.ICanvas\n * @see rendering.Texture\n * @see rendering.RenderTarget\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @memberof rendering\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (CanvasSource.test(renderSurface.source.resource))\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n\n    public resetState(): void\n    {\n        this.renderTarget = null;\n        this.renderSurface = null;\n    }\n}\n","\"use strict\";\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\nexport { calculateProjection };\n//# sourceMappingURL=calculateProjection.mjs.map\n","import type { Matrix } from '../../../../maths/matrix/Matrix';\n\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n","\"use strict\";\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\nexport { isRenderingToScreen };\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n","import type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","parcelRequire","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","$a501a60afdc99415$export$db13c76603bca4d1","$a501a60afdc99415$export$dfbe934dc5760b41","name","vertex","header","main","fragment","$0fb3c38788095636$export$556f4f9086226a47","$0fb3c38788095636$export$4804359c3f750499","$g2j5H","$28aiy","$ddKkB","$5k7Pa","$d6zIN","$8CF7d","$aEM94","$2Xi2U","$kQDDm","$gHW7P","$5DBVc","$l24yk","$a81eN","$4fWAX","$edAuX","$gR8f7","$7aCaM","$hriU1","$k3485","BackgroundSystem","GlobalUniformSystem","HelloSystem","ViewSystem","RenderGroupSystem","TextureGCSystem","GenerateTextureSystem","ExtractSystem","RendererInitHook","RenderableGCSystem","SchedulerSystem","BlendModePipe","BatcherPipe","SpritePipe","RenderGroupPipe","AlphaMaskPipe","StencilMaskPipe","ColorMaskPipe","CustomRenderPipe","$e76b9ad86b228e10$export$e576ade34298fbbb","$kFA6i","constructor","renderer","_renderer","updateRenderable","destroyRenderable","validateRenderable","addRenderable","container","instructionSet","renderPipes","batch","break","add","execute","isRenderable","render","destroy","extension","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","$9bff709278747486$export$9d1db8757b18c590","$0kbcf","$dLv5L","$dXAM5","$87MHd","$9bff709278747486$var$tempMatrix","Matrix","addRenderGroup","renderGroup","isCachedAsTexture","_addRenderableCacheAsTexture","_addRenderableDirect","_executeCacheAsTexture","_executeDirect","_batchableRenderGroup","BigPool","return","batchableRenderGroup","BatchableSprite","renderable","root","transform","relativeGroupTransform","texture","bounds","_textureBounds","addToBatch","textureNeedsUpdate","worldTransformMatrix","identity","translate","x","y","renderTarget","push","frame","globalUniforms","worldColor","executeInstructions","finishRenderPass","pop","_batcher","updateElement","geometry","buffers","update","inverseParentTextureTransform","worldColorAlpha","$aae9797cc2f076d1$export$de87bf58cb76142c","instructions","i","instructionSize","instruction","renderPipeId","$a6ec671d9ad127d2$export$e48941ab3223d0e5","$2zAQe","$dtW0p","$c4BxA","$h0MOH","$gZmuI","$a6ec671d9ad127d2$var$tempMatrix","parent","renderGroupParent","originalLocalTransform","copyFrom","localTransform","_updateCachedRenderGroups","_updateRenderGroups","start","worldTransform","uniformBatch","renderEnd","closestCacheAsTexture","updateCacheTexture","_parentCacheAsTextureRenderGroup","renderGroupChildren","length","invalidateMatrices","getLocalBounds","ceil","lastTexture","TexturePool","returnTexture","resolution","textureOptions","view","antialias","getOptimalTexture","width","height","Bounds","structureDidChange","runOnRender","clearList","childrenRenderablesToUpdate","list","validateRenderables","updateRenderGroupTransforms","_buildInstructions","_updateRenderables","index","upload","didViewUpdate","rendererOrPipes","reset","buildStart","blendMode","colorMask","sortableChildren","sortChildren","collectRenderablesWithEffects","buildEnd","WebGLSystem","WebGPUSystem","CanvasSystem","$433042607578a9a7$export$ff1832761d063f24","j","$d68b8eb9e5e57e06$export$1c1e67f49974a5b5","updateChildRenderGroups","$d68b8eb9e5e57e06$export$50ad8695661e3665","worldAlpha","appendFrom","$8KIbM","multiplyColors","groupColor","groupAlpha","localColor","localAlpha","childrenToUpdate","updateTick","renderGroupDepth","Number","childrenAtDepth","child","parentRenderGroup","relativeRenderGroupDepth","$d68b8eb9e5e57e06$export$cf7b65c878eb783a","updateFlags","didChange","updateLocalTransform","_updateFlags","$d68b8eb9e5e57e06$var$UPDATE_BLEND_COLOR_VISIBLE","$d68b8eb9e5e57e06$var$updateColorBlendVisibility","$d68b8eb9e5e57e06$var$tempContainer","children","$gRXu9","Container","UPDATE_VISIBLE","UPDATE_COLOR","UPDATE_BLEND","groupColorAlpha","groupBlendMode","localBlendMode","globalDisplayStatus","localDisplayStatus","$fa75833e253876b0$export$40044447708e4acc","rebuildRequired","pipe","$4e32db524195383e$export$ffb847f6753f2536","_gpuSpriteHash","create","_destroyRenderableBound","bind","renderableGC","addManagedHash","sprite","gpuSprite","_getGpuSprite","_updateBatchableSprite","uid","checkAndUpdateTexture","_texture","batchableSprite","off","visualBounds","_initGPUSprite","groupTransform","roundPixels","_roundPixels","on","$c93f83e965240bfe$export$3cdd191b816b3f8a","$lK0KY","$c0cbH","$c93f83e965240bfe$var$_BatcherPipe","_BatcherPipe","adaptor","state","State","for2d","_batchersByInstructionSet","_activeBatches","_adaptor","init","getBatcher","_availableBatchers","batchers","DefaultBatcher","_activeBatch","begin","batchableObject","batcherName","batches","indexBuffer","setDataWithSize","indexSize","attributeBuffer","float32View","attributeSize","batcher","dirty","action","shader","extensions","handleByMap","Batcher","$feb69f837ba6694a$export$cf1e9fa5acb94ac4","$4kixb","$hWIbe","$71eSK","$6NgLT","$4YnyE","$28usv","$feb69f837ba6694a$var$tempBounds","$feb69f837ba6694a$var$AlphaMaskEffect","FilterEffect","filters","MaskFilter","Sprite","Texture","EMPTY","inverse","value","_activeMaskStage","mask","maskedContainer","_maskOptions","canBundle","renderMaskToTexture","maskContainer","includeInBuild","collectRenderables","_maskedContainer","renderMask","filterEffect","measurable","getGlobalBounds","colorTextureSource","colorTexture","source","filterTexture","_resolution","offset","tx","minX","ty","minY","maskData","RendererType","WEBGL","filter","$3609ed1daf09bc77$export$6d9155deae913447","$022Ud","$4WM3f","$7ZovY","$aDwba","$buSTo","$aF6YU","$e0KyB","$9zLZG","Filter","options","rest","textureMatrix","TextureMatrix","gpuProgram","GpuProgram","from","entryPoint","glProgram","GlProgram","resources","filterUniforms","UniformGroup","uFilterMatrix","uMaskClamp","uClampFrame","uAlpha","uInverse","uMaskTexture","_textureMatrix","uniforms","apply","filterManager","input","output","clearMode","calculateSpriteMatrix","prepend","mapCoord","applyFilter","$ef0e1a74e377e668$export$ec91da630f36d5ea","$kmaR2","$ef0e1a74e377e668$var$_Filter","_Filter","Shader","defaultOptions","enabled","_state","padding","blendRequired","clipToViewport","addResource","gpu","gl","$ded3ae5cf2f06acd$export$2e2bcd8739ae039","$89de36e8de039d6f$export$2e2bcd8739ae039","$63a973ed2c62b87c$export$2e2bcd8739ae039","$fbcc864106d5c850$export$d4c3af11a9f163be","_colorStack","_colorStackIndex","_currentColor","_container","colorStack","currentColor","_mask","setMask","$dca00021d25990d4$export$6875bb6e3a32089e","$7gR5c","$6MbTD","_maskStackHash","_maskHash","WeakMap","_a","setBlendMode","effect","has","instructionsStart","instructionsLength","renderTargetUid","maskStackIndex","ensureDepthStencil","stencil","setStencilMode","STENCIL_MODES","RENDERING_MASK_ADD","INVERSE_MASK_ACTIVE","MASK_ACTIVE","RENDERING_MASK_REMOVE","clear","CLEAR","STENCIL","DISABLED","$9b37bae8666c4298$export$c69cd65c8827ac23","$hFslp","$9b37bae8666c4298$var$_BackgroundSystem","_BackgroundSystem","clearBeforeRender","_backgroundColor","Color","color","alpha","background","backgroundColor","backgroundAlpha","setAlpha","setValue","colorRgba","toArray","priority","$88c4a63cbc1f5501$export$fee7195ef0d08bcf","$c9aw6","$88c4a63cbc1f5501$var$BLEND_MODE_FILTERS","handle","BlendMode","Error","ref","_isAdvanced","_filterHash","_activeBlendMode","_renderableList","_endAdvancedBlendMode","_beginAdvancedBlendMode","warn","renderables","$4d12fdae2746e245$export$14c75b573db98096","$4d12fdae2746e245$var$imageTypes","png","jpg","webp","$4d12fdae2746e245$var$_ExtractSystem","_ExtractSystem","_normalizeOptions","defaults","target","image","Image","src","base64","format","quality","defaultImageOptions","canvas","toBlob","Promise","resolve","reject","blob","reader","FileReader","onload","result","onerror","readAsDataURL","toDataURL","convertToBlob","generateCanvas","textureGenerator","generateTexture","pixels","pixelInfo","getPixels","download","link","document","createElement","filename","href","body","appendChild","click","removeChild","log","console","$f3b15137a4f45c81$export$690776504ee197a6","$ec4lc","$4316K","$67iQf","$f3b15137a4f45c81$var$tempRect","Rectangle","$f3b15137a4f45c81$var$tempBounds","$f3b15137a4f45c81$var$noColor","textureSourceOptions","clearColor","isRGBAArray","Array","isArray","shared","region","copyTo","rectangle","Math","max","RenderTexture","updateMipmaps","$12e34bf3db3ada0e$export$813984f7330b4d72","$3dWsL","TextureSource","resize","$6ad9c034e5a8e39d$export$b9b6391a4528dd78","$hbjPo","$8n8Vu","$lc03N","_stackIndex","_globalUniformDataStack","_uniformsPool","_activeUniforms","_bindGroupPool","_activeBindGroups","size","projectionMatrix","bindGroup","currentGlobalUniformData","projectionData","Point","globalUniformData","uniformGroup","_createUniforms","uProjectionMatrix","uResolution","uWorldTransformMatrix","color32BitToUniform","uWorldColorAlpha","getUniformBindGroup","BindGroup","setResource","_currentGlobalUniformData","Float32Array","isStatic","$442cc62d6f04d660$export$b11154c55e5f16dd","$k3VU1","$442cc62d6f04d660$var$uid","_tasks","_offset","Ticker","system","_update","repeat","func","duration","useOffset","id","performance","now","last","cancel","splice","task","elapsed","remove","$4ee7b6e07c3982ee$export$63ce3e62fccb6f39","$11KLe","hello","context","webGLVersion","sayHello","$8b08ee031533c563$export$2c6a96c059a06e7c","$d0V4H","$2wPJh","$8b08ee031533c563$var$saidHello","DOMAdapter","getNavigator","userAgent","toLowerCase","indexOf","args","VERSION","$4a64db30d3a26925$export$a2204aeb1cc3b5ea","$5ytxW","$4a64db30d3a26925$var$renderableGCTick","$4a64db30d3a26925$var$_RenderableGCSystem","_RenderableGCSystem","_managedRenderables","_managedHashes","_managedArrays","maxUnusedTime","renderableGCMaxUnusedTime","_frequency","renderableGCFrequency","renderableGCActive","_handler","scheduler","run","_hashHandler","hash","cleanHash","_arrayHandler","array","cleanArray","addManagedArray","prerender","_now","gcTick","_updateInstructionGCTick","_lastUsed","once","_removeRenderable","managedRenderables","currentTick","destroyed","rp","$6d707366e75bfa04$export$e315d661f2bb796","clean","cleanHash2","$6d707366e75bfa04$export$c39b210f955bc1b8","arr","$649fd78d5232da48$export$a47b032752d8e393","$649fd78d5232da48$var$_TextureGCSystem","_TextureGCSystem","count","checkCount","checkCountMax","textureGCCheckCountMax","maxIdle","textureGCAMaxIdle","textureGCMaxIdle","active","textureGCActive","postrender","renderingToScreen","managedTextures","autoGarbageCollect","resource","_touched","unload","$18960edfc482c0eb$export$6f21c3d5af6602af","$aCdt0","$5R6vn","$i26u7","$18960edfc482c0eb$var$_ViewSystem","_ViewSystem","autoDensity","deprecation","v8_0_0","screen","createCanvas","getCanvasTexture","RenderTarget","colorTextures","depth","isRoot","transparent","desiredScreenWidth","desiredScreenHeight","removeView","parentNode","$f7ccc2b6d6689500$export$efcb1f8bf367cbfb","$fTJzX","$f7ccc2b6d6689500$var$_RenderTarget","_RenderTarget","descriptor","dirtyId","_size","_managedColorTextures","map","colorSource","onSourceResize","depthStencilTexture","ensureDepthStencilTexture","pixelWidth","pixelHeight","autoGenerateMipmaps","mipLevelCount","skipColorTexture","forEach","$6599c9e0f799f365$export$f2bcae39472d9516","$9HCqA","$6599c9e0f799f365$var$canvasCache","Map","CanvasSource","onDestroy","delete","$f107c1d33cf4bf55$export$649c859891b4f4a9","$bjxKI","$3wxNZ","$iZU4m","_syncFunctionHash","_systemCheck","unsafeEvalSupported","ensureUniformGroup","uniformData","getUniformGroupData","buffer","Buffer","data","layout","usage","BufferUsage","UNIFORM","COPY_DST","_signature","_initUniformGroup","uniformGroupSignature","elements","keys","uniformStructures","createUboElements","syncFunction","_generateUboSync","uboElements","generateUboSync","syncUniformGroup","uniformGroupData","dataInt32","updateUniformGroup","_dirtyId","synced","$af6de44cf94e2b7c$export$d72cdd5376f8af8e","$5fn1y","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","parsed","uniformParsers","uniformParser","test","ubo","template","Function","join","$91f1219963559a5d$export$cf9f41a7e506e2d2","uniform","red","$1705d6ce97c95cf0$var$loopMatrix","col","row","$1705d6ce97c95cf0$export$c761ef20854b0b5b","$1705d6ce97c95cf0$export$53279b3783655315","f32","i32","$4d4f3a3b4dbb7e2a$export$a79ef781de624449","$6p5EE","_resourceType","_resourceId","_bufferResource","onBufferChange","emit","destroyBuffer","$2d0a6ed5ddeec85d$export$abe4b4eea56679f6","$6Obke","extractedData","attributes","attribute","attributeData","instance","$2d0a6ed5ddeec85d$var$ensureStartAndStride","tempStride","tempStart","getAttributeInfoFromFormat","stride","$407244cf3627baae$export$861c1bf8bb2cddc7","NONE","stencilWriteMask","stencilReadMask","stencilFront","compare","passOp","stencilBack","$04dbce74b0e484cc$export$c555e722a4d2378a","$6EhkY","$4EOMD","$L6CRg","rootViewPort","viewport","onRenderTargetChange","SystemRunner","defaultClearColor","_renderSurfaceToRenderTargetHash","_gpuRenderTargetHash","_renderTargetStack","renderStart","rootRenderTarget","isRenderingToScreen","renderSurface","getRenderTarget","gpuRenderTarget","getGpuRenderTarget","resizeGpuRenderTarget","calculateProjection","startRenderPass","ALL","contextChange","currentRenderTargetData","isTexture","_initRenderTarget","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","min","key","destroyGpuRenderTarget","initGpuRenderTarget","resetState","$34a8cd72a4c09faa$export$fa0a4f720dae18a1","pm","flipY","sign","d","$be2e3065b62dc233$export$6eeeb7b7562073b1","HTMLCanvasElement","contains"],"version":3,"file":"WebGPURenderer.421fc519.js.map"}