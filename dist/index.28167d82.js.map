{"mappings":"IuYGI,EEDA,EsDKA,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,W,W,O,C,E,S,C,E,O,E,C,G,E,E,O,C,U,W,O,C,E,S,C,E,O,E,C,G9bLJ,IAgBA,EACA,EAjBI,EAAU,IAAI,IAgBlB,EAfA,SAAkB,CAAO,CAAE,CAAQ,EACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,GAAK,EAC5C,EAAQ,GAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CACvB,QAAS,EACT,KAAM,CAAQ,CAAC,EAAI,EAAE,AACvB,EAEJ,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,EAAQ,GAAG,CAAC,GAC3B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,IAAI,IAAI,EAAS,IAAI,CAAE,EAAS,OAAO,EAAE,QAAQ,EAC1D,C,G,E,Q,S,C,C,C,E,E,E,O,C,gB,W,O,C,G,E,E,O,C,a,W,O,C,GEsBK,IAAAyI,EAAA,GAGDA,CAHCA,EAAA,GAAA,CAAA,GAGD,WAAc,CAAA,cAGdA,EAAA,UAAa,CAAA,cAEbA,EAAA,iBAAoB,CAAA,sBAEpBA,EAAA,WAAc,CAAA,eAGdA,EAAA,WAAc,CAAA,eAEdA,EAAA,kBAAqB,CAAA,uBAErBA,EAAA,YAAe,CAAA,gBAGfA,EAAA,YAAe,CAAA,gBAEfA,EAAA,kBAAqB,CAAA,uBAErBA,EAAA,WAAc,CAAA,eAGdA,EAAA,KAAQ,CAAA,QAERA,EAAA,UAAa,CAAA,cAEbA,EAAA,aAAgB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c;AAAA,EAAK;AAAU,CAAI,CAAA,EACzC,OAAA,CAAQ,YAAa;AAAA,EAAK;AAAS,CAAI,CAAA,EACvC,OAAA,CAAQ,aAAc;AAAA,EAAK;AAAO,CAAI,CAGtE,C,E,E,O,C,iB,W,O,C,E,G,E,Q,S,C,C,C,E,E,E,O,C,a,W,O,C,GE1EgB,SAAA,EAAW,CAAA,CAAqB,CAChD,EACI,IAAI,EAAM,EAEV,IAAA,IAAW,KAAK,EAChB,CACU,IAAA,EAAQ,CAAA,CAAc,EAAC,CAMzB,EAFA,AAFa,EAAM,IAAA,CAAK,MAEf,MACb,CACU,EAAI,OAAQ,CAAA,CAAA,EAAA,EAAK,EAAC,EAAA,CAAA,CAAM,CAAA,OAAA,EAAU,EAAC;AAAA,EAAkB,EAAM,IAAK,CAAA;AAAK,MAAA,EAAW,EAAgB,aAAA,CAAA,EAKhG,EAAI,OAAA,CAAQ,CAAK,EAAA,EAAA,EAAC,EAAA,CAAA,CAAM,GAClC,CAGG,OAAA,CACX,C,G,E,Q,S,C,C,C,E,E,E,O,C,oB,W,O,C,G,E,E,O,C,sB,W,O,C,G,E,E,O,C,mB,W,O,C,G,E,E,O,C,qB,W,O,C,GE3BM,IAAA,EAA8B;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;AAAA,CAAA,CA8C9B,EAAgC;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;AAAA,CAAA,CAyBhC,EAA6B;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;AAAA,CAAA,CAsC7B,EAA+B;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;A;AAAA,CAAA,A,G,E,Q,S,C,C,C,E,E,E,O,C,oB,W,O,C,G,E,E,O,C,sB,W,O,C,GE7G9B,IAAM,EAAoB,CAC7B,KAAM,sBACN,OAAQ,CACJ,OAAkB;A;A;A;A;A;A;A;A;AAAA,QAAA,CAAA,AAAA,CAW1B,EAgBa,EAAsB,CAC/B,KAAM,sBACN,OAAQ,CACJ,OAAkB;A;A;A;A;AAAA,QAAA,CAAA,AAAA,CAQ1B,C,G,E,Q,S,C,C,C,E,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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/pixi.js/lib/extensions/Extensions.mjs","node_modules/pixi.js/src/extensions/Extensions.ts","node_modules/@parcel/runtime-js/lib/runtime-9df3f13a0d16de36.js","node_modules/@parcel/runtime-js/lib/helpers/browser/esm-js-loader.js","node_modules/@parcel/runtime-js/lib/runtime-bb0cc9c64533443c.js","node_modules/pixi.js/lib/rendering/init.mjs","node_modules/pixi.js/src/rendering/init.ts","node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs","node_modules/pixi.js/src/rendering/mask/alpha/AlphaMask.ts","node_modules/pixi.js/lib/scene/sprite/Sprite.mjs","node_modules/pixi.js/src/scene/sprite/Sprite.ts","node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs","node_modules/pixi.js/src/maths/point/ObservablePoint.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/Texture.ts","node_modules/eventemitter3/index.js","node_modules/pixi.js/lib/maths/matrix/groupD8.mjs","node_modules/pixi.js/src/maths/matrix/groupD8.ts","node_modules/pixi.js/lib/maths/matrix/Matrix.mjs","node_modules/pixi.js/src/maths/matrix/Matrix.ts","node_modules/pixi.js/lib/maths/misc/const.mjs","node_modules/pixi.js/src/maths/misc/const.ts","node_modules/pixi.js/lib/maths/point/Point.mjs","node_modules/pixi.js/src/maths/point/Point.ts","node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs","node_modules/pixi.js/src/maths/shapes/Rectangle.ts","node_modules/pixi.js/lib/utils/data/uid.mjs","node_modules/pixi.js/src/utils/data/uid.ts","node_modules/pixi.js/lib/utils/logging/deprecation.mjs","node_modules/pixi.js/src/utils/logging/deprecation.ts","node_modules/pixi.js/lib/utils/misc/NOOP.mjs","node_modules/pixi.js/src/utils/misc/NOOP.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/BufferImageSource.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/TextureSource.ts","node_modules/pixi.js/lib/maths/misc/pow2.mjs","node_modules/pixi.js/src/maths/misc/pow2.ts","node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs","node_modules/pixi.js/src/scene/container/utils/definedProps.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureStyle.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureMatrix.ts","node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs","node_modules/pixi.js/src/utils/data/updateQuadBounds.ts","node_modules/pixi.js/lib/scene/view/ViewContainer.mjs","node_modules/pixi.js/src/scene/view/ViewContainer.ts","node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs","node_modules/pixi.js/src/scene/container/bounds/Bounds.ts","node_modules/pixi.js/lib/scene/container/Container.mjs","node_modules/pixi.js/src/scene/container/Container.ts","node_modules/pixi.js/lib/color/Color.mjs","node_modules/pixi.js/src/color/Color.ts","node_modules/@pixi/colord/index.mjs","node_modules/@pixi/colord/plugins/names.mjs","node_modules/pixi.js/lib/culling/cullingMixin.mjs","node_modules/pixi.js/src/culling/cullingMixin.ts","node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs","node_modules/pixi.js/src/utils/pool/PoolGroup.ts","node_modules/pixi.js/lib/utils/pool/Pool.mjs","node_modules/pixi.js/src/utils/pool/Pool.ts","node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/cacheAsTextureMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/childrenHelperMixin.ts","node_modules/pixi.js/lib/utils/data/removeItems.mjs","node_modules/pixi.js/src/utils/data/removeItems.ts","node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/collectRenderablesMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/effectsMixin.ts","node_modules/pixi.js/lib/filters/FilterEffect.mjs","node_modules/pixi.js/src/filters/FilterEffect.ts","node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs","node_modules/pixi.js/src/rendering/mask/MaskEffectManager.ts","node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/findMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/getFastGlobalBoundsMixin.ts","node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs","node_modules/pixi.js/src/scene/container/bounds/utils/matrixAndBoundsPool.ts","node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/getGlobalMixin.ts","node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs","node_modules/pixi.js/src/scene/container/bounds/getGlobalBounds.ts","node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs","node_modules/pixi.js/src/scene/container/utils/multiplyColors.ts","node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs","node_modules/pixi.js/src/scene/container/utils/multiplyHexColors.ts","node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/measureMixin.ts","node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs","node_modules/pixi.js/src/scene/container/bounds/getLocalBounds.ts","node_modules/pixi.js/lib/utils/logging/warn.mjs","node_modules/pixi.js/src/utils/logging/warn.ts","node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs","node_modules/pixi.js/src/scene/container/utils/checkChildrenDidChange.ts","node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/onRenderMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/sortMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/toLocalGlobalMixin.ts","node_modules/pixi.js/lib/scene/container/RenderGroup.mjs","node_modules/pixi.js/src/scene/container/RenderGroup.ts","node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs","node_modules/pixi.js/src/rendering/renderers/shared/instructions/InstructionSet.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts","node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs","node_modules/pixi.js/src/scene/container/utils/assignWithIgnore.ts","node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs","node_modules/pixi.js/src/rendering/mask/utils/addMaskBounds.ts","node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs","node_modules/pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts","node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs","node_modules/pixi.js/src/rendering/mask/color/ColorMask.ts","node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs","node_modules/pixi.js/src/rendering/mask/stencil/StencilMask.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts","node_modules/pixi.js/lib/environment/adapter.mjs","node_modules/pixi.js/src/environment/adapter.ts","node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs","node_modules/pixi.js/src/environment-browser/BrowserAdapter.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts","node_modules/pixi.js/lib/ticker/Ticker.mjs","node_modules/pixi.js/src/ticker/Ticker.ts","node_modules/pixi.js/lib/ticker/const.mjs","node_modules/pixi.js/src/ticker/const.ts","node_modules/pixi.js/lib/ticker/TickerListener.mjs","node_modules/pixi.js/src/ticker/TickerListener.ts","node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs","node_modules/pixi.js/src/utils/browser/detectVideoAlphaMode.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts","node_modules/pixi.js/lib/assets/cache/Cache.mjs","node_modules/pixi.js/src/assets/cache/Cache.ts","node_modules/pixi.js/lib/assets/utils/convertToList.mjs","node_modules/pixi.js/src/assets/utils/convertToList.ts","node_modules/pixi.js/lib/spritesheet/init.mjs","node_modules/pixi.js/src/spritesheet/init.ts","node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs","node_modules/pixi.js/src/spritesheet/spritesheetAsset.ts","node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs","node_modules/pixi.js/src/assets/loader/parsers/LoaderParser.ts","node_modules/pixi.js/lib/assets/resolver/Resolver.mjs","node_modules/pixi.js/src/assets/resolver/Resolver.ts","node_modules/pixi.js/lib/utils/path.mjs","node_modules/pixi.js/src/utils/path.ts","node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs","node_modules/pixi.js/src/assets/utils/createStringVariations.ts","node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs","node_modules/pixi.js/src/assets/utils/isSingleItem.ts","node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs","node_modules/pixi.js/src/assets/utils/copySearchParams.ts","node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs","node_modules/pixi.js/src/spritesheet/Spritesheet.ts","node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs","node_modules/pixi.js/src/rendering/renderers/shared/system/AbstractRenderer.ts","node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs","node_modules/pixi.js/src/environment/autoDetectEnvironment.ts","node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs","node_modules/pixi.js/src/utils/browser/unsafeEvalSupported.ts","node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs","node_modules/pixi.js/src/rendering/renderers/gl/const.ts","node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs","node_modules/pixi.js/src/rendering/renderers/shared/system/SystemRunner.ts","node_modules/@parcel/runtime-js/lib/runtime-4f1574e53fc7b3f3.js","node_modules/@parcel/runtime-js/lib/runtime-def6007c7eec9ce0.js","node_modules/pixi.js/lib/utils/global/globalHooks.mjs","node_modules/pixi.js/src/utils/global/globalHooks.ts","node_modules/pixi.js/lib/utils/const.mjs","node_modules/pixi.js/src/utils/const.ts","node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs","node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts","node_modules/pixi.js/lib/scene/text/TextStyle.mjs","node_modules/pixi.js/src/scene/text/TextStyle.ts","node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs","node_modules/pixi.js/src/scene/graphics/shared/fill/FillGradient.ts","node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs","node_modules/pixi.js/src/scene/graphics/shared/fill/FillPattern.ts","node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs","node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts","node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs","node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts","node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs","node_modules/pixi.js/src/scene/graphics/shared/svg/SVGToGraphicsPath.ts","node_modules/parse-svg-path/index.js","node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs","node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts","node_modules/pixi.js/lib/maths/shapes/Circle.mjs","node_modules/pixi.js/src/maths/shapes/Circle.ts","node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs","node_modules/pixi.js/src/maths/shapes/Ellipse.ts","node_modules/pixi.js/lib/maths/shapes/Polygon.mjs","node_modules/pixi.js/src/maths/shapes/Polygon.ts","node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs","node_modules/pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts","node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs","node_modules/pixi.js/src/maths/shapes/RoundedRectangle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts","node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs","node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts","node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs","node_modules/pixi.js/src/rendering/batcher/gpu/getTextureBatchBindGroup.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts","node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs","node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts","node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs","node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts","node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs","node_modules/pixi.js/src/rendering/batcher/shared/DefaultBatcher.ts","node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs","node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts","node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs","node_modules/pixi.js/src/utils/data/ViewableBuffer.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts","node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs","node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts","node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs","node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts","node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs","node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts","node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs","node_modules/pixi.js/src/rendering/batcher/shared/BatchGeometry.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts","node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs","node_modules/pixi.js/src/rendering/batcher/shared/DefaultShader.ts","node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts","node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs","node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts","node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts","node_modules/pixi.js/lib/rendering/renderers/types.mjs","node_modules/pixi.js/src/rendering/renderers/types.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts","node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs","node_modules/pixi.js/src/scene/graphics/shared/BatchableGraphics.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts","node_modules/pixi.js/lib/scene/graphics/shared/const.mjs","node_modules/pixi.js/src/scene/graphics/shared/const.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPixelLine.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts","node_modules/earcut/src/earcut.js","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts","node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs","node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts","node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs","node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts","node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs","node_modules/pixi.js/src/scene/text/utils/generateTextStyleKey.ts","node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs","node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts","node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs","node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts","node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs","node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts","node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs","node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts","node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs","node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts","node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs","node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts","node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs","node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts","node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts","node_modules/@parcel/runtime-js/lib/runtime-1e794f238ccb155d.js","src/index.js","node_modules/pixi.js/lib/index.mjs","node_modules/pixi.js/src/index.ts","node_modules/pixi.js/lib/environment-browser/browserExt.mjs","node_modules/pixi.js/src/environment-browser/browserExt.ts","node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs","node_modules/pixi.js/src/environment-webworker/webworkerExt.ts","node_modules/pixi.js/lib/app/Application.mjs","node_modules/pixi.js/src/app/Application.ts","node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs","node_modules/pixi.js/src/rendering/renderers/autoDetectRenderer.ts","node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs","node_modules/pixi.js/src/utils/browser/isWebGLSupported.ts","node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs","node_modules/pixi.js/src/utils/browser/isWebGPUSupported.ts","node_modules/pixi.js/lib/assets/Assets.mjs","node_modules/pixi.js/src/assets/Assets.ts","node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs","node_modules/pixi.js/src/scene/text-bitmap/asset/loadBitmapFont.ts","node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs","node_modules/pixi.js/src/scene/text-bitmap/BitmapFont.ts","node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs","node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontTextParser.ts","node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs","node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts","node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs","node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLParser.ts","node_modules/pixi.js/lib/assets/BackgroundLoader.mjs","node_modules/pixi.js/src/assets/BackgroundLoader.ts","node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs","node_modules/pixi.js/src/assets/cache/parsers/cacheTextureArray.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectAvif.ts","node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs","node_modules/pixi.js/src/assets/detections/utils/testImageFormat.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectDefaults.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectMp4.ts","node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs","node_modules/pixi.js/src/assets/detections/utils/testVideoFormat.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectOgv.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectWebm.ts","node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs","node_modules/pixi.js/src/assets/detections/parsers/detectWebp.ts","node_modules/pixi.js/lib/assets/loader/Loader.mjs","node_modules/pixi.js/src/assets/loader/Loader.ts","node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs","node_modules/pixi.js/src/assets/loader/parsers/loadJson.ts","node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs","node_modules/pixi.js/src/assets/utils/checkDataUrl.ts","node_modules/pixi.js/lib/assets/utils/checkExtension.mjs","node_modules/pixi.js/src/assets/utils/checkExtension.ts","node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs","node_modules/pixi.js/src/assets/loader/parsers/loadTxt.ts","node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs","node_modules/pixi.js/src/assets/loader/parsers/loadWebFont.ts","node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs","node_modules/pixi.js/src/assets/loader/parsers/textures/loadSVG.ts","node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs","node_modules/pixi.js/src/utils/network/getResolutionOfUrl.ts","node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs","node_modules/pixi.js/src/assets/loader/parsers/textures/utils/createTexture.ts","node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs","node_modules/pixi.js/src/assets/loader/parsers/textures/loadTextures.ts","node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs","node_modules/pixi.js/src/assets/loader/workers/WorkerManager.ts","node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs","node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs","node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs","node_modules/pixi.js/src/assets/loader/parsers/textures/loadVideoTextures.ts","node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs","node_modules/pixi.js/src/assets/resolver/parsers/resolveJsonUrl.ts","node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs","node_modules/pixi.js/src/assets/resolver/parsers/resolveTextureUrl.ts","node_modules/pixi.js/lib/scene/text/Text.mjs","node_modules/pixi.js/src/scene/text/Text.ts","node_modules/pixi.js/lib/scene/text/AbstractText.mjs","node_modules/pixi.js/src/scene/text/AbstractText.ts","src/game.ts","src/reelManager.ts","src/symbolManager.ts","src/symbol.ts","src/resourceManager.ts","src/uiManager.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"kyEFX\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", function () { return $ef7689007096c8a0$export$6503ec6e8aabbaf; }, function (v) { return $ef7689007096c8a0$export$6503ec6e8aabbaf = v; });\n$parcel$export(module.exports, \"resolve\", function () { return $ef7689007096c8a0$export$f7ad0328861e2f03; }, function (v) { return $ef7689007096c8a0$export$f7ad0328861e2f03 = v; });\nvar $ef7689007096c8a0$export$6503ec6e8aabbaf;\nvar $ef7689007096c8a0$export$f7ad0328861e2f03;\n\"use strict\";\nvar $ef7689007096c8a0$var$mapping = new Map();\nfunction $ef7689007096c8a0$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$ef7689007096c8a0$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $ef7689007096c8a0$var$resolve(id) {\n    var resolved = $ef7689007096c8a0$var$mapping.get(id);\n    if (resolved == null) throw new Error('Could not resolve bundle with id ' + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$ef7689007096c8a0$export$6503ec6e8aabbaf = $ef7689007096c8a0$var$register;\n$ef7689007096c8a0$export$f7ad0328861e2f03 = $ef7689007096c8a0$var$resolve;\n\n});\n\nparcelRegister(\"kFA6i\", function(module, exports) {\n\n$parcel$export(module.exports, \"ExtensionType\", function () { return $c8c99521170b225f$export$4f037c6ec2da4eeb; });\n$parcel$export(module.exports, \"extensions\", function () { return $c8c99521170b225f$export$cc3e2d3244e01b7f; });\n\"use strict\";\nvar $c8c99521170b225f$export$4f037c6ec2da4eeb = /* @__PURE__ */ ((ExtensionType2)=>{\n    ExtensionType2[\"Application\"] = \"application\";\n    ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n    ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n    ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n    ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n    ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n    ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n    ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n    ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n    ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n    ExtensionType2[\"Asset\"] = \"asset\";\n    ExtensionType2[\"LoadParser\"] = \"load-parser\";\n    ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n    ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n    ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n    ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n    ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n    ExtensionType2[\"TextureSource\"] = \"texture-source\";\n    ExtensionType2[\"Environment\"] = \"environment\";\n    ExtensionType2[\"ShapeBuilder\"] = \"shape-builder\";\n    ExtensionType2[\"Batcher\"] = \"batcher\";\n    return ExtensionType2;\n})($c8c99521170b225f$export$4f037c6ec2da4eeb || {});\nconst $c8c99521170b225f$var$normalizeExtension = (ext)=>{\n    if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n        if (!ext.extension) throw new Error(\"Extension class must have an extension object\");\n        const metadata = typeof ext.extension !== \"object\" ? {\n            type: ext.extension\n        } : ext.extension;\n        ext = {\n            ...metadata,\n            ref: ext\n        };\n    }\n    if (typeof ext === \"object\") ext = {\n        ...ext\n    };\n    else throw new Error(\"Invalid extension type\");\n    if (typeof ext.type === \"string\") ext.type = [\n        ext.type\n    ];\n    return ext;\n};\nconst $c8c99521170b225f$export$ba4241979983e013 = (ext, defaultPriority)=>$c8c99521170b225f$var$normalizeExtension(ext).priority ?? defaultPriority;\nconst $c8c99521170b225f$export$cc3e2d3244e01b7f = {\n    /** @ignore */ _addHandlers: {},\n    /** @ignore */ _removeHandlers: {},\n    /** @ignore */ _queue: {},\n    /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */ remove (...extensions2) {\n        extensions2.map($c8c99521170b225f$var$normalizeExtension).forEach((ext)=>{\n            ext.type.forEach((type)=>this._removeHandlers[type]?.(ext));\n        });\n        return this;\n    },\n    /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */ add (...extensions2) {\n        extensions2.map($c8c99521170b225f$var$normalizeExtension).forEach((ext)=>{\n            ext.type.forEach((type)=>{\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n                if (!handlers[type]) {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                } else handlers[type]?.(ext);\n            });\n        });\n        return this;\n    },\n    /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */ handle (type, onAdd, onRemove) {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n        if (addHandlers[type] || removeHandlers[type]) throw new Error(`Extension type ${type} already has a handler`);\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n        const queue = this._queue;\n        if (queue[type]) {\n            queue[type]?.forEach((ext)=>onAdd(ext));\n            delete queue[type];\n        }\n        return this;\n    },\n    /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */ handleByMap (type, map) {\n        return this.handle(type, (extension)=>{\n            if (extension.name) map[extension.name] = extension.ref;\n        }, (extension)=>{\n            if (extension.name) delete map[extension.name];\n        });\n    },\n    /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */ handleByNamedList (type, map, defaultPriority = -1) {\n        return this.handle(type, (extension)=>{\n            const index = map.findIndex((item)=>item.name === extension.name);\n            if (index >= 0) return;\n            map.push({\n                name: extension.name,\n                value: extension.ref\n            });\n            map.sort((a, b)=>$c8c99521170b225f$export$ba4241979983e013(b.value, defaultPriority) - $c8c99521170b225f$export$ba4241979983e013(a.value, defaultPriority));\n        }, (extension)=>{\n            const index = map.findIndex((item)=>item.name === extension.name);\n            if (index !== -1) map.splice(index, 1);\n        });\n    },\n    /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */ handleByList (type, list, defaultPriority = -1) {\n        return this.handle(type, (extension)=>{\n            if (list.includes(extension.ref)) return;\n            list.push(extension.ref);\n            list.sort((a, b)=>$c8c99521170b225f$export$ba4241979983e013(b, defaultPriority) - $c8c99521170b225f$export$ba4241979983e013(a, defaultPriority));\n        }, (extension)=>{\n            const index = list.indexOf(extension.ref);\n            if (index !== -1) list.splice(index, 1);\n        });\n    }\n};\n\n});\n\nparcelRegister(\"87946\", function(module, exports) {\n\nvar $hffE7 = parcelRequire(\"hffE7\");\nmodule.exports = Promise.all([\n    $hffE7(\"d1bSR\"),\n    $hffE7(\"5nC1g\")\n]).then(()=>parcelRequire('4zK10'));\n\n});\nparcelRegister(\"hffE7\", function(module, exports) {\n\"use strict\";\n\nfunction $c8dff9588896671a$var$load(id) {\n    // eslint-disable-next-line no-undef\n    return import((parcelRequire(\"kyEFX\")).resolve(id));\n}\nmodule.exports = $c8dff9588896671a$var$load;\n\n});\n\n\nparcelRegister(\"lvdPr\", function(module, exports) {\n\nvar $hffE7 = parcelRequire(\"hffE7\");\nmodule.exports = Promise.all([\n    $hffE7(\"d1bSR\"),\n    $hffE7(\"8rxSw\")\n]).then(()=>parcelRequire('i6XA8'));\n\n});\n\nparcelRegister(\"6PbjS\", function(module, exports) {\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $hMWwR = parcelRequire(\"hMWwR\");\n\nvar $6yBjn = parcelRequire(\"6yBjn\");\n\nvar $c9Hg5 = parcelRequire(\"c9Hg5\");\n\nvar $eiaM4 = parcelRequire(\"eiaM4\");\n\nvar $9HCqA = parcelRequire(\"9HCqA\");\n\nvar $hRHFw = parcelRequire(\"hRHFw\");\n\nvar $9QDRe = parcelRequire(\"9QDRe\");\nparcelRequire(\"9ErZc\");\n\n\"use strict\";\n(0, $kFA6i.extensions).add((0, $hMWwR.AlphaMask), (0, $6yBjn.ColorMask), (0, $c9Hg5.StencilMask), (0, $9QDRe.VideoSource), (0, $hRHFw.ImageSource), (0, $9HCqA.CanvasSource), (0, $eiaM4.BufferImageSource));\n\n});\nparcelRegister(\"hMWwR\", function(module, exports) {\n\n$parcel$export(module.exports, \"AlphaMask\", function () { return $0b3ed93070685547$export$3c32667be409917c; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $6NgLT = parcelRequire(\"6NgLT\");\n\nvar $7tYoJ = parcelRequire(\"7tYoJ\");\n\nvar $ey5hm = parcelRequire(\"ey5hm\");\n\"use strict\";\nclass $0b3ed93070685547$export$3c32667be409917c {\n    constructor(options){\n        this.priority = 0;\n        this.inverse = false;\n        this.pipe = \"alphaMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n        this.renderMaskToTexture = !(mask instanceof (0, $6NgLT.Sprite));\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n        this.mask.measurable = false;\n    }\n    reset() {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n    addBounds(bounds, skipUpdateTransform) {\n        if (!this.inverse) (0, $7tYoJ.addMaskBounds)(this.mask, bounds, skipUpdateTransform);\n    }\n    addLocalBounds(bounds, localRoot) {\n        (0, $ey5hm.addMaskLocalBounds)(this.mask, bounds, localRoot);\n    }\n    containsPoint(point, hitTestFn) {\n        const mask = this.mask;\n        return hitTestFn(mask, point);\n    }\n    destroy() {\n        this.reset();\n    }\n    static test(mask) {\n        return mask instanceof (0, $6NgLT.Sprite);\n    }\n}\n$0b3ed93070685547$export$3c32667be409917c.extension = (0, $kFA6i.ExtensionType).MaskEffect;\n\n});\nparcelRegister(\"6NgLT\", function(module, exports) {\n\n$parcel$export(module.exports, \"Sprite\", function () { return $ba0fb74591e28f6d$export$3075603db8e6204c; });\n\nvar $dq7e0 = parcelRequire(\"dq7e0\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $04UFt = parcelRequire(\"04UFt\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $4ndcs = parcelRequire(\"4ndcs\");\n\"use strict\";\nclass $ba0fb74591e28f6d$export$3075603db8e6204c extends (0, $4ndcs.ViewContainer) {\n    /**\n   * @param options - The options for creating the sprite.\n   */ constructor(options = (0, $4YnyE.Texture).EMPTY){\n        if (options instanceof (0, $4YnyE.Texture)) options = {\n            texture: options\n        };\n        const { texture: texture = (0, $4YnyE.Texture).EMPTY, anchor: anchor, roundPixels: roundPixels, width: width, height: height, ...rest } = options;\n        super({\n            label: \"Sprite\",\n            ...rest\n        });\n        this.renderPipeId = \"sprite\";\n        this.batched = true;\n        this._visualBounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        this._anchor = new (0, $dq7e0.ObservablePoint)({\n            _onUpdate: ()=>{\n                this.onViewUpdate();\n            }\n        });\n        if (anchor) this.anchor = anchor;\n        else if (texture.defaultAnchor) this.anchor = texture.defaultAnchor;\n        this.texture = texture;\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n        if (width !== void 0) this.width = width;\n        if (height !== void 0) this.height = height;\n    }\n    /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */ static from(source, skipCache = false) {\n        if (source instanceof (0, $4YnyE.Texture)) return new $ba0fb74591e28f6d$export$3075603db8e6204c(source);\n        return new $ba0fb74591e28f6d$export$3075603db8e6204c((0, $4YnyE.Texture).from(source, skipCache));\n    }\n    set texture(value) {\n        value || (value = (0, $4YnyE.Texture).EMPTY);\n        const currentTexture = this._texture;\n        if (currentTexture === value) return;\n        if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n        if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n        this._texture = value;\n        if (this._width) this._setWidth(this._width, this._texture.orig.width);\n        if (this._height) this._setHeight(this._height, this._texture.orig.height);\n        this.onViewUpdate();\n    }\n    /** The texture that the sprite is using. */ get texture() {\n        return this._texture;\n    }\n    /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */ get visualBounds() {\n        (0, $04UFt.updateQuadBounds)(this._visualBounds, this._anchor, this._texture);\n        return this._visualBounds;\n    }\n    /**\n   * @deprecated\n   */ get sourceBounds() {\n        (0, $aCdt0.deprecation)(\"8.6.1\", \"Sprite.sourceBounds is deprecated, use visualBounds instead.\");\n        return this.visualBounds;\n    }\n    /** @private */ updateBounds() {\n        const anchor = this._anchor;\n        const texture = this._texture;\n        const bounds = this._bounds;\n        const { width: width, height: height } = texture.orig;\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n    /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */ destroy(options = false) {\n        super.destroy(options);\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            this._texture.destroy(destroyTextureSource);\n        }\n        this._texture = null;\n        this._visualBounds = null;\n        this._bounds = null;\n        this._anchor = null;\n    }\n    /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */ get anchor() {\n        return this._anchor;\n    }\n    set anchor(value) {\n        typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */ get width() {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n    set width(value) {\n        this._setWidth(value, this._texture.orig.width);\n        this._width = value;\n    }\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */ get height() {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n    set height(value) {\n        this._setHeight(value, this._texture.orig.height);\n        this._height = value;\n    }\n    /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */ getSize(out) {\n        out || (out = {});\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n        return out;\n    }\n    /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */ setSize(value, height) {\n        if (typeof value === \"object\") {\n            height = value.height ?? value.width;\n            value = value.width;\n        } else height ?? (height = value);\n        value !== void 0 && this._setWidth(value, this._texture.orig.width);\n        height !== void 0 && this._setHeight(height, this._texture.orig.height);\n    }\n}\n\n});\nparcelRegister(\"dq7e0\", function(module, exports) {\n\n$parcel$export(module.exports, \"ObservablePoint\", function () { return $ffac4789f4a1c62b$export$3755aaad3fd42e52; });\n\"use strict\";\nclass $ffac4789f4a1c62b$export$3755aaad3fd42e52 {\n    /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */ constructor(observer, x, y){\n        this._x = x || 0;\n        this._y = y || 0;\n        this._observer = observer;\n    }\n    /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */ clone(observer) {\n        return new $ffac4789f4a1c62b$export$3755aaad3fd42e52(observer ?? this._observer, this._x, this._y);\n    }\n    /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */ set(x = 0, y = x) {\n        if (this._x !== x || this._y !== y) {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n        return this;\n    }\n    /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */ copyFrom(p) {\n        if (this._x !== p.x || this._y !== p.y) {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n        return this;\n    }\n    /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */ copyTo(p) {\n        p.set(this._x, this._y);\n        return p;\n    }\n    /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */ equals(p) {\n        return p.x === this._x && p.y === this._y;\n    }\n    toString() {\n        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n    }\n    /** Position of the observable point on the x axis. */ get x() {\n        return this._x;\n    }\n    set x(value) {\n        if (this._x !== value) {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n    /** Position of the observable point on the y axis. */ get y() {\n        return this._y;\n    }\n    set y(value) {\n        if (this._y !== value) {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n\n});\n\nparcelRegister(\"4YnyE\", function(module, exports) {\n\n$parcel$export(module.exports, \"Texture\", function () { return $4b15df50dcdad398$export$5431306cf43de24a; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $bvDrV = parcelRequire(\"bvDrV\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $87q4u = parcelRequire(\"87q4u\");\n\nvar $eiaM4 = parcelRequire(\"eiaM4\");\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\nvar $aDwba = parcelRequire(\"aDwba\");\n\"use strict\";\nclass $4b15df50dcdad398$export$5431306cf43de24a extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    /**\n   * @param {rendering.TextureOptions} options - Options for the texture\n   */ constructor({ source: source, label: label, frame: frame, orig: orig, trim: trim, defaultAnchor: defaultAnchor, defaultBorders: defaultBorders, rotate: rotate, dynamic: dynamic } = {}){\n        super();\n        /** unique id for this texture */ this.uid = (0, $fTJzX.uid)(\"texture\");\n        /** A uvs object based on the given frame and the texture source */ this.uvs = {\n            x0: 0,\n            y0: 0,\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            x3: 0,\n            y3: 0\n        };\n        /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */ this.frame = new (0, $ec4lc.Rectangle)();\n        /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */ this.noFrame = false;\n        /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */ this.dynamic = false;\n        /** is it a texture? yes! used for type checking */ this.isTexture = true;\n        this.label = label;\n        this.source = source?.source ?? new (0, $3dWsL.TextureSource)();\n        this.noFrame = !frame;\n        if (frame) this.frame.copyFrom(frame);\n        else {\n            const { width: width, height: height } = this._source;\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n        this.orig = orig || this.frame;\n        this.trim = trim;\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n        this.updateUvs();\n    }\n    set source(value) {\n        if (this._source) this._source.off(\"resize\", this.update, this);\n        this._source = value;\n        value.on(\"resize\", this.update, this);\n        this.emit(\"update\", this);\n    }\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */ get source() {\n        return this._source;\n    }\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */ get textureMatrix() {\n        if (!this._textureMatrix) this._textureMatrix = new (0, $aDwba.TextureMatrix)(this);\n        return this._textureMatrix;\n    }\n    /** The width of the Texture in pixels. */ get width() {\n        return this.orig.width;\n    }\n    /** The height of the Texture in pixels. */ get height() {\n        return this.orig.height;\n    }\n    /** Call this function when you have modified the frame of this texture. */ updateUvs() {\n        const { uvs: uvs, frame: frame } = this;\n        const { width: width, height: height } = this._source;\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n        let rotate = this.rotate;\n        if (rotate) {\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n            const cX = nX + w2;\n            const cY = nY + h2;\n            rotate = (0, $bvDrV.groupD8).add(rotate, (0, $bvDrV.groupD8).NW);\n            uvs.x0 = cX + w2 * (0, $bvDrV.groupD8).uX(rotate);\n            uvs.y0 = cY + h2 * (0, $bvDrV.groupD8).uY(rotate);\n            rotate = (0, $bvDrV.groupD8).add(rotate, 2);\n            uvs.x1 = cX + w2 * (0, $bvDrV.groupD8).uX(rotate);\n            uvs.y1 = cY + h2 * (0, $bvDrV.groupD8).uY(rotate);\n            rotate = (0, $bvDrV.groupD8).add(rotate, 2);\n            uvs.x2 = cX + w2 * (0, $bvDrV.groupD8).uX(rotate);\n            uvs.y2 = cY + h2 * (0, $bvDrV.groupD8).uY(rotate);\n            rotate = (0, $bvDrV.groupD8).add(rotate, 2);\n            uvs.x3 = cX + w2 * (0, $bvDrV.groupD8).uX(rotate);\n            uvs.y3 = cY + h2 * (0, $bvDrV.groupD8).uY(rotate);\n        } else {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n    /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */ destroy(destroySource = false) {\n        if (this._source) {\n            if (destroySource) {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n    }\n    /**\n   * Call this if you have modified the `texture outside` of the constructor.\n   *\n   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n   */ update() {\n        if (this.noFrame) {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n        this.updateUvs();\n        this.emit(\"update\", this);\n    }\n    /** @deprecated since 8.0.0 */ get baseTexture() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Texture.baseTexture is now Texture.source\");\n        return this._source;\n    }\n}\n$4b15df50dcdad398$export$5431306cf43de24a.EMPTY = new $4b15df50dcdad398$export$5431306cf43de24a({\n    label: \"EMPTY\",\n    source: new (0, $3dWsL.TextureSource)({\n        label: \"EMPTY\"\n    })\n});\n$4b15df50dcdad398$export$5431306cf43de24a.EMPTY.destroy = (0, $87q4u.NOOP);\n$4b15df50dcdad398$export$5431306cf43de24a.WHITE = new $4b15df50dcdad398$export$5431306cf43de24a({\n    source: new (0, $eiaM4.BufferImageSource)({\n        resource: new Uint8Array([\n            255,\n            255,\n            255,\n            255\n        ]),\n        width: 1,\n        height: 1,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        label: \"WHITE\"\n    }),\n    label: \"WHITE\"\n});\n$4b15df50dcdad398$export$5431306cf43de24a.WHITE.destroy = (0, $87q4u.NOOP);\n\n});\nparcelRegister(\"6p5EE\", function(module, exports) {\n'use strict';\nvar $4a9976ca6ebf6735$var$has = Object.prototype.hasOwnProperty, $4a9976ca6ebf6735$var$prefix = '~';\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function $4a9976ca6ebf6735$var$Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    $4a9976ca6ebf6735$var$Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new $4a9976ca6ebf6735$var$Events().__proto__) $4a9976ca6ebf6735$var$prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function $4a9976ca6ebf6735$var$EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function $4a9976ca6ebf6735$var$addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== 'function') throw new TypeError('The listener must be a function');\n    var listener = new $4a9976ca6ebf6735$var$EE(fn, context || emitter, once), evt = $4a9976ca6ebf6735$var$prefix ? $4a9976ca6ebf6735$var$prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function $4a9976ca6ebf6735$var$clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new $4a9976ca6ebf6735$var$Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function $4a9976ca6ebf6735$var$EventEmitter() {\n    this._events = new $4a9976ca6ebf6735$var$Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ $4a9976ca6ebf6735$var$EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events)if ($4a9976ca6ebf6735$var$has.call(events, name)) names.push($4a9976ca6ebf6735$var$prefix ? name.slice(1) : name);\n    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ $4a9976ca6ebf6735$var$EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = $4a9976ca6ebf6735$var$prefix ? $4a9976ca6ebf6735$var$prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ $4a9976ca6ebf6735$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = $4a9976ca6ebf6735$var$prefix ? $4a9976ca6ebf6735$var$prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ $4a9976ca6ebf6735$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = $4a9976ca6ebf6735$var$prefix ? $4a9976ca6ebf6735$var$prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $4a9976ca6ebf6735$var$EventEmitter.prototype.on = function on(event, fn, context) {\n    return $4a9976ca6ebf6735$var$addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $4a9976ca6ebf6735$var$EventEmitter.prototype.once = function once(event, fn, context) {\n    return $4a9976ca6ebf6735$var$addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ $4a9976ca6ebf6735$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = $4a9976ca6ebf6735$var$prefix ? $4a9976ca6ebf6735$var$prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        $4a9976ca6ebf6735$var$clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $4a9976ca6ebf6735$var$clearEvent(this, evt);\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else $4a9976ca6ebf6735$var$clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ $4a9976ca6ebf6735$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = $4a9976ca6ebf6735$var$prefix ? $4a9976ca6ebf6735$var$prefix + event : event;\n        if (this._events[evt]) $4a9976ca6ebf6735$var$clearEvent(this, evt);\n    } else {\n        this._events = new $4a9976ca6ebf6735$var$Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\n$4a9976ca6ebf6735$var$EventEmitter.prototype.off = $4a9976ca6ebf6735$var$EventEmitter.prototype.removeListener;\n$4a9976ca6ebf6735$var$EventEmitter.prototype.addListener = $4a9976ca6ebf6735$var$EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\n$4a9976ca6ebf6735$var$EventEmitter.prefixed = $4a9976ca6ebf6735$var$prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\n$4a9976ca6ebf6735$var$EventEmitter.EventEmitter = $4a9976ca6ebf6735$var$EventEmitter;\nmodule.exports = $4a9976ca6ebf6735$var$EventEmitter;\n\n});\n\nparcelRegister(\"bvDrV\", function(module, exports) {\n\n$parcel$export(module.exports, \"groupD8\", function () { return $337e48ae514d7a47$export$b7bb6a2a8d203102; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\"use strict\";\nconst $337e48ae514d7a47$var$ux = [\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1\n];\nconst $337e48ae514d7a47$var$uy = [\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1\n];\nconst $337e48ae514d7a47$var$vx = [\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1\n];\nconst $337e48ae514d7a47$var$vy = [\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1\n];\nconst $337e48ae514d7a47$var$rotationCayley = [];\nconst $337e48ae514d7a47$var$rotationMatrices = [];\nconst $337e48ae514d7a47$var$signum = Math.sign;\nfunction $337e48ae514d7a47$var$init() {\n    for(let i = 0; i < 16; i++){\n        const row = [];\n        $337e48ae514d7a47$var$rotationCayley.push(row);\n        for(let j = 0; j < 16; j++){\n            const _ux = $337e48ae514d7a47$var$signum($337e48ae514d7a47$var$ux[i] * $337e48ae514d7a47$var$ux[j] + $337e48ae514d7a47$var$vx[i] * $337e48ae514d7a47$var$uy[j]);\n            const _uy = $337e48ae514d7a47$var$signum($337e48ae514d7a47$var$uy[i] * $337e48ae514d7a47$var$ux[j] + $337e48ae514d7a47$var$vy[i] * $337e48ae514d7a47$var$uy[j]);\n            const _vx = $337e48ae514d7a47$var$signum($337e48ae514d7a47$var$ux[i] * $337e48ae514d7a47$var$vx[j] + $337e48ae514d7a47$var$vx[i] * $337e48ae514d7a47$var$vy[j]);\n            const _vy = $337e48ae514d7a47$var$signum($337e48ae514d7a47$var$uy[i] * $337e48ae514d7a47$var$vx[j] + $337e48ae514d7a47$var$vy[i] * $337e48ae514d7a47$var$vy[j]);\n            for(let k = 0; k < 16; k++)if ($337e48ae514d7a47$var$ux[k] === _ux && $337e48ae514d7a47$var$uy[k] === _uy && $337e48ae514d7a47$var$vx[k] === _vx && $337e48ae514d7a47$var$vy[k] === _vy) {\n                row.push(k);\n                break;\n            }\n        }\n    }\n    for(let i = 0; i < 16; i++){\n        const mat = new (0, $0kbcf.Matrix)();\n        mat.set($337e48ae514d7a47$var$ux[i], $337e48ae514d7a47$var$uy[i], $337e48ae514d7a47$var$vx[i], $337e48ae514d7a47$var$vy[i], 0, 0);\n        $337e48ae514d7a47$var$rotationMatrices.push(mat);\n    }\n}\n$337e48ae514d7a47$var$init();\nconst $337e48ae514d7a47$export$b7bb6a2a8d203102 = {\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ E: 0,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ SE: 1,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ S: 2,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ SW: 3,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ W: 4,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ NW: 5,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ N: 6,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ NE: 7,\n    /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MIRROR_VERTICAL: 8,\n    /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MAIN_DIAGONAL: 10,\n    /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MIRROR_HORIZONTAL: 12,\n    /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ REVERSE_DIAGONAL: 14,\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */ uX: (ind)=>$337e48ae514d7a47$var$ux[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */ uY: (ind)=>$337e48ae514d7a47$var$uy[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */ vX: (ind)=>$337e48ae514d7a47$var$vx[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */ vY: (ind)=>$337e48ae514d7a47$var$vy[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */ inv: (rotation)=>{\n        if (rotation & 8) return rotation & 15;\n        return -rotation & 7;\n    },\n    /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */ add: (rotationSecond, rotationFirst)=>$337e48ae514d7a47$var$rotationCayley[rotationSecond][rotationFirst],\n    /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */ sub: (rotationSecond, rotationFirst)=>$337e48ae514d7a47$var$rotationCayley[rotationSecond][$337e48ae514d7a47$export$b7bb6a2a8d203102.inv(rotationFirst)],\n    /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */ rotate180: (rotation)=>rotation ^ 4,\n    /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */ isVertical: (rotation)=>(rotation & 3) === 2,\n    // rotation % 4 === 2\n    /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */ byDirection: (dx, dy)=>{\n        if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n            if (dy >= 0) return $337e48ae514d7a47$export$b7bb6a2a8d203102.S;\n            return $337e48ae514d7a47$export$b7bb6a2a8d203102.N;\n        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n            if (dx > 0) return $337e48ae514d7a47$export$b7bb6a2a8d203102.E;\n            return $337e48ae514d7a47$export$b7bb6a2a8d203102.W;\n        } else if (dy > 0) {\n            if (dx > 0) return $337e48ae514d7a47$export$b7bb6a2a8d203102.SE;\n            return $337e48ae514d7a47$export$b7bb6a2a8d203102.SW;\n        } else if (dx > 0) return $337e48ae514d7a47$export$b7bb6a2a8d203102.NE;\n        return $337e48ae514d7a47$export$b7bb6a2a8d203102.NW;\n    },\n    /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */ matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0)=>{\n        const mat = $337e48ae514d7a47$var$rotationMatrices[$337e48ae514d7a47$export$b7bb6a2a8d203102.inv(rotation)];\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    }\n};\n\n});\nparcelRegister(\"0kbcf\", function(module, exports) {\n\n$parcel$export(module.exports, \"Matrix\", function () { return $95b114128aa969d0$export$5b12bf1653c0dd85; });\n\nvar $c3fGK = parcelRequire(\"c3fGK\");\n\nvar $hbjPo = parcelRequire(\"hbjPo\");\n\"use strict\";\nclass $95b114128aa969d0$export$5b12bf1653c0dd85 {\n    /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */ constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0){\n        /** An array of the current matrix. Only populated when `toArray` is called */ this.array = null;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n    /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */ fromArray(array) {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n    /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */ set(a, b, c, d, tx, ty) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n        return this;\n    }\n    /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */ toArray(transpose, out) {\n        if (!this.array) this.array = new Float32Array(9);\n        const array = out || this.array;\n        if (transpose) {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        } else {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n        return array;\n    }\n    /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */ apply(pos, newPos) {\n        newPos = newPos || new (0, $hbjPo.Point)();\n        const x = pos.x;\n        const y = pos.y;\n        newPos.x = this.a * x + this.c * y + this.tx;\n        newPos.y = this.b * x + this.d * y + this.ty;\n        return newPos;\n    }\n    /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */ applyInverse(pos, newPos) {\n        newPos = newPos || new (0, $hbjPo.Point)();\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n        const id = 1 / (a * d + c * -b);\n        const x = pos.x;\n        const y = pos.y;\n        newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n        newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n        return newPos;\n    }\n    /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */ translate(x, y) {\n        this.tx += x;\n        this.ty += y;\n        return this;\n    }\n    /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */ scale(x, y) {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n        return this;\n    }\n    /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */ rotate(angle) {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n        this.a = a1 * cos - this.b * sin;\n        this.b = a1 * sin + this.b * cos;\n        this.c = c1 * cos - this.d * sin;\n        this.d = c1 * sin + this.d * cos;\n        this.tx = tx1 * cos - this.ty * sin;\n        this.ty = tx1 * sin + this.ty * cos;\n        return this;\n    }\n    /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */ append(matrix) {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        this.a = matrix.a * a1 + matrix.b * c1;\n        this.b = matrix.a * b1 + matrix.b * d1;\n        this.c = matrix.c * a1 + matrix.d * c1;\n        this.d = matrix.c * b1 + matrix.d * d1;\n        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n        return this;\n    }\n    /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */ appendFrom(a, b) {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n        this.a = a1 * a2 + b1 * c2;\n        this.b = a1 * b2 + b1 * d2;\n        this.c = c1 * a2 + d1 * c2;\n        this.d = c1 * b2 + d1 * d2;\n        this.tx = tx * a2 + ty * c2 + b.tx;\n        this.ty = tx * b2 + ty * d2 + b.ty;\n        return this;\n    }\n    /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */ setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n        this.tx = x - (pivotX * this.a + pivotY * this.c);\n        this.ty = y - (pivotX * this.b + pivotY * this.d);\n        return this;\n    }\n    /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */ prepend(matrix) {\n        const tx1 = this.tx;\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n            const a1 = this.a;\n            const c1 = this.c;\n            this.a = a1 * matrix.a + this.b * matrix.c;\n            this.b = a1 * matrix.b + this.b * matrix.d;\n            this.c = c1 * matrix.a + this.d * matrix.c;\n            this.d = c1 * matrix.b + this.d * matrix.d;\n        }\n        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n        return this;\n    }\n    /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */ decompose(transform) {\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n        const delta = Math.abs(skewX + skewY);\n        if (delta < 1e-5 || Math.abs((0, $c3fGK.PI_2) - delta) < 1e-5) {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        } else {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n        transform.scale.x = Math.sqrt(a * a + b * b);\n        transform.scale.y = Math.sqrt(c * c + d * d);\n        transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n        transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n        return transform;\n    }\n    /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */ invert() {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = a1 * d1 - b1 * c1;\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = (c1 * this.ty - d1 * tx1) / n;\n        this.ty = -(a1 * this.ty - b1 * tx1) / n;\n        return this;\n    }\n    /** Checks if this matrix is an identity matrix */ isIdentity() {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n    /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */ identity() {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n        return this;\n    }\n    /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */ clone() {\n        const matrix = new $95b114128aa969d0$export$5b12bf1653c0dd85();\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    }\n    /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */ copyTo(matrix) {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    }\n    /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */ copyFrom(matrix) {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n        return this;\n    }\n    /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */ equals(matrix) {\n        return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n    toString() {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */ static get IDENTITY() {\n        return $95b114128aa969d0$var$identityMatrix.identity();\n    }\n    /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */ static get shared() {\n        return $95b114128aa969d0$var$tempMatrix.identity();\n    }\n}\nconst $95b114128aa969d0$var$tempMatrix = new $95b114128aa969d0$export$5b12bf1653c0dd85();\nconst $95b114128aa969d0$var$identityMatrix = new $95b114128aa969d0$export$5b12bf1653c0dd85();\n\n});\nparcelRegister(\"c3fGK\", function(module, exports) {\n\n$parcel$export(module.exports, \"PI_2\", function () { return $0e5495c98c03d570$export$59ed0a0a5de1084b; });\n$parcel$export(module.exports, \"RAD_TO_DEG\", function () { return $0e5495c98c03d570$export$3f91627dc85c5d57; });\n$parcel$export(module.exports, \"DEG_TO_RAD\", function () { return $0e5495c98c03d570$export$870617f62e3187f1; });\n\"use strict\";\nconst $0e5495c98c03d570$export$59ed0a0a5de1084b = Math.PI * 2;\nconst $0e5495c98c03d570$export$3f91627dc85c5d57 = 180 / Math.PI;\nconst $0e5495c98c03d570$export$870617f62e3187f1 = Math.PI / 180;\n\n});\n\nparcelRegister(\"hbjPo\", function(module, exports) {\n\n$parcel$export(module.exports, \"Point\", function () { return $55bdd69a4fa64f9d$export$baf26146a414f24a; });\n\"use strict\";\nclass $55bdd69a4fa64f9d$export$baf26146a414f24a {\n    /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */ constructor(x = 0, y = 0){\n        /** Position of the point on the x axis */ this.x = 0;\n        /** Position of the point on the y axis */ this.y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */ clone() {\n        return new $55bdd69a4fa64f9d$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */ copyFrom(p) {\n        this.set(p.x, p.y);\n        return this;\n    }\n    /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */ copyTo(p) {\n        p.set(this.x, this.y);\n        return p;\n    }\n    /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */ equals(p) {\n        return p.x === this.x && p.y === this.y;\n    }\n    /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */ set(x = 0, y = x) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    toString() {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */ static get shared() {\n        $55bdd69a4fa64f9d$var$tempPoint.x = 0;\n        $55bdd69a4fa64f9d$var$tempPoint.y = 0;\n        return $55bdd69a4fa64f9d$var$tempPoint;\n    }\n}\nconst $55bdd69a4fa64f9d$var$tempPoint = new $55bdd69a4fa64f9d$export$baf26146a414f24a();\n\n});\n\n\n\nparcelRegister(\"ec4lc\", function(module, exports) {\n\n$parcel$export(module.exports, \"Rectangle\", function () { return $ce149bca869fe98f$export$4617fb02663045ef; });\n\nvar $hbjPo = parcelRequire(\"hbjPo\");\n\"use strict\";\nconst $ce149bca869fe98f$var$tempPoints = [\n    new (0, $hbjPo.Point)(),\n    new (0, $hbjPo.Point)(),\n    new (0, $hbjPo.Point)(),\n    new (0, $hbjPo.Point)()\n];\nclass $ce149bca869fe98f$export$4617fb02663045ef {\n    /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */ constructor(x = 0, y = 0, width = 0, height = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */ this.type = \"rectangle\";\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n    /** Returns the left edge of the rectangle. */ get left() {\n        return this.x;\n    }\n    /** Returns the right edge of the rectangle. */ get right() {\n        return this.x + this.width;\n    }\n    /** Returns the top edge of the rectangle. */ get top() {\n        return this.y;\n    }\n    /** Returns the bottom edge of the rectangle. */ get bottom() {\n        return this.y + this.height;\n    }\n    /** Determines whether the Rectangle is empty. */ isEmpty() {\n        return this.left === this.right || this.top === this.bottom;\n    }\n    /** A constant empty rectangle. This is a new object every time the property is accessed */ static get EMPTY() {\n        return new $ce149bca869fe98f$export$4617fb02663045ef(0, 0, 0, 0);\n    }\n    /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */ clone() {\n        return new $ce149bca869fe98f$export$4617fb02663045ef(this.x, this.y, this.width, this.height);\n    }\n    /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */ copyFromBounds(bounds) {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n        return this;\n    }\n    /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n        return this;\n    }\n    /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(rectangle) {\n        rectangle.copyFrom(this);\n        return rectangle;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */ contains(x, y) {\n        if (this.width <= 0 || this.height <= 0) return false;\n        if (x >= this.x && x < this.x + this.width) {\n            if (y >= this.y && y < this.y + this.height) return true;\n        }\n        return false;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this rectangle\n   */ strokeContains(x, y, strokeWidth, alignment = 0.5) {\n        const { width: width, height: height } = this;\n        if (width <= 0 || height <= 0) return false;\n        const _x = this.x;\n        const _y = this.y;\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n        const outerLeft = _x - strokeWidthOuter;\n        const outerRight = _x + width + strokeWidthOuter;\n        const outerTop = _y - strokeWidthOuter;\n        const outerBottom = _y + height + strokeWidthOuter;\n        const innerLeft = _x + strokeWidthInner;\n        const innerRight = _x + width - strokeWidthInner;\n        const innerTop = _y + strokeWidthInner;\n        const innerBottom = _y + height - strokeWidthInner;\n        return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */ intersects(other, transform) {\n        if (!transform) {\n            const x02 = this.x < other.x ? other.x : this.x;\n            const x12 = this.right > other.right ? other.right : this.right;\n            if (x12 <= x02) return false;\n            const y02 = this.y < other.y ? other.y : this.y;\n            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n            return y12 > y02;\n        }\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n        if (x1 <= x0 || y1 <= y0) return false;\n        const lt = $ce149bca869fe98f$var$tempPoints[0].set(other.left, other.top);\n        const lb = $ce149bca869fe98f$var$tempPoints[1].set(other.left, other.bottom);\n        const rt = $ce149bca869fe98f$var$tempPoints[2].set(other.right, other.top);\n        const rb = $ce149bca869fe98f$var$tempPoints[3].set(other.right, other.bottom);\n        if (rt.x <= lt.x || lb.y <= lt.y) return false;\n        const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n        if (s === 0) return false;\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) return false;\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = nx * x0 + ny * y0;\n        const n10 = nx * x1 + ny * y0;\n        const n01 = nx * x0 + ny * y1;\n        const n11 = nx * x1 + ny * y1;\n        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) return false;\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = mx * x0 + my * y0;\n        const m10 = mx * x1 + my * y0;\n        const m01 = mx * x0 + my * y1;\n        const m11 = mx * x1 + my * y1;\n        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) return false;\n        return true;\n    }\n    /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */ pad(paddingX = 0, paddingY = paddingX) {\n        this.x -= paddingX;\n        this.y -= paddingY;\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n        return this;\n    }\n    /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */ fit(rectangle) {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n        return this;\n    }\n    /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */ ceil(resolution = 1, eps = 1e-3) {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n        return this;\n    }\n    /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */ enlarge(rectangle) {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n        return this;\n    }\n    /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out || (out = new $ce149bca869fe98f$export$4617fb02663045ef());\n        out.copyFrom(this);\n        return out;\n    }\n    toString() {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n}\n\n});\n\nparcelRegister(\"fTJzX\", function(module, exports) {\n\n$parcel$export(module.exports, \"uid\", function () { return $e72449b3eae4b368$export$e2a22331486dcca0; });\n\"use strict\";\nconst $e72449b3eae4b368$var$uidCache = {\n    default: -1\n};\nfunction $e72449b3eae4b368$export$e2a22331486dcca0(name = \"default\") {\n    if ($e72449b3eae4b368$var$uidCache[name] === void 0) $e72449b3eae4b368$var$uidCache[name] = -1;\n    return ++$e72449b3eae4b368$var$uidCache[name];\n}\nfunction $e72449b3eae4b368$export$220409b686c277d0() {\n    for(const key in $e72449b3eae4b368$var$uidCache)delete $e72449b3eae4b368$var$uidCache[key];\n}\n\n});\n\nparcelRegister(\"aCdt0\", function(module, exports) {\n\n$parcel$export(module.exports, \"v8_0_0\", function () { return $2e9be43e91eceed5$export$dc79da96439604f0; });\n$parcel$export(module.exports, \"v8_3_4\", function () { return $2e9be43e91eceed5$export$e88af00f5d3e8bcc; });\n$parcel$export(module.exports, \"deprecation\", function () { return $2e9be43e91eceed5$export$afd31d834b512e89; });\n\"use strict\";\nconst $2e9be43e91eceed5$var$warnings = {};\nconst $2e9be43e91eceed5$export$dc79da96439604f0 = \"8.0.0\";\nconst $2e9be43e91eceed5$export$e88af00f5d3e8bcc = \"8.3.4\";\nfunction $2e9be43e91eceed5$export$afd31d834b512e89(version, message, ignoreDepth = 3) {\n    if ($2e9be43e91eceed5$var$warnings[message]) return;\n    let stack = new Error().stack;\n    if (typeof stack === \"undefined\") console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n    else {\n        stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n        if (console.groupCollapsed) {\n            console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", `${message}\nDeprecated since v${version}`);\n            console.warn(stack);\n            console.groupEnd();\n        } else {\n            console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n            console.warn(stack);\n        }\n    }\n    $2e9be43e91eceed5$var$warnings[message] = true;\n}\n\n});\n\nparcelRegister(\"87q4u\", function(module, exports) {\n\n$parcel$export(module.exports, \"NOOP\", function () { return $e74451cf129b5abc$export$5702a91a6f42969f; });\n\"use strict\";\nconst $e74451cf129b5abc$export$5702a91a6f42969f = ()=>{};\n\n});\n\nparcelRegister(\"eiaM4\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferImageSource\", function () { return $7a8074626802e18f$export$1872462350fcb7cd; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\"use strict\";\nclass $7a8074626802e18f$export$1872462350fcb7cd extends (0, $3dWsL.TextureSource) {\n    constructor(options){\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n        if (!format) {\n            if (buffer instanceof Float32Array) format = \"rgba32float\";\n            else if (buffer instanceof Int32Array) format = \"rgba32uint\";\n            else if (buffer instanceof Uint32Array) format = \"rgba32uint\";\n            else if (buffer instanceof Int16Array) format = \"rgba16uint\";\n            else if (buffer instanceof Uint16Array) format = \"rgba16uint\";\n            else if (buffer instanceof Int8Array) format = \"bgra8unorm\";\n            else format = \"bgra8unorm\";\n        }\n        super({\n            ...options,\n            resource: buffer,\n            format: format\n        });\n        this.uploadMethodId = \"buffer\";\n    }\n    static test(resource) {\n        return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n    }\n}\n$7a8074626802e18f$export$1872462350fcb7cd.extension = (0, $kFA6i.ExtensionType).TextureSource;\n\n});\nparcelRegister(\"3dWsL\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureSource\", function () { return $3d8d2c0928be477e$export$8498e6a2e655d3d8; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $7qPGY = parcelRequire(\"7qPGY\");\n\nvar $exB5W = parcelRequire(\"exB5W\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $9lBUA = parcelRequire(\"9lBUA\");\n\"use strict\";\nconst $3d8d2c0928be477e$var$_TextureSource = class _TextureSource extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    /**\n   * @param options - options for creating a new TextureSource\n   */ constructor(options = {}){\n        super();\n        this.options = options;\n        /** unique id for this Texture source */ this.uid = (0, $fTJzX.uid)(\"textureSource\");\n        /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */ this._resourceType = \"textureSource\";\n        /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */ this._resourceId = (0, $fTJzX.uid)(\"resource\");\n        /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */ this.uploadMethodId = \"unknown\";\n        // dimensions\n        this._resolution = 1;\n        /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */ this.pixelWidth = 1;\n        /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */ this.pixelHeight = 1;\n        /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */ this.width = 1;\n        /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */ this.height = 1;\n        /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */ this.sampleCount = 1;\n        /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */ this.mipLevelCount = 1;\n        /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */ this.autoGenerateMipmaps = false;\n        /** the format that the texture data has */ this.format = \"rgba8unorm\";\n        /** how many dimensions does this texture have? currently v8 only supports 2d */ this.dimension = \"2d\";\n        /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */ this.antialias = false;\n        /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */ this._touched = 0;\n        /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */ this._batchTick = -1;\n        /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */ this._textureBindLocation = -1;\n        options = {\n            ..._TextureSource.defaultOptions,\n            ...options\n        };\n        this.label = options.label ?? \"\";\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n        if (options.width) this.pixelWidth = options.width * this._resolution;\n        else this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n        if (options.height) this.pixelHeight = options.height * this._resolution;\n        else this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n        this.style = new (0, $9lBUA.TextureStyle)((0, $exB5W.definedProps)(options));\n        this.destroyed = false;\n        this._refreshPOT();\n    }\n    /** returns itself */ get source() {\n        return this;\n    }\n    /** the style of the texture */ get style() {\n        return this._style;\n    }\n    set style(value) {\n        if (this.style === value) return;\n        this._style?.off(\"change\", this._onStyleChange, this);\n        this._style = value;\n        this._style?.on(\"change\", this._onStyleChange, this);\n        this._onStyleChange();\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get addressMode() {\n        return this._style.addressMode;\n    }\n    set addressMode(value) {\n        this._style.addressMode = value;\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get repeatMode() {\n        return this._style.addressMode;\n    }\n    set repeatMode(value) {\n        this._style.addressMode = value;\n    }\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */ get magFilter() {\n        return this._style.magFilter;\n    }\n    set magFilter(value) {\n        this._style.magFilter = value;\n    }\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */ get minFilter() {\n        return this._style.minFilter;\n    }\n    set minFilter(value) {\n        this._style.minFilter = value;\n    }\n    /** Specifies behavior for sampling between mipmap levels. */ get mipmapFilter() {\n        return this._style.mipmapFilter;\n    }\n    set mipmapFilter(value) {\n        this._style.mipmapFilter = value;\n    }\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */ get lodMinClamp() {\n        return this._style.lodMinClamp;\n    }\n    set lodMinClamp(value) {\n        this._style.lodMinClamp = value;\n    }\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */ get lodMaxClamp() {\n        return this._style.lodMaxClamp;\n    }\n    set lodMaxClamp(value) {\n        this._style.lodMaxClamp = value;\n    }\n    _onStyleChange() {\n        this.emit(\"styleChange\", this);\n    }\n    /** call this if you have modified the texture outside of the constructor */ update() {\n        if (this.resource) {\n            const resolution = this._resolution;\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n            if (didResize) return;\n        }\n        this.emit(\"update\", this);\n    }\n    /** Destroys this texture source */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.emit(\"change\", this);\n        if (this._style) {\n            this._style.destroy();\n            this._style = null;\n        }\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n    /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */ unload() {\n        this._resourceId = (0, $fTJzX.uid)(\"resource\");\n        this.emit(\"change\", this);\n        this.emit(\"unload\", this);\n    }\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */ get resourceWidth() {\n        const { resource: resource } = this;\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */ get resourceHeight() {\n        const { resource: resource } = this;\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n    /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */ get resolution() {\n        return this._resolution;\n    }\n    set resolution(resolution) {\n        if (this._resolution === resolution) return;\n        this._resolution = resolution;\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n    /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */ resize(width, height, resolution) {\n        resolution || (resolution = this._resolution);\n        width || (width = this.width);\n        height || (height = this.height);\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n        this._resolution = resolution;\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) return false;\n        this._refreshPOT();\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n        this.emit(\"resize\", this);\n        this._resourceId = (0, $fTJzX.uid)(\"resource\");\n        this.emit(\"change\", this);\n        return true;\n    }\n    /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */ updateMipmaps() {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1) this.emit(\"updateMipmaps\", this);\n    }\n    set wrapMode(value) {\n        this._style.wrapMode = value;\n    }\n    get wrapMode() {\n        return this._style.wrapMode;\n    }\n    set scaleMode(value) {\n        this._style.scaleMode = value;\n    }\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */ get scaleMode() {\n        return this._style.scaleMode;\n    }\n    /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */ _refreshPOT() {\n        this.isPowerOfTwo = (0, $7qPGY.isPow2)(this.pixelWidth) && (0, $7qPGY.isPow2)(this.pixelHeight);\n    }\n    static test(_resource) {\n        throw new Error(\"Unimplemented\");\n    }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */ $3d8d2c0928be477e$var$_TextureSource.defaultOptions = {\n    resolution: 1,\n    format: \"bgra8unorm\",\n    alphaMode: \"premultiply-alpha-on-upload\",\n    dimensions: \"2d\",\n    mipLevelCount: 1,\n    autoGenerateMipmaps: false,\n    sampleCount: 1,\n    antialias: false,\n    autoGarbageCollect: false\n};\nlet $3d8d2c0928be477e$export$8498e6a2e655d3d8 = $3d8d2c0928be477e$var$_TextureSource;\n\n});\nparcelRegister(\"7qPGY\", function(module, exports) {\n\n$parcel$export(module.exports, \"nextPow2\", function () { return $986fb9110aa90cb3$export$f0d90cf68bd426eb; });\n$parcel$export(module.exports, \"isPow2\", function () { return $986fb9110aa90cb3$export$eb50b9c078eb6ae7; });\n\"use strict\";\nfunction $986fb9110aa90cb3$export$f0d90cf68bd426eb(v) {\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n    return v + 1;\n}\nfunction $986fb9110aa90cb3$export$eb50b9c078eb6ae7(v) {\n    return !(v & v - 1) && !!v;\n}\nfunction $986fb9110aa90cb3$export$b9fae0bba9d9094d(v) {\n    let r = (v > 65535 ? 1 : 0) << 4;\n    v >>>= r;\n    let shift = (v > 255 ? 1 : 0) << 3;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 15 ? 1 : 0) << 2;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 3 ? 1 : 0) << 1;\n    v >>>= shift;\n    r |= shift;\n    return r | v >> 1;\n}\n\n});\n\nparcelRegister(\"exB5W\", function(module, exports) {\n\n$parcel$export(module.exports, \"definedProps\", function () { return $b011cb4bb21573b4$export$801feaffb936a09d; });\n\"use strict\";\nfunction $b011cb4bb21573b4$export$801feaffb936a09d(obj) {\n    const result = {};\n    for(const key in obj)if (obj[key] !== void 0) result[key] = obj[key];\n    return result;\n}\n\n});\n\nparcelRegister(\"9lBUA\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureStyle\", function () { return $90a34299e1fe538e$export$1ce1d0c10d3de5d5; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\"use strict\";\nconst $90a34299e1fe538e$var$idHash = /* @__PURE__ */ Object.create(null);\nfunction $90a34299e1fe538e$var$createResourceIdFromString(value) {\n    const id = $90a34299e1fe538e$var$idHash[value];\n    if (id === void 0) $90a34299e1fe538e$var$idHash[value] = (0, $fTJzX.uid)(\"resource\");\n    return id;\n}\nconst $90a34299e1fe538e$var$_TextureStyle = class _TextureStyle extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    /**\n   * @param options - options for the style\n   */ constructor(options = {}){\n        super();\n        this._resourceType = \"textureSampler\";\n        this._touched = 0;\n        /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */ this._maxAnisotropy = 1;\n        /**\n     * Has the style been destroyed?\n     * @readonly\n     */ this.destroyed = false;\n        options = {\n            ..._TextureStyle.defaultOptions,\n            ...options\n        };\n        this.addressMode = options.addressMode;\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n        this.scaleMode = options.scaleMode;\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n        this.compare = options.compare;\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n    set addressMode(value) {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get addressMode() {\n        return this.addressModeU;\n    }\n    set wrapMode(value) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n        this.addressMode = value;\n    }\n    get wrapMode() {\n        return this.addressMode;\n    }\n    set scaleMode(value) {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */ get scaleMode() {\n        return this.magFilter;\n    }\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */ set maxAnisotropy(value) {\n        this._maxAnisotropy = Math.min(value, 16);\n        if (this._maxAnisotropy > 1) this.scaleMode = \"linear\";\n    }\n    get maxAnisotropy() {\n        return this._maxAnisotropy;\n    }\n    // TODO - move this to WebGL?\n    get _resourceId() {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n    update() {\n        this.emit(\"change\", this);\n        this._sharedResourceId = null;\n    }\n    _generateResourceId() {\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n        this._sharedResourceId = $90a34299e1fe538e$var$createResourceIdFromString(bigKey);\n        return this._resourceId;\n    }\n    /** Destroys the style */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.emit(\"change\", this);\n        this.removeAllListeners();\n    }\n};\n/** default options for the style */ $90a34299e1fe538e$var$_TextureStyle.defaultOptions = {\n    addressMode: \"clamp-to-edge\",\n    scaleMode: \"linear\"\n};\nlet $90a34299e1fe538e$export$1ce1d0c10d3de5d5 = $90a34299e1fe538e$var$_TextureStyle;\n\n});\n\n\n\nparcelRegister(\"aDwba\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureMatrix\", function () { return $57b4ac32d55b0fe4$export$dbea3135e9da48cb; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\"use strict\";\nconst $57b4ac32d55b0fe4$var$tempMat = new (0, $0kbcf.Matrix)();\nclass $57b4ac32d55b0fe4$export$dbea3135e9da48cb {\n    /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */ constructor(texture, clampMargin){\n        this.mapCoord = new (0, $0kbcf.Matrix)();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n        this.clampOffset = 0;\n        if (typeof clampMargin === \"undefined\") this.clampMargin = texture.width < 10 ? 0 : 0.5;\n        else this.clampMargin = clampMargin;\n        this.isSimple = false;\n        this.texture = texture;\n    }\n    /** Texture property. */ get texture() {\n        return this._texture;\n    }\n    set texture(value) {\n        if (this.texture === value) return;\n        this._texture?.removeListener(\"update\", this.update, this);\n        this._texture = value;\n        this._texture.addListener(\"update\", this.update, this);\n        this.update();\n    }\n    /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */ multiplyUvs(uvs, out) {\n        if (out === void 0) out = uvs;\n        const mat = this.mapCoord;\n        for(let i = 0; i < uvs.length; i += 2){\n            const x = uvs[i];\n            const y = uvs[i + 1];\n            out[i] = x * mat.a + y * mat.c + mat.tx;\n            out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n        }\n        return out;\n    }\n    /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */ update() {\n        const tex = this._texture;\n        this._updateID++;\n        const uvs = tex.uvs;\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n        const orig = tex.orig;\n        const trim = tex.trim;\n        if (trim) {\n            $57b4ac32d55b0fe4$var$tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);\n            this.mapCoord.append($57b4ac32d55b0fe4$var$tempMat);\n        }\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset / texBase._resolution;\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n        this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n        return true;\n    }\n}\n\n});\n\n\nparcelRegister(\"04UFt\", function(module, exports) {\n\n$parcel$export(module.exports, \"updateQuadBounds\", function () { return $4941c1f3fc750b3e$export$558ce66aa5723f1d; });\n\"use strict\";\nfunction $4941c1f3fc750b3e$export$558ce66aa5723f1d(bounds, anchor, texture) {\n    const { width: width, height: height } = texture.orig;\n    const trim = texture.trim;\n    if (trim) {\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n        bounds.minX = trim.x - anchor._x * width;\n        bounds.maxX = bounds.minX + sourceWidth;\n        bounds.minY = trim.y - anchor._y * height;\n        bounds.maxY = bounds.minY + sourceHeight;\n    } else {\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n\n});\n\nparcelRegister(\"4ndcs\", function(module, exports) {\n\n$parcel$export(module.exports, \"ViewContainer\", function () { return $41020eb0c9bcc845$export$19fb617b96998849; });\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\n\"use strict\";\nclass $41020eb0c9bcc845$export$19fb617b96998849 extends (0, $gRXu9.Container) {\n    constructor(){\n        super(...arguments);\n        /** @private */ this.canBundle = true;\n        /** @private */ this.allowChildren = false;\n        /** @private */ this._roundPixels = 0;\n        /** @private */ this._lastUsed = -1;\n        this._bounds = new (0, $dtW0p.Bounds)(0, 1, 0, 0);\n        this._boundsDirty = true;\n    }\n    /**\n   * The local bounds of the view.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        if (!this._boundsDirty) return this._bounds;\n        this.updateBounds();\n        this._boundsDirty = false;\n        return this._bounds;\n    }\n    /**\n   * Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    set roundPixels(value) {\n        this._roundPixels = value ? 1 : 0;\n    }\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        const bounds = this.bounds;\n        const { x: x, y: y } = point;\n        return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;\n    }\n    /** @private */ onViewUpdate() {\n        this._didViewChangeTick++;\n        this._boundsDirty = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.onChildViewUpdate(this);\n    }\n    destroy(options) {\n        super.destroy(options);\n        this._bounds = null;\n    }\n    collectRenderablesSimple(instructionSet, renderer, currentLayer) {\n        const { renderPipes: renderPipes, renderableGC: renderableGC } = renderer;\n        renderPipes.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);\n        const rp = renderPipes;\n        rp[this.renderPipeId].addRenderable(this, instructionSet);\n        renderableGC.addRenderable(this);\n        this.didViewUpdate = false;\n        const children = this.children;\n        const length = children.length;\n        for(let i = 0; i < length; i++)children[i].collectRenderables(instructionSet, renderer, currentLayer);\n    }\n}\n\n});\nparcelRegister(\"dtW0p\", function(module, exports) {\n\n$parcel$export(module.exports, \"Bounds\", function () { return $65a637ce5da3d941$export$c4e9d269599ab4b4; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\"use strict\";\nconst $65a637ce5da3d941$var$defaultMatrix = new (0, $0kbcf.Matrix)();\nclass $65a637ce5da3d941$export$c4e9d269599ab4b4 {\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity){\n        /** @default Infinity */ this.minX = Infinity;\n        /** @default Infinity */ this.minY = Infinity;\n        /** @default -Infinity */ this.maxX = -Infinity;\n        /** @default -Infinity */ this.maxY = -Infinity;\n        this.matrix = $65a637ce5da3d941$var$defaultMatrix;\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */ isEmpty() {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n    /** The bounding rectangle of the bounds. */ get rectangle() {\n        if (!this._rectangle) this._rectangle = new (0, $ec4lc.Rectangle)();\n        const rectangle = this._rectangle;\n        if (this.minX > this.maxX || this.minY > this.maxY) {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        } else rectangle.copyFromBounds(this);\n        return rectangle;\n    }\n    /** Clears the bounds and resets. */ clear() {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n        this.matrix = $65a637ce5da3d941$var$defaultMatrix;\n        return this;\n    }\n    /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */ set(x0, y0, x1, y1) {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n    /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */ addFrame(x0, y0, x1, y1, matrix) {\n        matrix || (matrix = this.matrix);\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        let x = a * x0 + c * y0 + tx;\n        let y = b * x0 + d * y0 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x1 + c * y0 + tx;\n        y = b * x1 + d * y0 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x0 + c * y1 + tx;\n        y = b * x0 + d * y1 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x1 + c * y1 + tx;\n        y = b * x1 + d * y1 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */ addRect(rect, matrix) {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n    /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */ addBounds(bounds, matrix) {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n    /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */ addBoundsMask(mask) {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n    /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */ applyMatrix(matrix) {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n        const { a: a, b: b, c: c, d: d, tx: tx, ty: ty } = matrix;\n        let x = a * minX + c * minY + tx;\n        let y = b * minX + d * minY + ty;\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n        x = a * maxX + c * minY + tx;\n        y = b * maxX + d * minY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n        x = a * minX + c * maxY + tx;\n        y = b * minX + d * maxY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n        x = a * maxX + c * maxY + tx;\n        y = b * maxX + d * maxY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n    /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */ fit(rect) {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n        return this;\n    }\n    /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */ fitBounds(left, right, top, bottom) {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n        return this;\n    }\n    /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */ pad(paddingX, paddingY = paddingX) {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n        return this;\n    }\n    /** Ceils the bounds. */ ceil() {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n        return this;\n    }\n    /** Clones the bounds. */ clone() {\n        return new $65a637ce5da3d941$export$c4e9d269599ab4b4(this.minX, this.minY, this.maxX, this.maxY);\n    }\n    /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */ scale(x, y = x) {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n        return this;\n    }\n    /** the x value of the bounds. */ get x() {\n        return this.minX;\n    }\n    set x(value) {\n        const width = this.maxX - this.minX;\n        this.minX = value;\n        this.maxX = value + width;\n    }\n    /** the y value of the bounds. */ get y() {\n        return this.minY;\n    }\n    set y(value) {\n        const height = this.maxY - this.minY;\n        this.minY = value;\n        this.maxY = value + height;\n    }\n    /** the width value of the bounds. */ get width() {\n        return this.maxX - this.minX;\n    }\n    set width(value) {\n        this.maxX = this.minX + value;\n    }\n    /** the height value of the bounds. */ get height() {\n        return this.maxY - this.minY;\n    }\n    set height(value) {\n        this.maxY = this.minY + value;\n    }\n    /** the left value of the bounds. */ get left() {\n        return this.minX;\n    }\n    /** the right value of the bounds. */ get right() {\n        return this.maxX;\n    }\n    /** the top value of the bounds. */ get top() {\n        return this.minY;\n    }\n    /** the bottom value of the bounds. */ get bottom() {\n        return this.maxY;\n    }\n    /** Is the bounds positive. */ get isPositive() {\n        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n    }\n    get isValid() {\n        return this.minX + this.minY !== Infinity;\n    }\n    /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */ addVertexData(vertexData, beginOffset, endOffset, matrix) {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        matrix || (matrix = this.matrix);\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        for(let i = beginOffset; i < endOffset; i += 2){\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n            const x = a * localX + c * localY + tx;\n            const y = b * localX + d * localY + ty;\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */ containsPoint(x, y) {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) return true;\n        return false;\n    }\n    toString() {\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n    /**\n   * Copies the bounds from another bounds object.\n   * @param bounds - The bounds to copy from.\n   * @returns - This bounds object.\n   */ copyFrom(bounds) {\n        this.minX = bounds.minX;\n        this.minY = bounds.minY;\n        this.maxX = bounds.maxX;\n        this.maxY = bounds.maxY;\n        return this;\n    }\n}\n\n});\n\nparcelRegister(\"gRXu9\", function(module, exports) {\n\n$parcel$export(module.exports, \"UPDATE_COLOR\", function () { return $2dde9d72d383d3dd$export$f8ede8d8bf091ab5; });\n$parcel$export(module.exports, \"UPDATE_BLEND\", function () { return $2dde9d72d383d3dd$export$e4801e7edc7582f; });\n$parcel$export(module.exports, \"UPDATE_VISIBLE\", function () { return $2dde9d72d383d3dd$export$83db162b74637ea; });\n$parcel$export(module.exports, \"Container\", function () { return $2dde9d72d383d3dd$export$42a852a2b6b56249; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $7tfc3 = parcelRequire(\"7tfc3\");\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $c3fGK = parcelRequire(\"c3fGK\");\n\nvar $dq7e0 = parcelRequire(\"dq7e0\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $dLv5L = parcelRequire(\"dLv5L\");\n\nvar $eURp4 = parcelRequire(\"eURp4\");\n\nvar $5XZI5 = parcelRequire(\"5XZI5\");\n\nvar $8aDma = parcelRequire(\"8aDma\");\n\nvar $fWc5r = parcelRequire(\"fWc5r\");\n\nvar $ggihy = parcelRequire(\"ggihy\");\n\nvar $6OcmO = parcelRequire(\"6OcmO\");\n\nvar $h3CH0 = parcelRequire(\"h3CH0\");\n\nvar $cVzTv = parcelRequire(\"cVzTv\");\n\nvar $b7mtY = parcelRequire(\"b7mtY\");\n\nvar $b2N3G = parcelRequire(\"b2N3G\");\n\nvar $knQy3 = parcelRequire(\"knQy3\");\n\nvar $2WbnL = parcelRequire(\"2WbnL\");\n\nvar $eSqzB = parcelRequire(\"eSqzB\");\n\"use strict\";\nconst $2dde9d72d383d3dd$var$defaultSkew = new (0, $dq7e0.ObservablePoint)(null);\nconst $2dde9d72d383d3dd$var$defaultPivot = new (0, $dq7e0.ObservablePoint)(null);\nconst $2dde9d72d383d3dd$var$defaultScale = new (0, $dq7e0.ObservablePoint)(null, 1, 1);\nconst $2dde9d72d383d3dd$export$f8ede8d8bf091ab5 = 1;\nconst $2dde9d72d383d3dd$export$e4801e7edc7582f = 2;\nconst $2dde9d72d383d3dd$export$83db162b74637ea = 4;\nconst $2dde9d72d383d3dd$export$8363b5079568fbee = 8;\nclass $2dde9d72d383d3dd$export$42a852a2b6b56249 extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    constructor(options = {}){\n        super();\n        /** unique id for this container */ this.uid = (0, $fTJzX.uid)(\"renderable\");\n        /** @private */ this._updateFlags = 15;\n        // the render group this container owns\n        /** @private */ this.renderGroup = null;\n        // the render group this container belongs to\n        /** @private */ this.parentRenderGroup = null;\n        // the index of the container in the render group\n        /** @private */ this.parentRenderGroupIndex = 0;\n        // set to true if the container has changed. It is reset once the changes have been applied\n        // by the transform system\n        // its here to stop ensure that when things change, only one update gets registers with the transform system\n        /** @private */ this.didChange = false;\n        // same as above, but for the renderable\n        /** @private */ this.didViewUpdate = false;\n        // how deep is the container relative to its render group..\n        // unless the element is the root render group - it will be relative to its parent\n        /** @private */ this.relativeRenderGroupDepth = 0;\n        /**\n     * The array of children of this container.\n     * @readonly\n     */ this.children = [];\n        /** The display object container that contains this display object. */ this.parent = null;\n        // used internally for changing up the render order.. mainly for masks and filters\n        // TODO setting this should cause a rebuild??\n        /** @private */ this.includeInBuild = true;\n        /** @private */ this.measurable = true;\n        /** @private */ this.isSimple = true;\n        // / /////////////Transform related props//////////////\n        // used by the transform system to check if a container needs to be updated that frame\n        // if the tick matches the current transform system tick, it is not updated again\n        /**\n     * @internal\n     * @ignore\n     */ this.updateTick = -1;\n        /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */ this.localTransform = new (0, $0kbcf.Matrix)();\n        /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */ this.relativeGroupTransform = new (0, $0kbcf.Matrix)();\n        /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */ this.groupTransform = this.relativeGroupTransform;\n        /** If the object has been destroyed via destroy(). If true, it should not be used. */ this.destroyed = false;\n        // transform data..\n        /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */ this._position = new (0, $dq7e0.ObservablePoint)(this, 0, 0);\n        /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */ this._scale = $2dde9d72d383d3dd$var$defaultScale;\n        /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */ this._pivot = $2dde9d72d383d3dd$var$defaultPivot;\n        /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */ this._skew = $2dde9d72d383d3dd$var$defaultSkew;\n        /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._cx = 1;\n        /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._sx = 0;\n        /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._cy = 0;\n        /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._sy = 1;\n        /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */ this._rotation = 0;\n        // / COLOR related props //////////////\n        // color stored as ABGR\n        this.localColor = 16777215;\n        this.localAlpha = 1;\n        this.groupAlpha = 1;\n        // A\n        this.groupColor = 16777215;\n        // BGR\n        this.groupColorAlpha = 4294967295;\n        // ABGR\n        // / BLEND related props //////////////\n        /**\n     * @internal\n     * @ignore\n     */ this.localBlendMode = \"inherit\";\n        /**\n     * @internal\n     * @ignore\n     */ this.groupBlendMode = \"normal\";\n        // / VISIBILITY related props //////////////\n        // visibility\n        // 0b11\n        // first bit is visible, second bit is renderable\n        /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */ this.localDisplayStatus = 7;\n        // 0b11 | 0b10 | 0b01 | 0b00\n        /**\n     * @internal\n     * @ignore\n     */ this.globalDisplayStatus = 7;\n        /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */ this._didContainerChangeTick = 0;\n        /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */ this._didViewChangeTick = 0;\n        /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */ this._didLocalTransformChangeId = -1;\n        this.effects = [];\n        (0, $eSqzB.assignWithIgnore)(this, options, {\n            children: true,\n            parent: true,\n            effects: true\n        });\n        options.children?.forEach((child)=>this.addChild(child));\n        options.parent?.addChild(this);\n    }\n    /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */ static mixin(source) {\n        Object.defineProperties($2dde9d72d383d3dd$export$42a852a2b6b56249.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n    // = 'default';\n    /**\n   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n   * @deprecated since 8.2.6\n   * @ignore\n   */ set _didChangeId(value) {\n        this._didViewChangeTick = value >> 12 & 4095;\n        this._didContainerChangeTick = value & 4095;\n    }\n    get _didChangeId() {\n        return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;\n    }\n    /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */ addChild(...children) {\n        if (!this.allowChildren) (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n        if (children.length > 1) {\n            for(let i = 0; i < children.length; i++)this.addChild(children[i]);\n            return children[0];\n        }\n        const child = children[0];\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (child.parent === this) {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n            if (renderGroup) renderGroup.structureDidChange = true;\n            return child;\n        }\n        if (child.parent) child.parent.removeChild(child);\n        this.children.push(child);\n        if (this.sortableChildren) this.sortDirty = true;\n        child.parent = this;\n        child.didChange = true;\n        child._updateFlags = 15;\n        if (renderGroup) renderGroup.addChild(child);\n        this.emit(\"childAdded\", child, this, this.children.length - 1);\n        child.emit(\"added\", this);\n        this._didViewChangeTick++;\n        if (child._zIndex !== 0) child.depthOfChildModified();\n        return child;\n    }\n    /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */ removeChild(...children) {\n        if (children.length > 1) {\n            for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n            return children[0];\n        }\n        const child = children[0];\n        const index = this.children.indexOf(child);\n        if (index > -1) {\n            this._didViewChangeTick++;\n            this.children.splice(index, 1);\n            if (this.renderGroup) this.renderGroup.removeChild(child);\n            else if (this.parentRenderGroup) this.parentRenderGroup.removeChild(child);\n            if (child.parentRenderLayer) child.parentRenderLayer.detach(child);\n            child.parent = null;\n            this.emit(\"childRemoved\", child, this, index);\n            child.emit(\"removed\", this);\n        }\n        return child;\n    }\n    /** @ignore */ _onUpdate(point) {\n        if (point) {\n            if (point === this._skew) this._updateSkew();\n        }\n        this._didContainerChangeTick++;\n        if (this.didChange) return;\n        this.didChange = true;\n        if (this.parentRenderGroup) this.parentRenderGroup.onChildUpdate(this);\n    }\n    set isRenderGroup(value) {\n        if (!!this.renderGroup === value) return;\n        if (value) this.enableRenderGroup();\n        else this.disableRenderGroup();\n    }\n    /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */ get isRenderGroup() {\n        return !!this.renderGroup;\n    }\n    /**\n   * Calling this enables a render group for this container.\n   * This means it will be rendered as a separate set of instructions.\n   * The transform of the container will also be handled on the GPU rather than the CPU.\n   */ enableRenderGroup() {\n        if (this.renderGroup) return;\n        const parentRenderGroup = this.parentRenderGroup;\n        parentRenderGroup?.removeChild(this);\n        this.renderGroup = (0, $dLv5L.BigPool).get((0, $2WbnL.RenderGroup), this);\n        this.groupTransform = (0, $0kbcf.Matrix).IDENTITY;\n        parentRenderGroup?.addChild(this);\n        this._updateIsSimple();\n    }\n    /** This will disable the render group for this container. */ disableRenderGroup() {\n        if (!this.renderGroup) return;\n        const parentRenderGroup = this.parentRenderGroup;\n        parentRenderGroup?.removeChild(this);\n        (0, $dLv5L.BigPool).return(this.renderGroup);\n        this.renderGroup = null;\n        this.groupTransform = this.relativeGroupTransform;\n        parentRenderGroup?.addChild(this);\n        this._updateIsSimple();\n    }\n    /** @ignore */ _updateIsSimple() {\n        this.isSimple = !this.renderGroup && this.effects.length === 0;\n    }\n    /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */ get worldTransform() {\n        this._worldTransform || (this._worldTransform = new (0, $0kbcf.Matrix)());\n        if (this.renderGroup) this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n        else if (this.parentRenderGroup) this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n        return this._worldTransform;\n    }\n    /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */ get x() {\n        return this._position.x;\n    }\n    set x(value) {\n        this._position.x = value;\n    }\n    /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */ get y() {\n        return this._position.y;\n    }\n    set y(value) {\n        this._position.y = value;\n    }\n    /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */ get position() {\n        return this._position;\n    }\n    set position(value) {\n        this._position.copyFrom(value);\n    }\n    /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */ get rotation() {\n        return this._rotation;\n    }\n    set rotation(value) {\n        if (this._rotation !== value) {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n    /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */ get angle() {\n        return this.rotation * (0, $c3fGK.RAD_TO_DEG);\n    }\n    set angle(value) {\n        this.rotation = value * (0, $c3fGK.DEG_TO_RAD);\n    }\n    /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */ get pivot() {\n        if (this._pivot === $2dde9d72d383d3dd$var$defaultPivot) this._pivot = new (0, $dq7e0.ObservablePoint)(this, 0, 0);\n        return this._pivot;\n    }\n    set pivot(value) {\n        if (this._pivot === $2dde9d72d383d3dd$var$defaultPivot) this._pivot = new (0, $dq7e0.ObservablePoint)(this, 0, 0);\n        typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n    /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */ get skew() {\n        if (this._skew === $2dde9d72d383d3dd$var$defaultSkew) this._skew = new (0, $dq7e0.ObservablePoint)(this, 0, 0);\n        return this._skew;\n    }\n    set skew(value) {\n        if (this._skew === $2dde9d72d383d3dd$var$defaultSkew) this._skew = new (0, $dq7e0.ObservablePoint)(this, 0, 0);\n        this._skew.copyFrom(value);\n    }\n    /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */ get scale() {\n        if (this._scale === $2dde9d72d383d3dd$var$defaultScale) this._scale = new (0, $dq7e0.ObservablePoint)(this, 1, 1);\n        return this._scale;\n    }\n    set scale(value) {\n        if (this._scale === $2dde9d72d383d3dd$var$defaultScale) this._scale = new (0, $dq7e0.ObservablePoint)(this, 0, 0);\n        typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n    /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */ get width() {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n    set width(value) {\n        const localWidth = this.getLocalBounds().width;\n        this._setWidth(value, localWidth);\n    }\n    /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */ get height() {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n    set height(value) {\n        const localHeight = this.getLocalBounds().height;\n        this._setHeight(value, localHeight);\n    }\n    /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */ getSize(out) {\n        if (!out) out = {};\n        const bounds = this.getLocalBounds();\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n        return out;\n    }\n    /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */ setSize(value, height) {\n        const size = this.getLocalBounds();\n        if (typeof value === \"object\") {\n            height = value.height ?? value.width;\n            value = value.width;\n        } else height ?? (height = value);\n        value !== void 0 && this._setWidth(value, size.width);\n        height !== void 0 && this._setHeight(height, size.height);\n    }\n    /** Called when the skew or the rotation changes. */ _updateSkew() {\n        const rotation = this._rotation;\n        const skew = this._skew;\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x);\n        this._sy = Math.cos(rotation - skew._x);\n    }\n    /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */ updateTransform(opts) {\n        this.position.set(typeof opts.x === \"number\" ? opts.x : this.position.x, typeof opts.y === \"number\" ? opts.y : this.position.y);\n        this.scale.set(typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x, typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y);\n        this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n        this.skew.set(typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x, typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y);\n        this.pivot.set(typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x, typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y);\n        return this;\n    }\n    /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */ setFromMatrix(matrix) {\n        matrix.decompose(this);\n    }\n    /** Updates the local transform. */ updateLocalTransform() {\n        const localTransformChangeId = this._didContainerChangeTick;\n        if (this._didLocalTransformChangeId === localTransformChangeId) return;\n        this._didLocalTransformChangeId = localTransformChangeId;\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n        const sx = scale._x;\n        const sy = scale._y;\n        const px = pivot._x;\n        const py = pivot._y;\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n        lt.tx = position._x - (px * lt.a + py * lt.c);\n        lt.ty = position._y - (px * lt.b + py * lt.d);\n    }\n    // / ///// color related stuff\n    set alpha(value) {\n        if (value === this.localAlpha) return;\n        this.localAlpha = value;\n        this._updateFlags |= $2dde9d72d383d3dd$export$f8ede8d8bf091ab5;\n        this._onUpdate();\n    }\n    /** The opacity of the object. */ get alpha() {\n        return this.localAlpha;\n    }\n    set tint(value) {\n        const tempColor = (0, $hFslp.Color).shared.setValue(value ?? 16777215);\n        const bgr = tempColor.toBgrNumber();\n        if (bgr === this.localColor) return;\n        this.localColor = bgr;\n        this._updateFlags |= $2dde9d72d383d3dd$export$f8ede8d8bf091ab5;\n        this._onUpdate();\n    }\n    /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */ get tint() {\n        return (0, $h3CH0.bgr2rgb)(this.localColor);\n    }\n    // / //////////////// blend related stuff\n    set blendMode(value) {\n        if (this.localBlendMode === value) return;\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n        this._updateFlags |= $2dde9d72d383d3dd$export$e4801e7edc7582f;\n        this.localBlendMode = value;\n        this._onUpdate();\n    }\n    /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */ get blendMode() {\n        return this.localBlendMode;\n    }\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */ get visible() {\n        return !!(this.localDisplayStatus & 2);\n    }\n    set visible(value) {\n        const valueNumber = value ? 2 : 0;\n        if ((this.localDisplayStatus & 2) === valueNumber) return;\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n        this._updateFlags |= $2dde9d72d383d3dd$export$83db162b74637ea;\n        this.localDisplayStatus ^= 2;\n        this._onUpdate();\n    }\n    /** @ignore */ get culled() {\n        return !(this.localDisplayStatus & 4);\n    }\n    /** @ignore */ set culled(value) {\n        const valueNumber = value ? 0 : 4;\n        if ((this.localDisplayStatus & 4) === valueNumber) return;\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n        this._updateFlags |= $2dde9d72d383d3dd$export$83db162b74637ea;\n        this.localDisplayStatus ^= 4;\n        this._onUpdate();\n    }\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */ get renderable() {\n        return !!(this.localDisplayStatus & 1);\n    }\n    set renderable(value) {\n        const valueNumber = value ? 1 : 0;\n        if ((this.localDisplayStatus & 1) === valueNumber) return;\n        this._updateFlags |= $2dde9d72d383d3dd$export$83db162b74637ea;\n        this.localDisplayStatus ^= 1;\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n        this._onUpdate();\n    }\n    /** Whether or not the object should be rendered. */ get isRenderable() {\n        return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n    }\n    /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */ destroy(options = false) {\n        if (this.destroyed) return;\n        this.destroyed = true;\n        let oldChildren;\n        if (this.children.length) oldChildren = this.removeChildren(0, this.children.length);\n        this.removeFromParent();\n        this.parent = null;\n        this._maskEffect = null;\n        this._filterEffect = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n        this.emit(\"destroyed\", this);\n        this.removeAllListeners();\n        const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n        if (destroyChildren && oldChildren) for(let i = 0; i < oldChildren.length; ++i)oldChildren[i].destroy(options);\n        this.renderGroup?.destroy();\n        this.renderGroup = null;\n    }\n}\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $5XZI5.childrenHelperMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $6OcmO.getFastGlobalBoundsMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $knQy3.toLocalGlobalMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $b7mtY.onRenderMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $cVzTv.measureMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $fWc5r.effectsMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $ggihy.findMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $b2N3G.sortMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $7tfc3.cullingMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $eURp4.cacheAsTextureMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $h3CH0.getGlobalMixin));\n$2dde9d72d383d3dd$export$42a852a2b6b56249.mixin((0, $8aDma.collectRenderablesMixin));\n\n});\nparcelRegister(\"hFslp\", function(module, exports) {\n\n$parcel$export(module.exports, \"Color\", function () { return $ce14d1440ee922b4$export$892596cec99bc70e; });\n\nvar $hgnOi = parcelRequire(\"hgnOi\");\n\nvar $40ez6 = parcelRequire(\"40ez6\");\n\"use strict\";\n(0, $hgnOi.extend)([\n    (0, $40ez6.default)\n]);\nconst $ce14d1440ee922b4$var$_Color = class _Color {\n    /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */ constructor(value = 16777215){\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 16777215;\n        this.value = value;\n    }\n    /** Get red component (0 - 1) */ get red() {\n        return this._components[0];\n    }\n    /** Get green component (0 - 1) */ get green() {\n        return this._components[1];\n    }\n    /** Get blue component (0 - 1) */ get blue() {\n        return this._components[2];\n    }\n    /** Get alpha component (0 - 1) */ get alpha() {\n        return this._components[3];\n    }\n    /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */ setValue(value) {\n        this.value = value;\n        return this;\n    }\n    /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */ set value(value) {\n        if (value instanceof _Color) {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        } else if (value === null) throw new Error(\"Cannot set Color#value to null\");\n        else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n            this._value = this._cloneSource(value);\n            this._normalize(this._value);\n        }\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */ _cloneSource(value) {\n        if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) return value;\n        else if (Array.isArray(value) || ArrayBuffer.isView(value)) return value.slice(0);\n        else if (typeof value === \"object\" && value !== null) return {\n            ...value\n        };\n        return value;\n    }\n    /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */ _isSourceEqual(value1, value2) {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n        if (type1 !== type2) return false;\n        else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) return value1 === value2;\n        else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n            if (value1.length !== value2.length) return false;\n            return value1.every((v, i)=>v === value2[i]);\n        } else if (value1 !== null && value2 !== null) {\n            const keys1 = Object.keys(value1);\n            const keys2 = Object.keys(value2);\n            if (keys1.length !== keys2.length) return false;\n            return keys1.every((key)=>value1[key] === value2[key]);\n        }\n        return value1 === value2;\n    }\n    /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */ toRgba() {\n        const [r, g, b, a] = this._components;\n        return {\n            r: r,\n            g: g,\n            b: b,\n            a: a\n        };\n    }\n    /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */ toRgb() {\n        const [r, g, b] = this._components;\n        return {\n            r: r,\n            g: g,\n            b: b\n        };\n    }\n    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */ toRgbaString() {\n        const [r, g, b] = this.toUint8RgbArray();\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n    toUint8RgbArray(out) {\n        const [r, g, b] = this._components;\n        if (!this._arrayRgb) this._arrayRgb = [];\n        out || (out = this._arrayRgb);\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n        return out;\n    }\n    toArray(out) {\n        if (!this._arrayRgba) this._arrayRgba = [];\n        out || (out = this._arrayRgba);\n        const [r, g, b, a] = this._components;\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n        return out;\n    }\n    toRgbArray(out) {\n        if (!this._arrayRgb) this._arrayRgb = [];\n        out || (out = this._arrayRgb);\n        const [r, g, b] = this._components;\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        return out;\n    }\n    /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */ toNumber() {\n        return this._int;\n    }\n    /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */ toBgrNumber() {\n        const [r, g, b] = this.toUint8RgbArray();\n        return (b << 16) + (g << 8) + r;\n    }\n    /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */ toLittleEndianNumber() {\n        const value = this._int;\n        return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n    }\n    /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */ multiply(value) {\n        const [r, g, b, a] = _Color._temp.setValue(value)._components;\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n        this._refreshInt();\n        this._value = null;\n        return this;\n    }\n    /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */ premultiply(alpha, applyToRGB = true) {\n        if (applyToRGB) {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n        this._refreshInt();\n        this._value = null;\n        return this;\n    }\n    /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */ toPremultiplied(alpha, applyToRGB = true) {\n        if (alpha === 1) return -16777216 + this._int;\n        if (alpha === 0) return applyToRGB ? 0 : this._int;\n        let r = this._int >> 16 & 255;\n        let g = this._int >> 8 & 255;\n        let b = this._int & 255;\n        if (applyToRGB) {\n            r = r * alpha + 0.5 | 0;\n            g = g * alpha + 0.5 | 0;\n            b = b * alpha + 0.5 | 0;\n        }\n        return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n    }\n    /**\n   * Convert to a hexadecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */ toHex() {\n        const hexString = this._int.toString(16);\n        return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n    }\n    /**\n   * Convert to a hexadecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */ toHexa() {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n        return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n    }\n    /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */ setAlpha(alpha) {\n        this._components[3] = this._clamp(alpha);\n        return this;\n    }\n    /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */ _normalize(value) {\n        let r;\n        let g;\n        let b;\n        let a;\n        if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n            const int = value;\n            r = (int >> 16 & 255) / 255;\n            g = (int >> 8 & 255) / 255;\n            b = (int & 255) / 255;\n            a = 1;\n        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n            value = this._clamp(value);\n            [r, g, b, a = 1] = value;\n        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        } else if (typeof value === \"string\" || typeof value === \"object\") {\n            if (typeof value === \"string\") {\n                const match = _Color.HEX_PATTERN.exec(value);\n                if (match) value = `#${match[2]}`;\n            }\n            const color = (0, $hgnOi.colord)(value);\n            if (color.isValid()) {\n                ({ r: r, g: g, b: b, a: a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n        if (r !== void 0) {\n            this._components[0] = r;\n            this._components[1] = g;\n            this._components[2] = b;\n            this._components[3] = a;\n            this._refreshInt();\n        } else throw new Error(`Unable to convert color ${value}`);\n    }\n    /** Refresh the internal color rgb number */ _refreshInt() {\n        this._clamp(this._components);\n        const [r, g, b] = this._components;\n        this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n    }\n    /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */ _clamp(value, min = 0, max = 1) {\n        if (typeof value === \"number\") return Math.min(Math.max(value, min), max);\n        value.forEach((v, i)=>{\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n        return value;\n    }\n    /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from 'pixi.js';\n   * Color.isColorLike('white'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */ static isColorLike(value) {\n        return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n    }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from 'pixi.js';\n * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n */ $ce14d1440ee922b4$var$_Color.shared = new $ce14d1440ee922b4$var$_Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */ $ce14d1440ee922b4$var$_Color._temp = new $ce14d1440ee922b4$var$_Color();\n/** Pattern for hex strings */ // eslint-disable-next-line @typescript-eslint/naming-convention\n$ce14d1440ee922b4$var$_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet $ce14d1440ee922b4$export$892596cec99bc70e = $ce14d1440ee922b4$var$_Color;\n\n});\nparcelRegister(\"hgnOi\", function(module, exports) {\n\n$parcel$export(module.exports, \"colord\", function () { return $44b44bc546a4a126$export$c8efe09109f9cb9e; });\n$parcel$export(module.exports, \"extend\", function () { return $44b44bc546a4a126$export$8b58be045bf06082; });\nvar $44b44bc546a4a126$var$r = {\n    grad: .9,\n    turn: 360,\n    rad: 360 / (2 * Math.PI)\n}, $44b44bc546a4a126$var$t = function(r) {\n    return \"string\" == typeof r ? r.length > 0 : \"number\" == typeof r;\n}, $44b44bc546a4a126$var$n = function(r, t, n) {\n    return void 0 === t && (t = 0), void 0 === n && (n = Math.pow(10, t)), Math.round(n * r) / n + 0;\n}, $44b44bc546a4a126$var$e = function(r, t, n) {\n    return void 0 === t && (t = 0), void 0 === n && (n = 1), r > n ? n : r > t ? r : t;\n}, $44b44bc546a4a126$var$u = function(r) {\n    return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;\n}, $44b44bc546a4a126$var$a = function(r) {\n    return {\n        r: $44b44bc546a4a126$var$e(r.r, 0, 255),\n        g: $44b44bc546a4a126$var$e(r.g, 0, 255),\n        b: $44b44bc546a4a126$var$e(r.b, 0, 255),\n        a: $44b44bc546a4a126$var$e(r.a)\n    };\n}, $44b44bc546a4a126$var$o = function(r) {\n    return {\n        r: $44b44bc546a4a126$var$n(r.r),\n        g: $44b44bc546a4a126$var$n(r.g),\n        b: $44b44bc546a4a126$var$n(r.b),\n        a: $44b44bc546a4a126$var$n(r.a, 3)\n    };\n}, $44b44bc546a4a126$var$i = /^#([0-9a-f]{3,8})$/i, $44b44bc546a4a126$var$s = function(r) {\n    var t = r.toString(16);\n    return t.length < 2 ? \"0\" + t : t;\n}, $44b44bc546a4a126$var$h = function(r) {\n    var t = r.r, n = r.g, e = r.b, u = r.a, a = Math.max(t, n, e), o = a - Math.min(t, n, e), i = o ? a === t ? (n - e) / o : a === n ? 2 + (e - t) / o : 4 + (t - n) / o : 0;\n    return {\n        h: 60 * (i < 0 ? i + 6 : i),\n        s: a ? o / a * 100 : 0,\n        v: a / 255 * 100,\n        a: u\n    };\n}, $44b44bc546a4a126$var$b = function(r) {\n    var t = r.h, n = r.s, e = r.v, u = r.a;\n    t = t / 360 * 6, n /= 100, e /= 100;\n    var a = Math.floor(t), o = e * (1 - n), i = e * (1 - (t - a) * n), s = e * (1 - (1 - t + a) * n), h = a % 6;\n    return {\n        r: 255 * [\n            e,\n            i,\n            o,\n            o,\n            s,\n            e\n        ][h],\n        g: 255 * [\n            s,\n            e,\n            e,\n            i,\n            o,\n            o\n        ][h],\n        b: 255 * [\n            o,\n            o,\n            s,\n            e,\n            e,\n            i\n        ][h],\n        a: u\n    };\n}, $44b44bc546a4a126$var$g = function(r) {\n    return {\n        h: $44b44bc546a4a126$var$u(r.h),\n        s: $44b44bc546a4a126$var$e(r.s, 0, 100),\n        l: $44b44bc546a4a126$var$e(r.l, 0, 100),\n        a: $44b44bc546a4a126$var$e(r.a)\n    };\n}, $44b44bc546a4a126$var$d = function(r) {\n    return {\n        h: $44b44bc546a4a126$var$n(r.h),\n        s: $44b44bc546a4a126$var$n(r.s),\n        l: $44b44bc546a4a126$var$n(r.l),\n        a: $44b44bc546a4a126$var$n(r.a, 3)\n    };\n}, $44b44bc546a4a126$var$f = function(r) {\n    var t, n, e;\n    return $44b44bc546a4a126$var$b((n = (t = r).s, {\n        h: t.h,\n        s: (n *= ((e = t.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * n / (e + n) * 100 : 0,\n        v: e + n,\n        a: t.a\n    }));\n}, $44b44bc546a4a126$var$c = function(r) {\n    var t, n, e, u;\n    return {\n        h: (t = $44b44bc546a4a126$var$h(r)).h,\n        s: (u = (200 - (n = t.s)) * (e = t.v) / 100) > 0 && u < 200 ? n * e / 100 / (u <= 100 ? u : 200 - u) * 100 : 0,\n        l: u / 2,\n        a: t.a\n    };\n}, $44b44bc546a4a126$var$l = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $44b44bc546a4a126$var$p = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $44b44bc546a4a126$var$v = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $44b44bc546a4a126$var$m = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $44b44bc546a4a126$var$y = {\n    string: [\n        [\n            function(r) {\n                var t = $44b44bc546a4a126$var$i.exec(r);\n                return t ? (r = t[1]).length <= 4 ? {\n                    r: parseInt(r[0] + r[0], 16),\n                    g: parseInt(r[1] + r[1], 16),\n                    b: parseInt(r[2] + r[2], 16),\n                    a: 4 === r.length ? $44b44bc546a4a126$var$n(parseInt(r[3] + r[3], 16) / 255, 2) : 1\n                } : 6 === r.length || 8 === r.length ? {\n                    r: parseInt(r.substr(0, 2), 16),\n                    g: parseInt(r.substr(2, 2), 16),\n                    b: parseInt(r.substr(4, 2), 16),\n                    a: 8 === r.length ? $44b44bc546a4a126$var$n(parseInt(r.substr(6, 2), 16) / 255, 2) : 1\n                } : null : null;\n            },\n            \"hex\"\n        ],\n        [\n            function(r) {\n                var t = $44b44bc546a4a126$var$v.exec(r) || $44b44bc546a4a126$var$m.exec(r);\n                return t ? t[2] !== t[4] || t[4] !== t[6] ? null : $44b44bc546a4a126$var$a({\n                    r: Number(t[1]) / (t[2] ? 100 / 255 : 1),\n                    g: Number(t[3]) / (t[4] ? 100 / 255 : 1),\n                    b: Number(t[5]) / (t[6] ? 100 / 255 : 1),\n                    a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1)\n                }) : null;\n            },\n            \"rgb\"\n        ],\n        [\n            function(t) {\n                var n = $44b44bc546a4a126$var$l.exec(t) || $44b44bc546a4a126$var$p.exec(t);\n                if (!n) return null;\n                var e, u, a = $44b44bc546a4a126$var$g({\n                    h: (e = n[1], u = n[2], void 0 === u && (u = \"deg\"), Number(e) * ($44b44bc546a4a126$var$r[u] || 1)),\n                    s: Number(n[3]),\n                    l: Number(n[4]),\n                    a: void 0 === n[5] ? 1 : Number(n[5]) / (n[6] ? 100 : 1)\n                });\n                return $44b44bc546a4a126$var$f(a);\n            },\n            \"hsl\"\n        ]\n    ],\n    object: [\n        [\n            function(r) {\n                var n = r.r, e = r.g, u = r.b, o = r.a, i = void 0 === o ? 1 : o;\n                return $44b44bc546a4a126$var$t(n) && $44b44bc546a4a126$var$t(e) && $44b44bc546a4a126$var$t(u) ? $44b44bc546a4a126$var$a({\n                    r: Number(n),\n                    g: Number(e),\n                    b: Number(u),\n                    a: Number(i)\n                }) : null;\n            },\n            \"rgb\"\n        ],\n        [\n            function(r) {\n                var n = r.h, e = r.s, u = r.l, a = r.a, o = void 0 === a ? 1 : a;\n                if (!$44b44bc546a4a126$var$t(n) || !$44b44bc546a4a126$var$t(e) || !$44b44bc546a4a126$var$t(u)) return null;\n                var i = $44b44bc546a4a126$var$g({\n                    h: Number(n),\n                    s: Number(e),\n                    l: Number(u),\n                    a: Number(o)\n                });\n                return $44b44bc546a4a126$var$f(i);\n            },\n            \"hsl\"\n        ],\n        [\n            function(r) {\n                var n = r.h, a = r.s, o = r.v, i = r.a, s = void 0 === i ? 1 : i;\n                if (!$44b44bc546a4a126$var$t(n) || !$44b44bc546a4a126$var$t(a) || !$44b44bc546a4a126$var$t(o)) return null;\n                var h = function(r) {\n                    return {\n                        h: $44b44bc546a4a126$var$u(r.h),\n                        s: $44b44bc546a4a126$var$e(r.s, 0, 100),\n                        v: $44b44bc546a4a126$var$e(r.v, 0, 100),\n                        a: $44b44bc546a4a126$var$e(r.a)\n                    };\n                }({\n                    h: Number(n),\n                    s: Number(a),\n                    v: Number(o),\n                    a: Number(s)\n                });\n                return $44b44bc546a4a126$var$b(h);\n            },\n            \"hsv\"\n        ]\n    ]\n}, $44b44bc546a4a126$var$N = function(r, t) {\n    for(var n = 0; n < t.length; n++){\n        var e = t[n][0](r);\n        if (e) return [\n            e,\n            t[n][1]\n        ];\n    }\n    return [\n        null,\n        void 0\n    ];\n}, $44b44bc546a4a126$var$x = function(r) {\n    return \"string\" == typeof r ? $44b44bc546a4a126$var$N(r.trim(), $44b44bc546a4a126$var$y.string) : \"object\" == typeof r && null !== r ? $44b44bc546a4a126$var$N(r, $44b44bc546a4a126$var$y.object) : [\n        null,\n        void 0\n    ];\n}, $44b44bc546a4a126$export$f61ac8b6f1f46202 = function(r) {\n    return $44b44bc546a4a126$var$x(r)[1];\n}, $44b44bc546a4a126$var$M = function(r, t) {\n    var n = $44b44bc546a4a126$var$c(r);\n    return {\n        h: n.h,\n        s: $44b44bc546a4a126$var$e(n.s + 100 * t, 0, 100),\n        l: n.l,\n        a: n.a\n    };\n}, $44b44bc546a4a126$var$H = function(r) {\n    return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;\n}, $44b44bc546a4a126$var$$ = function(r, t) {\n    var n = $44b44bc546a4a126$var$c(r);\n    return {\n        h: n.h,\n        s: n.s,\n        l: $44b44bc546a4a126$var$e(n.l + 100 * t, 0, 100),\n        a: n.a\n    };\n}, $44b44bc546a4a126$export$4d30ed660ff08d0 = function() {\n    function r(r) {\n        this.parsed = $44b44bc546a4a126$var$x(r)[0], this.rgba = this.parsed || {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        };\n    }\n    return r.prototype.isValid = function() {\n        return null !== this.parsed;\n    }, r.prototype.brightness = function() {\n        return $44b44bc546a4a126$var$n($44b44bc546a4a126$var$H(this.rgba), 2);\n    }, r.prototype.isDark = function() {\n        return $44b44bc546a4a126$var$H(this.rgba) < .5;\n    }, r.prototype.isLight = function() {\n        return $44b44bc546a4a126$var$H(this.rgba) >= .5;\n    }, r.prototype.toHex = function() {\n        var r, t, e, u, a, i;\n        return r = $44b44bc546a4a126$var$o(this.rgba), t = r.r, e = r.g, u = r.b, i = (a = r.a) < 1 ? $44b44bc546a4a126$var$s($44b44bc546a4a126$var$n(255 * a)) : \"\", \"#\" + $44b44bc546a4a126$var$s(t) + $44b44bc546a4a126$var$s(e) + $44b44bc546a4a126$var$s(u) + i;\n    }, r.prototype.toRgb = function() {\n        return $44b44bc546a4a126$var$o(this.rgba);\n    }, r.prototype.toRgbString = function() {\n        var r, t, n, e, u;\n        return r = $44b44bc546a4a126$var$o(this.rgba), t = r.r, n = r.g, e = r.b, (u = r.a) < 1 ? \"rgba(\" + t + \", \" + n + \", \" + e + \", \" + u + \")\" : \"rgb(\" + t + \", \" + n + \", \" + e + \")\";\n    }, r.prototype.toHsl = function() {\n        return $44b44bc546a4a126$var$d($44b44bc546a4a126$var$c(this.rgba));\n    }, r.prototype.toHslString = function() {\n        var r, t, n, e, u;\n        return r = $44b44bc546a4a126$var$d($44b44bc546a4a126$var$c(this.rgba)), t = r.h, n = r.s, e = r.l, (u = r.a) < 1 ? \"hsla(\" + t + \", \" + n + \"%, \" + e + \"%, \" + u + \")\" : \"hsl(\" + t + \", \" + n + \"%, \" + e + \"%)\";\n    }, r.prototype.toHsv = function() {\n        var r;\n        return r = $44b44bc546a4a126$var$h(this.rgba), {\n            h: $44b44bc546a4a126$var$n(r.h),\n            s: $44b44bc546a4a126$var$n(r.s),\n            v: $44b44bc546a4a126$var$n(r.v),\n            a: $44b44bc546a4a126$var$n(r.a, 3)\n        };\n    }, r.prototype.invert = function() {\n        var r;\n        return $44b44bc546a4a126$export$c8efe09109f9cb9e({\n            r: 255 - (r = this.rgba).r,\n            g: 255 - r.g,\n            b: 255 - r.b,\n            a: r.a\n        });\n    }, r.prototype.saturate = function(r) {\n        return void 0 === r && (r = .1), $44b44bc546a4a126$export$c8efe09109f9cb9e($44b44bc546a4a126$var$M(this.rgba, r));\n    }, r.prototype.desaturate = function(r) {\n        return void 0 === r && (r = .1), $44b44bc546a4a126$export$c8efe09109f9cb9e($44b44bc546a4a126$var$M(this.rgba, -r));\n    }, r.prototype.grayscale = function() {\n        return $44b44bc546a4a126$export$c8efe09109f9cb9e($44b44bc546a4a126$var$M(this.rgba, -1));\n    }, r.prototype.lighten = function(r) {\n        return void 0 === r && (r = .1), $44b44bc546a4a126$export$c8efe09109f9cb9e($44b44bc546a4a126$var$$(this.rgba, r));\n    }, r.prototype.darken = function(r) {\n        return void 0 === r && (r = .1), $44b44bc546a4a126$export$c8efe09109f9cb9e($44b44bc546a4a126$var$$(this.rgba, -r));\n    }, r.prototype.rotate = function(r) {\n        return void 0 === r && (r = 15), this.hue(this.hue() + r);\n    }, r.prototype.alpha = function(r) {\n        var t;\n        return \"number\" == typeof r ? $44b44bc546a4a126$export$c8efe09109f9cb9e({\n            r: (t = this.rgba).r,\n            g: t.g,\n            b: t.b,\n            a: r\n        }) : $44b44bc546a4a126$var$n(this.rgba.a, 3);\n    }, r.prototype.hue = function(r) {\n        var t = $44b44bc546a4a126$var$c(this.rgba);\n        return \"number\" == typeof r ? $44b44bc546a4a126$export$c8efe09109f9cb9e({\n            h: r,\n            s: t.s,\n            l: t.l,\n            a: t.a\n        }) : $44b44bc546a4a126$var$n(t.h);\n    }, r.prototype.isEqual = function(r) {\n        return this.toHex() === $44b44bc546a4a126$export$c8efe09109f9cb9e(r).toHex();\n    }, r;\n}(), $44b44bc546a4a126$export$c8efe09109f9cb9e = function(r) {\n    return r instanceof $44b44bc546a4a126$export$4d30ed660ff08d0 ? r : new $44b44bc546a4a126$export$4d30ed660ff08d0(r);\n}, $44b44bc546a4a126$var$S = [], $44b44bc546a4a126$export$8b58be045bf06082 = function(r) {\n    r.forEach(function(r) {\n        $44b44bc546a4a126$var$S.indexOf(r) < 0 && (r($44b44bc546a4a126$export$4d30ed660ff08d0, $44b44bc546a4a126$var$y), $44b44bc546a4a126$var$S.push(r));\n    });\n}, $44b44bc546a4a126$export$4385e60b38654f68 = function() {\n    return new $44b44bc546a4a126$export$4d30ed660ff08d0({\n        r: 255 * Math.random(),\n        g: 255 * Math.random(),\n        b: 255 * Math.random()\n    });\n};\n\n});\n\nparcelRegister(\"40ez6\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $cf19add7623c5dc6$export$2e2bcd8739ae039; });\nfunction $cf19add7623c5dc6$export$2e2bcd8739ae039(e, f) {\n    var a = {\n        white: \"#ffffff\",\n        bisque: \"#ffe4c4\",\n        blue: \"#0000ff\",\n        cadetblue: \"#5f9ea0\",\n        chartreuse: \"#7fff00\",\n        chocolate: \"#d2691e\",\n        coral: \"#ff7f50\",\n        antiquewhite: \"#faebd7\",\n        aqua: \"#00ffff\",\n        azure: \"#f0ffff\",\n        whitesmoke: \"#f5f5f5\",\n        papayawhip: \"#ffefd5\",\n        plum: \"#dda0dd\",\n        blanchedalmond: \"#ffebcd\",\n        black: \"#000000\",\n        gold: \"#ffd700\",\n        goldenrod: \"#daa520\",\n        gainsboro: \"#dcdcdc\",\n        cornsilk: \"#fff8dc\",\n        cornflowerblue: \"#6495ed\",\n        burlywood: \"#deb887\",\n        aquamarine: \"#7fffd4\",\n        beige: \"#f5f5dc\",\n        crimson: \"#dc143c\",\n        cyan: \"#00ffff\",\n        darkblue: \"#00008b\",\n        darkcyan: \"#008b8b\",\n        darkgoldenrod: \"#b8860b\",\n        darkkhaki: \"#bdb76b\",\n        darkgray: \"#a9a9a9\",\n        darkgreen: \"#006400\",\n        darkgrey: \"#a9a9a9\",\n        peachpuff: \"#ffdab9\",\n        darkmagenta: \"#8b008b\",\n        darkred: \"#8b0000\",\n        darkorchid: \"#9932cc\",\n        darkorange: \"#ff8c00\",\n        darkslateblue: \"#483d8b\",\n        gray: \"#808080\",\n        darkslategray: \"#2f4f4f\",\n        darkslategrey: \"#2f4f4f\",\n        deeppink: \"#ff1493\",\n        deepskyblue: \"#00bfff\",\n        wheat: \"#f5deb3\",\n        firebrick: \"#b22222\",\n        floralwhite: \"#fffaf0\",\n        ghostwhite: \"#f8f8ff\",\n        darkviolet: \"#9400d3\",\n        magenta: \"#ff00ff\",\n        green: \"#008000\",\n        dodgerblue: \"#1e90ff\",\n        grey: \"#808080\",\n        honeydew: \"#f0fff0\",\n        hotpink: \"#ff69b4\",\n        blueviolet: \"#8a2be2\",\n        forestgreen: \"#228b22\",\n        lawngreen: \"#7cfc00\",\n        indianred: \"#cd5c5c\",\n        indigo: \"#4b0082\",\n        fuchsia: \"#ff00ff\",\n        brown: \"#a52a2a\",\n        maroon: \"#800000\",\n        mediumblue: \"#0000cd\",\n        lightcoral: \"#f08080\",\n        darkturquoise: \"#00ced1\",\n        lightcyan: \"#e0ffff\",\n        ivory: \"#fffff0\",\n        lightyellow: \"#ffffe0\",\n        lightsalmon: \"#ffa07a\",\n        lightseagreen: \"#20b2aa\",\n        linen: \"#faf0e6\",\n        mediumaquamarine: \"#66cdaa\",\n        lemonchiffon: \"#fffacd\",\n        lime: \"#00ff00\",\n        khaki: \"#f0e68c\",\n        mediumseagreen: \"#3cb371\",\n        limegreen: \"#32cd32\",\n        mediumspringgreen: \"#00fa9a\",\n        lightskyblue: \"#87cefa\",\n        lightblue: \"#add8e6\",\n        midnightblue: \"#191970\",\n        lightpink: \"#ffb6c1\",\n        mistyrose: \"#ffe4e1\",\n        moccasin: \"#ffe4b5\",\n        mintcream: \"#f5fffa\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        navajowhite: \"#ffdead\",\n        navy: \"#000080\",\n        mediumvioletred: \"#c71585\",\n        powderblue: \"#b0e0e6\",\n        palegoldenrod: \"#eee8aa\",\n        oldlace: \"#fdf5e6\",\n        paleturquoise: \"#afeeee\",\n        mediumturquoise: \"#48d1cc\",\n        mediumorchid: \"#ba55d3\",\n        rebeccapurple: \"#663399\",\n        lightsteelblue: \"#b0c4de\",\n        mediumslateblue: \"#7b68ee\",\n        thistle: \"#d8bfd8\",\n        tan: \"#d2b48c\",\n        orchid: \"#da70d6\",\n        mediumpurple: \"#9370db\",\n        purple: \"#800080\",\n        pink: \"#ffc0cb\",\n        skyblue: \"#87ceeb\",\n        springgreen: \"#00ff7f\",\n        palegreen: \"#98fb98\",\n        red: \"#ff0000\",\n        yellow: \"#ffff00\",\n        slateblue: \"#6a5acd\",\n        lavenderblush: \"#fff0f5\",\n        peru: \"#cd853f\",\n        palevioletred: \"#db7093\",\n        violet: \"#ee82ee\",\n        teal: \"#008080\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        aliceblue: \"#f0f8ff\",\n        darkseagreen: \"#8fbc8f\",\n        darkolivegreen: \"#556b2f\",\n        greenyellow: \"#adff2f\",\n        seagreen: \"#2e8b57\",\n        seashell: \"#fff5ee\",\n        tomato: \"#ff6347\",\n        silver: \"#c0c0c0\",\n        sienna: \"#a0522d\",\n        lavender: \"#e6e6fa\",\n        lightgreen: \"#90ee90\",\n        orange: \"#ffa500\",\n        orangered: \"#ff4500\",\n        steelblue: \"#4682b4\",\n        royalblue: \"#4169e1\",\n        turquoise: \"#40e0d0\",\n        yellowgreen: \"#9acd32\",\n        salmon: \"#fa8072\",\n        saddlebrown: \"#8b4513\",\n        sandybrown: \"#f4a460\",\n        rosybrown: \"#bc8f8f\",\n        darksalmon: \"#e9967a\",\n        lightgoldenrodyellow: \"#fafad2\",\n        snow: \"#fffafa\",\n        lightgrey: \"#d3d3d3\",\n        lightgray: \"#d3d3d3\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        olivedrab: \"#6b8e23\",\n        olive: \"#808000\"\n    }, r = {};\n    for(var d in a)r[a[d]] = d;\n    var l = {};\n    e.prototype.toName = function(f) {\n        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return \"transparent\";\n        var d, i, n = r[this.toHex()];\n        if (n) return n;\n        if (null == f ? void 0 : f.closest) {\n            var o = this.toRgb(), t = 1 / 0, b = \"black\";\n            if (!l.length) for(var c in a)l[c] = new e(a[c]).toRgb();\n            for(var g in a){\n                var u = (d = o, i = l[g], Math.pow(d.r - i.r, 2) + Math.pow(d.g - i.g, 2) + Math.pow(d.b - i.b, 2));\n                u < t && (t = u, b = g);\n            }\n            return b;\n        }\n    };\n    f.string.push([\n        function(f) {\n            var r = f.toLowerCase(), d = \"transparent\" === r ? \"#0000\" : a[r];\n            return d ? new e(d).toRgb() : null;\n        },\n        \"name\"\n    ]);\n}\n\n});\n\n\nparcelRegister(\"7tfc3\", function(module, exports) {\n\n$parcel$export(module.exports, \"cullingMixin\", function () { return $baf6669d7bf5ea3c$export$dce76d4f0fd249ed; });\n\"use strict\";\nconst $baf6669d7bf5ea3c$export$dce76d4f0fd249ed = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true\n};\n\n});\n\nparcelRegister(\"dLv5L\", function(module, exports) {\n\n$parcel$export(module.exports, \"BigPool\", function () { return $489893e6d10c5383$export$8249372279066210; });\n\nvar $h8Jx4 = parcelRequire(\"h8Jx4\");\n\"use strict\";\nclass $489893e6d10c5383$export$866836a21808b71c {\n    constructor(){\n        /**\n     * A map to store the pools by their class type.\n     * @private\n     */ this._poolsByClass = /* @__PURE__ */ new Map();\n    }\n    /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */ prepopulate(Class, total) {\n        const classPool = this.getPool(Class);\n        classPool.prepopulate(total);\n    }\n    /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */ get(Class, data) {\n        const pool = this.getPool(Class);\n        return pool.get(data);\n    }\n    /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */ return(item) {\n        const pool = this.getPool(item.constructor);\n        pool.return(item);\n    }\n    /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */ getPool(ClassType) {\n        if (!this._poolsByClass.has(ClassType)) this._poolsByClass.set(ClassType, new (0, $h8Jx4.Pool)(ClassType));\n        return this._poolsByClass.get(ClassType);\n    }\n    /** gets the usage stats of each pool in the system */ stats() {\n        const stats = {};\n        this._poolsByClass.forEach((pool)=>{\n            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize\n            };\n        });\n        return stats;\n    }\n}\nconst $489893e6d10c5383$export$8249372279066210 = new $489893e6d10c5383$export$866836a21808b71c();\n\n});\nparcelRegister(\"h8Jx4\", function(module, exports) {\n\n$parcel$export(module.exports, \"Pool\", function () { return $64b1c68c385378e9$export$14963ee5c8637e11; });\n\"use strict\";\nclass $64b1c68c385378e9$export$14963ee5c8637e11 {\n    /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */ constructor(ClassType, initialSize){\n        this._pool = [];\n        this._count = 0;\n        this._index = 0;\n        this._classType = ClassType;\n        if (initialSize) this.prepopulate(initialSize);\n    }\n    /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */ prepopulate(total) {\n        for(let i = 0; i < total; i++)this._pool[this._index++] = new this._classType();\n        this._count += total;\n    }\n    /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */ get(data) {\n        let item;\n        if (this._index > 0) item = this._pool[--this._index];\n        else item = new this._classType();\n        item.init?.(data);\n        return item;\n    }\n    /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */ return(item) {\n        item.reset?.();\n        this._pool[this._index++] = item;\n    }\n    /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */ get totalSize() {\n        return this._count;\n    }\n    /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */ get totalFree() {\n        return this._index;\n    }\n    /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */ get totalUsed() {\n        return this._count - this._index;\n    }\n    /** clears the pool - mainly used for debugging! */ clear() {\n        this._pool.length = 0;\n        this._index = 0;\n    }\n}\n\n});\n\n\nparcelRegister(\"eURp4\", function(module, exports) {\n\n$parcel$export(module.exports, \"cacheAsTextureMixin\", function () { return $aca394a50e66740d$export$9660f593b1298e75; });\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\"use strict\";\nconst $aca394a50e66740d$export$9660f593b1298e75 = {\n    /**\n   * Is this container cached as a texture?\n   * @readonly\n   * @type {boolean}\n   * @memberof scene.Container#\n   */ get isCachedAsTexture () {\n        return !!this.renderGroup?.isCachedAsTexture;\n    },\n    cacheAsTexture (val1) {\n        if (typeof val1 === \"boolean\" && val1 === false) this.disableRenderGroup();\n        else {\n            this.enableRenderGroup();\n            this.renderGroup.enableCacheAsTexture(val1 === true ? {} : val1);\n        }\n    },\n    /**\n   * Updates the cached texture. Will flag that this container's cached texture needs to be redrawn.\n   * This will happen on the next render.\n   * @memberof scene.Container#\n   */ updateCacheTexture () {\n        this.renderGroup?.updateCacheTexture();\n    },\n    /**\n   * Allows backwards compatibility with pixi.js below version v8. Use `cacheAsTexture` instead.\n   * @deprecated\n   */ get cacheAsBitmap () {\n        return this.isCachedAsTexture;\n    },\n    /**\n   * @deprecated\n   */ set cacheAsBitmap (val){\n        (0, $aCdt0.deprecation)(\"v8.6.0\", \"cacheAsBitmap is deprecated, use cacheAsTexture instead.\");\n        this.cacheAsTexture(val);\n    }\n};\n\n});\n\nparcelRegister(\"5XZI5\", function(module, exports) {\n\n$parcel$export(module.exports, \"childrenHelperMixin\", function () { return $4caa91b2de1a4670$export$64cca9f0c2df174a; });\n\nvar $cGrD4 = parcelRequire(\"cGrD4\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\"use strict\";\nconst $4caa91b2de1a4670$export$64cca9f0c2df174a = {\n    allowChildren: true,\n    /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */ removeChildren (beginIndex = 0, endIndex) {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed = [];\n        if (range > 0 && range <= end) {\n            for(let i = end - 1; i >= beginIndex; i--){\n                const child = this.children[i];\n                if (!child) continue;\n                removed.push(child);\n                child.parent = null;\n            }\n            (0, $cGrD4.removeItems)(this.children, beginIndex, end);\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n            if (renderGroup) renderGroup.removeChildren(removed);\n            for(let i = 0; i < removed.length; ++i){\n                this.emit(\"childRemoved\", removed[i], this, i);\n                removed[i].emit(\"removed\", this);\n            }\n            return removed;\n        } else if (range === 0 && this.children.length === 0) return removed;\n        throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n    },\n    /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */ removeChildAt (index) {\n        const child = this.getChildAt(index);\n        return this.removeChild(child);\n    },\n    /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */ getChildAt (index) {\n        if (index < 0 || index >= this.children.length) throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        return this.children[index];\n    },\n    /**\n   * Changes the position of an existing child in the container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */ setChildIndex (child, index) {\n        if (index < 0 || index >= this.children.length) throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        this.getChildIndex(child);\n        this.addChildAt(child, index);\n    },\n    /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */ getChildIndex (child) {\n        const index = this.children.indexOf(child);\n        if (index === -1) throw new Error(\"The supplied Container must be a child of the caller\");\n        return index;\n    },\n    /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */ addChildAt (child, index) {\n        if (!this.allowChildren) (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n        const { children: children } = this;\n        if (index < 0 || index > children.length) throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        if (child.parent) {\n            const currentIndex = child.parent.children.indexOf(child);\n            if (child.parent === this && currentIndex === index) return child;\n            if (currentIndex !== -1) child.parent.children.splice(currentIndex, 1);\n        }\n        if (index === children.length) children.push(child);\n        else children.splice(index, 0, child);\n        child.parent = this;\n        child.didChange = true;\n        child._updateFlags = 15;\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.addChild(child);\n        if (this.sortableChildren) this.sortDirty = true;\n        this.emit(\"childAdded\", child, this, index);\n        child.emit(\"added\", this);\n        return child;\n    },\n    /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   * @memberof scene.Container#\n   */ swapChildren (child, child2) {\n        if (child === child2) return;\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.structureDidChange = true;\n        this._didContainerChangeTick++;\n    },\n    /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */ removeFromParent () {\n        this.parent?.removeChild(this);\n    },\n    /**\n   * Reparent the child to this container, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @returns The first child that was reparented.\n   * @memberof scene.Container#\n   */ reparentChild (...child) {\n        if (child.length === 1) return this.reparentChildAt(child[0], this.children.length);\n        child.forEach((c)=>this.reparentChildAt(c, this.children.length));\n        return child[0];\n    },\n    /**\n   * Reparent the child to this container at the specified index, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @param index - The index to reparent the child to\n   * @memberof scene.Container#\n   */ reparentChildAt (child, index) {\n        if (child.parent === this) {\n            this.setChildIndex(child, index);\n            return child;\n        }\n        const childMat = child.worldTransform.clone();\n        child.removeFromParent();\n        this.addChildAt(child, index);\n        const newMatrix = this.worldTransform.clone();\n        newMatrix.invert();\n        childMat.prepend(newMatrix);\n        child.setFromMatrix(childMat);\n        return child;\n    }\n};\n\n});\nparcelRegister(\"cGrD4\", function(module, exports) {\n\n$parcel$export(module.exports, \"removeItems\", function () { return $cc86715a5454533e$export$8d47c0e1ce445404; });\n\"use strict\";\nfunction $cc86715a5454533e$export$8d47c0e1ce445404(arr, startIdx, removeCount) {\n    const length = arr.length;\n    let i;\n    if (startIdx >= length || removeCount === 0) return;\n    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n    const len = length - removeCount;\n    for(i = startIdx; i < len; ++i)arr[i] = arr[i + removeCount];\n    arr.length = len;\n}\n\n});\n\n\nparcelRegister(\"8aDma\", function(module, exports) {\n\n$parcel$export(module.exports, \"collectRenderablesMixin\", function () { return $b192be86e57e3f3d$export$e50be97f8cd670d0; });\n\"use strict\";\nconst $b192be86e57e3f3d$export$e50be97f8cd670d0 = {\n    /**\n   * Main method to collect renderables from the container and its children.\n   * It checks the container's properties to decide whether to use a simple or advanced collection method.\n   * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n   * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n   * @param {IRenderLayer} currentLayer - The current render layer being processed.\n   * @memberof scene.Container#\n   */ collectRenderables (instructionSet, renderer, currentLayer) {\n        if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild) return;\n        if (this.sortableChildren) this.sortChildren();\n        if (this.isSimple) this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n        else if (this.renderGroup) renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);\n        else this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);\n    },\n    /**\n   * Simple method for collecting renderables from the container's children.\n   * This method is efficient and used when the container is marked as simple.\n   * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n   * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n   * @param {IRenderLayer} currentLayer - The current render layer being processed.\n   * @memberof scene.Container#\n   */ collectRenderablesSimple (instructionSet, renderer, currentLayer) {\n        const children = this.children;\n        const length = children.length;\n        for(let i = 0; i < length; i++)children[i].collectRenderables(instructionSet, renderer, currentLayer);\n    },\n    /**\n   * Advanced method for collecting renderables, which handles additional effects.\n   * This method is used when the container has complex processing needs.\n   * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n   * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n   * @param {IRenderLayer} currentLayer - The current render layer being processed.\n   * @memberof scene.Container#\n   */ collectRenderablesWithEffects (instructionSet, renderer, currentLayer) {\n        const { renderPipes: renderPipes } = renderer;\n        for(let i = 0; i < this.effects.length; i++){\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe];\n            pipe.push(effect, this, instructionSet);\n        }\n        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n        for(let i = this.effects.length - 1; i >= 0; i--){\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe];\n            pipe.pop(effect, this, instructionSet);\n        }\n    }\n};\n\n});\n\nparcelRegister(\"fWc5r\", function(module, exports) {\n\n$parcel$export(module.exports, \"effectsMixin\", function () { return $2bf418dded26abfd$export$eec5e288a9d02a7c; });\n\nvar $4kixb = parcelRequire(\"4kixb\");\n\nvar $jYxJQ = parcelRequire(\"jYxJQ\");\n\"use strict\";\nconst $2bf418dded26abfd$export$eec5e288a9d02a7c = {\n    _maskEffect: null,\n    _maskOptions: {\n        inverse: false\n    },\n    _filterEffect: null,\n    /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */ effects: [],\n    _markStructureAsChanged () {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.structureDidChange = true;\n    },\n    /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */ addEffect (effect) {\n        const index = this.effects.indexOf(effect);\n        if (index !== -1) return;\n        this.effects.push(effect);\n        this.effects.sort((a, b)=>a.priority - b.priority);\n        this._markStructureAsChanged();\n        this._updateIsSimple();\n    },\n    /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */ removeEffect (effect) {\n        const index = this.effects.indexOf(effect);\n        if (index === -1) return;\n        this.effects.splice(index, 1);\n        this._markStructureAsChanged();\n        this._updateIsSimple();\n    },\n    set mask (value){\n        const effect = this._maskEffect;\n        if (effect?.mask === value) return;\n        if (effect) {\n            this.removeEffect(effect);\n            (0, $jYxJQ.MaskEffectManager).returnMaskEffect(effect);\n            this._maskEffect = null;\n        }\n        if (value === null || value === void 0) return;\n        this._maskEffect = (0, $jYxJQ.MaskEffectManager).getMaskEffect(value);\n        this.addEffect(this._maskEffect);\n    },\n    /**\n   * Used to set mask and control mask options.\n   * @param options\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.setMask({\n   *     mask: graphics,\n   *     inverse: true,\n   * });\n   * @memberof scene.Container#\n   */ setMask (options) {\n        this._maskOptions = {\n            ...this._maskOptions,\n            ...options\n        };\n        if (options.mask) this.mask = options.mask;\n        this._markStructureAsChanged();\n    },\n    /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */ get mask () {\n        return this._maskEffect?.mask;\n    },\n    set filters (value){\n        if (!Array.isArray(value) && value) value = [\n            value\n        ];\n        const effect = this._filterEffect || (this._filterEffect = new (0, $4kixb.FilterEffect)());\n        value;\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n        const didChange = hasFilters !== hadFilters;\n        value = Array.isArray(value) ? value.slice(0) : value;\n        effect.filters = Object.freeze(value);\n        if (didChange) {\n            if (hasFilters) this.addEffect(effect);\n            else {\n                this.removeEffect(effect);\n                effect.filters = value ?? null;\n            }\n        }\n    },\n    /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */ get filters () {\n        return this._filterEffect?.filters;\n    },\n    set filterArea (value){\n        this._filterEffect || (this._filterEffect = new (0, $4kixb.FilterEffect)());\n        this._filterEffect.filterArea = value;\n    },\n    /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */ get filterArea () {\n        return this._filterEffect?.filterArea;\n    }\n};\n\n});\nparcelRegister(\"4kixb\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterEffect\", function () { return $43a253ac8857703b$export$d66c06ffe23037ab; });\n\"use strict\";\nclass $43a253ac8857703b$export$d66c06ffe23037ab {\n    constructor(){\n        /** the pipe that knows how to handle this effect */ this.pipe = \"filter\";\n        /** the priority of this effect */ this.priority = 1;\n    }\n    destroy() {\n        for(let i = 0; i < this.filters.length; i++)this.filters[i].destroy();\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n\n});\n\nparcelRegister(\"jYxJQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaskEffectManager\", function () { return $0a1a5b6c8f3dafa1$export$1eb319167fe02d04; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $dLv5L = parcelRequire(\"dLv5L\");\n\"use strict\";\nclass $0a1a5b6c8f3dafa1$export$3b0749bf144d4b29 {\n    constructor(){\n        /**\n     * @private\n     */ this._effectClasses = [];\n        this._tests = [];\n        this._initialized = false;\n    }\n    init() {\n        if (this._initialized) return;\n        this._initialized = true;\n        this._effectClasses.forEach((test)=>{\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n    add(test) {\n        this._tests.push(test);\n    }\n    getMaskEffect(item) {\n        if (!this._initialized) this.init();\n        for(let i = 0; i < this._tests.length; i++){\n            const test = this._tests[i];\n            if (test.test(item)) return (0, $dLv5L.BigPool).get(test.maskClass, item);\n        }\n        return item;\n    }\n    returnMaskEffect(effect) {\n        (0, $dLv5L.BigPool).return(effect);\n    }\n}\nconst $0a1a5b6c8f3dafa1$export$1eb319167fe02d04 = new $0a1a5b6c8f3dafa1$export$3b0749bf144d4b29();\n(0, $kFA6i.extensions).handleByList((0, $kFA6i.ExtensionType).MaskEffect, $0a1a5b6c8f3dafa1$export$1eb319167fe02d04._effectClasses);\n\n});\n\n\nparcelRegister(\"ggihy\", function(module, exports) {\n\n$parcel$export(module.exports, \"findMixin\", function () { return $f6ff4915d88a2281$export$468b0762e1bfbd64; });\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\"use strict\";\nconst $f6ff4915d88a2281$export$468b0762e1bfbd64 = {\n    /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */ label: null,\n    /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */ get name () {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Container.name property has been removed, use Container.label instead\");\n        return this.label;\n    },\n    set name (value){\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Container.name property has been removed, use Container.label instead\");\n        this.label = value;\n    },\n    /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */ getChildByName (name, deep = false) {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */ getChildByLabel (label, deep = false) {\n        const children = this.children;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.label === label || label instanceof RegExp && label.test(child.label)) return child;\n        }\n        if (deep) for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            const found = child.getChildByLabel(label, true);\n            if (found) return found;\n        }\n        return null;\n    },\n    /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */ getChildrenByLabel (label, deep = false, out = []) {\n        const children = this.children;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.label === label || label instanceof RegExp && label.test(child.label)) out.push(child);\n        }\n        if (deep) for(let i = 0; i < children.length; i++)children[i].getChildrenByLabel(label, true, out);\n        return out;\n    }\n};\n\n});\n\nparcelRegister(\"6OcmO\", function(module, exports) {\n\n$parcel$export(module.exports, \"getFastGlobalBoundsMixin\", function () { return $25c6b62480252a55$export$993f17c9646405e3; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $6cT41 = parcelRequire(\"6cT41\");\n\"use strict\";\nconst $25c6b62480252a55$var$tempMatrix = new (0, $0kbcf.Matrix)();\nconst $25c6b62480252a55$export$993f17c9646405e3 = {\n    /**\n   * Computes the global bounds for the container, considering its children and optionally\n   * factoring in render layers. It starts by clearing the provided bounds object, then\n   * recursively calculates the bounds, and finally applies the world transformation.\n   * @param {boolean} [factorRenderLayers] - Whether to consider render layers in the calculation.\n   * @param {Bounds} [bounds] - The bounds object to store the result. If not provided, a new one is created.\n   * @returns {Bounds} The computed bounds.\n   * @memberof scene.Container#\n   */ getFastGlobalBounds (factorRenderLayers, bounds) {\n        bounds || (bounds = new (0, $dtW0p.Bounds)());\n        bounds.clear();\n        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n        if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        bounds.applyMatrix(renderGroup.worldTransform);\n        return bounds;\n    },\n    /**\n   * Recursively calculates the global bounds for the container and its children.\n   * It considers visibility, measurability, and effects, and applies transformations\n   * as necessary to compute the bounds accurately.\n   * @param {boolean} factorRenderLayers - Whether to consider render layers in the calculation.\n   * @param {Bounds} bounds - The bounds object to update with the calculated values.\n   * @param {IRenderLayer} currentLayer - The current render layer being processed.\n   * @memberof scene.Container#\n   */ _getGlobalBoundsRecursive (factorRenderLayers, bounds, currentLayer) {\n        let localBounds = bounds;\n        if (factorRenderLayers && this.parentRenderLayer !== currentLayer) return;\n        if (this.localDisplayStatus !== 7 || !this.measurable) return;\n        const manageEffects = !!this.effects.length;\n        if (this.renderGroup || manageEffects) localBounds = (0, $6cT41.boundsPool).get().clear();\n        if (this.boundsArea) bounds.addRect(this.boundsArea, this.worldTransform);\n        else {\n            if (this.renderPipeId) {\n                const viewBounds = this.bounds;\n                localBounds.addFrame(viewBounds.minX, viewBounds.minY, viewBounds.maxX, viewBounds.maxY, this.groupTransform);\n            }\n            const children = this.children;\n            for(let i = 0; i < children.length; i++)children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n        }\n        if (manageEffects) {\n            let advanced = false;\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n            for(let i = 0; i < this.effects.length; i++)if (this.effects[i].addBounds) {\n                if (!advanced) {\n                    advanced = true;\n                    localBounds.applyMatrix(renderGroup.worldTransform);\n                }\n                this.effects[i].addBounds(localBounds, true);\n            }\n            if (advanced) {\n                localBounds.applyMatrix(renderGroup.worldTransform.copyTo($25c6b62480252a55$var$tempMatrix).invert());\n                bounds.addBounds(localBounds, this.relativeGroupTransform);\n            }\n            bounds.addBounds(localBounds);\n            (0, $6cT41.boundsPool).return(localBounds);\n        } else if (this.renderGroup) {\n            bounds.addBounds(localBounds, this.relativeGroupTransform);\n            (0, $6cT41.boundsPool).return(localBounds);\n        }\n    }\n};\n\n});\nparcelRegister(\"6cT41\", function(module, exports) {\n\n$parcel$export(module.exports, \"matrixPool\", function () { return $99c34bfe5b9aeddd$export$3849005ba4dacf72; });\n$parcel$export(module.exports, \"boundsPool\", function () { return $99c34bfe5b9aeddd$export$9194656040c1dc42; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $h8Jx4 = parcelRequire(\"h8Jx4\");\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\"use strict\";\nconst $99c34bfe5b9aeddd$export$3849005ba4dacf72 = new (0, $h8Jx4.Pool)((0, $0kbcf.Matrix));\nconst $99c34bfe5b9aeddd$export$9194656040c1dc42 = new (0, $h8Jx4.Pool)((0, $dtW0p.Bounds));\n\n});\n\n\nparcelRegister(\"h3CH0\", function(module, exports) {\n\n$parcel$export(module.exports, \"bgr2rgb\", function () { return $30d4b960a98e31d7$export$110f9f26b10ddb4a; });\n$parcel$export(module.exports, \"getGlobalMixin\", function () { return $30d4b960a98e31d7$export$c7c22dc0c465d95a; });\n\nvar $71eSK = parcelRequire(\"71eSK\");\n\nvar $6cT41 = parcelRequire(\"6cT41\");\n\nvar $8KIbM = parcelRequire(\"8KIbM\");\n\"use strict\";\nfunction $30d4b960a98e31d7$export$110f9f26b10ddb4a(color) {\n    return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);\n}\nconst $30d4b960a98e31d7$export$c7c22dc0c465d95a = {\n    /**\n   * Returns the global (compound) alpha of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n   *   - If true: Uses cached worldAlpha from the last render pass for better performance\n   * @returns The resulting alpha value (between 0 and 1)\n   * @example\n   * // Accurate but slower - recalculates entire alpha chain\n   * const preciseAlpha = container.getGlobalAlpha();\n   *\n   * // Faster but may be outdated - uses cached alpha\n   * const cachedAlpha = container.getGlobalAlpha(true);\n   */ getGlobalAlpha (skipUpdate) {\n        if (skipUpdate) {\n            if (this.renderGroup) return this.renderGroup.worldAlpha;\n            if (this.parentRenderGroup) return this.parentRenderGroup.worldAlpha * this.alpha;\n            return this.alpha;\n        }\n        let alpha = this.alpha;\n        let current = this.parent;\n        while(current){\n            alpha *= current.alpha;\n            current = current.parent;\n        }\n        return alpha;\n    },\n    /**\n   * Returns the global transform matrix of the container within the scene.\n   * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire transform chain for accuracy\n   *   - If true: Uses cached worldTransform from the last render pass for better performance\n   * @returns The resulting transformation matrix (either the input matrix or a new one)\n   * @example\n   * // Accurate but slower - recalculates entire transform chain\n   * const preciseTransform = container.getGlobalTransform();\n   *\n   * // Faster but may be outdated - uses cached transform\n   * const cachedTransform = container.getGlobalTransform(undefined, true);\n   *\n   * // Reuse existing matrix\n   * const existingMatrix = new Matrix();\n   * container.getGlobalTransform(existingMatrix);\n   */ getGlobalTransform (matrix, skipUpdate) {\n        if (skipUpdate) return matrix.copyFrom(this.worldTransform);\n        this.updateLocalTransform();\n        const parentTransform = (0, $71eSK.updateTransformBackwards)(this, (0, $6cT41.matrixPool).get().identity());\n        matrix.appendFrom(this.localTransform, parentTransform);\n        (0, $6cT41.matrixPool).return(parentTransform);\n        return matrix;\n    },\n    /**\n   * Returns the global (compound) tint color of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n   *   - If true: Uses cached worldColor from the last render pass for better performance\n   * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n   * @example\n   * // Accurate but slower - recalculates entire tint chain\n   * const preciseTint = container.getGlobalTint();\n   *\n   * // Faster but may be outdated - uses cached tint\n   * const cachedTint = container.getGlobalTint(true);\n   */ getGlobalTint (skipUpdate) {\n        if (skipUpdate) {\n            if (this.renderGroup) return $30d4b960a98e31d7$export$110f9f26b10ddb4a(this.renderGroup.worldColor);\n            if (this.parentRenderGroup) return $30d4b960a98e31d7$export$110f9f26b10ddb4a((0, $8KIbM.multiplyColors)(this.localColor, this.parentRenderGroup.worldColor));\n            return this.tint;\n        }\n        let color = this.localColor;\n        let parent = this.parent;\n        while(parent){\n            color = (0, $8KIbM.multiplyColors)(color, parent.localColor);\n            parent = parent.parent;\n        }\n        return $30d4b960a98e31d7$export$110f9f26b10ddb4a(color);\n    }\n};\n\n});\nparcelRegister(\"71eSK\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGlobalBounds\", function () { return $52b40ad2e47511ad$export$f4412a6981d97baa; });\n$parcel$export(module.exports, \"updateTransformBackwards\", function () { return $52b40ad2e47511ad$export$2022bc48a49dd6d2; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $6cT41 = parcelRequire(\"6cT41\");\n\"use strict\";\nfunction $52b40ad2e47511ad$export$f4412a6981d97baa(target, skipUpdateTransform, bounds) {\n    bounds.clear();\n    let parentTransform;\n    let pooledMatrix;\n    if (target.parent) {\n        if (!skipUpdateTransform) {\n            pooledMatrix = (0, $6cT41.matrixPool).get().identity();\n            parentTransform = $52b40ad2e47511ad$export$2022bc48a49dd6d2(target, pooledMatrix);\n        } else parentTransform = target.parent.worldTransform;\n    } else parentTransform = (0, $0kbcf.Matrix).IDENTITY;\n    $52b40ad2e47511ad$export$ca70956e64971628(target, bounds, parentTransform, skipUpdateTransform);\n    if (pooledMatrix) (0, $6cT41.matrixPool).return(pooledMatrix);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    return bounds;\n}\nfunction $52b40ad2e47511ad$export$ca70956e64971628(target, bounds, parentTransform, skipUpdateTransform) {\n    if (!target.visible || !target.measurable) return;\n    let worldTransform;\n    if (!skipUpdateTransform) {\n        target.updateLocalTransform();\n        worldTransform = (0, $6cT41.matrixPool).get();\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    } else worldTransform = target.worldTransform;\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n    if (preserveBounds) bounds = (0, $6cT41.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, worldTransform);\n    else {\n        if (target.bounds) {\n            bounds.matrix = worldTransform;\n            bounds.addBounds(target.bounds);\n        }\n        for(let i = 0; i < target.children.length; i++)$52b40ad2e47511ad$export$ca70956e64971628(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n    if (preserveBounds) {\n        for(let i = 0; i < target.effects.length; i++)target.effects[i].addBounds?.(bounds);\n        parentBounds.addBounds(bounds, (0, $0kbcf.Matrix).IDENTITY);\n        (0, $6cT41.boundsPool).return(bounds);\n    }\n    if (!skipUpdateTransform) (0, $6cT41.matrixPool).return(worldTransform);\n}\nfunction $52b40ad2e47511ad$export$2022bc48a49dd6d2(target, parentTransform) {\n    const parent = target.parent;\n    if (parent) {\n        $52b40ad2e47511ad$export$2022bc48a49dd6d2(parent, parentTransform);\n        parent.updateLocalTransform();\n        parentTransform.append(parent.localTransform);\n    }\n    return parentTransform;\n}\n\n});\n\nparcelRegister(\"8KIbM\", function(module, exports) {\n\n$parcel$export(module.exports, \"multiplyColors\", function () { return $c36832d976b8765d$export$a82a3ae2e3118160; });\n\nvar $goP77 = parcelRequire(\"goP77\");\n\"use strict\";\nconst $c36832d976b8765d$var$WHITE_BGR = 16777215;\nfunction $c36832d976b8765d$export$a82a3ae2e3118160(localBGRColor, parentBGRColor) {\n    if (localBGRColor === $c36832d976b8765d$var$WHITE_BGR) return parentBGRColor;\n    if (parentBGRColor === $c36832d976b8765d$var$WHITE_BGR) return localBGRColor;\n    return (0, $goP77.multiplyHexColors)(localBGRColor, parentBGRColor);\n}\n\n});\nparcelRegister(\"goP77\", function(module, exports) {\n\n$parcel$export(module.exports, \"multiplyHexColors\", function () { return $138f4e5b5df40592$export$815d7ea0395de72c; });\n\"use strict\";\nfunction $138f4e5b5df40592$export$815d7ea0395de72c(color1, color2) {\n    if (color1 === 16777215 || !color2) return color2;\n    if (color2 === 16777215 || !color1) return color1;\n    const r1 = color1 >> 16 & 255;\n    const g1 = color1 >> 8 & 255;\n    const b1 = color1 & 255;\n    const r2 = color2 >> 16 & 255;\n    const g2 = color2 >> 8 & 255;\n    const b2 = color2 & 255;\n    const r = r1 * r2 / 255 | 0;\n    const g = g1 * g2 / 255 | 0;\n    const b = b1 * b2 / 255 | 0;\n    return (r << 16) + (g << 8) + b;\n}\n\n});\n\n\n\nparcelRegister(\"cVzTv\", function(module, exports) {\n\n$parcel$export(module.exports, \"measureMixin\", function () { return $6d18ce597b58af2d$export$285e6e72e8e62f0; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $71eSK = parcelRequire(\"71eSK\");\n\nvar $4316K = parcelRequire(\"4316K\");\n\nvar $5mqu4 = parcelRequire(\"5mqu4\");\n\"use strict\";\nconst $6d18ce597b58af2d$var$tempMatrix = new (0, $0kbcf.Matrix)();\nconst $6d18ce597b58af2d$export$285e6e72e8e62f0 = {\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n    _setWidth (value, localWidth) {\n        const sign = Math.sign(this.scale.x) || 1;\n        if (localWidth !== 0) this.scale.x = value / localWidth * sign;\n        else this.scale.x = sign;\n    },\n    _setHeight (value, localHeight) {\n        const sign = Math.sign(this.scale.y) || 1;\n        if (localHeight !== 0) this.scale.y = value / localHeight * sign;\n        else this.scale.y = sign;\n    },\n    /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */ getLocalBounds () {\n        if (!this._localBoundsCacheData) this._localBoundsCacheData = {\n            data: [],\n            index: 1,\n            didChange: false,\n            localBounds: new (0, $dtW0p.Bounds)()\n        };\n        const localBoundsCacheData = this._localBoundsCacheData;\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n        if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didViewChangeTick;\n        }\n        (0, $5mqu4.checkChildrenDidChange)(this, localBoundsCacheData);\n        if (localBoundsCacheData.didChange) (0, $4316K.getLocalBounds)(this, localBoundsCacheData.localBounds, $6d18ce597b58af2d$var$tempMatrix);\n        return localBoundsCacheData.localBounds;\n    },\n    /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */ getBounds (skipUpdate, bounds) {\n        return (0, $71eSK.getGlobalBounds)(this, skipUpdate, bounds || new (0, $dtW0p.Bounds)());\n    }\n};\n\n});\nparcelRegister(\"4316K\", function(module, exports) {\n\n$parcel$export(module.exports, \"getLocalBounds\", function () { return $96a1f8bfb39ffa81$export$ffaf4f504c4c5c9c; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $6cT41 = parcelRequire(\"6cT41\");\n\"use strict\";\nfunction $96a1f8bfb39ffa81$export$ffaf4f504c4c5c9c(target, bounds, relativeMatrix) {\n    bounds.clear();\n    relativeMatrix || (relativeMatrix = (0, $0kbcf.Matrix).IDENTITY);\n    $96a1f8bfb39ffa81$var$_getLocalBounds(target, bounds, relativeMatrix, target, true);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    return bounds;\n}\nfunction $96a1f8bfb39ffa81$var$_getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n    let relativeTransform;\n    if (!isRoot) {\n        if (!target.visible || !target.measurable) return;\n        target.updateLocalTransform();\n        const localTransform = target.localTransform;\n        relativeTransform = (0, $6cT41.matrixPool).get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    } else {\n        relativeTransform = (0, $6cT41.matrixPool).get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n    if (preserveBounds) bounds = (0, $6cT41.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, relativeTransform);\n    else {\n        if (target.renderPipeId) {\n            bounds.matrix = relativeTransform;\n            bounds.addBounds(target.bounds);\n        }\n        const children = target.children;\n        for(let i = 0; i < children.length; i++)$96a1f8bfb39ffa81$var$_getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n    if (preserveBounds) {\n        for(let i = 0; i < target.effects.length; i++)target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        parentBounds.addBounds(bounds, (0, $0kbcf.Matrix).IDENTITY);\n        (0, $6cT41.boundsPool).return(bounds);\n    }\n    (0, $6cT41.matrixPool).return(relativeTransform);\n}\nfunction $96a1f8bfb39ffa81$export$58081aedf094d85b(target, root, matrix) {\n    const parent = target.parent;\n    if (!parent) {\n        (0, $c9aw6.warn)(\"Item is not inside the root container\");\n        return;\n    }\n    if (parent !== root) {\n        $96a1f8bfb39ffa81$export$58081aedf094d85b(parent, root, matrix);\n        parent.updateLocalTransform();\n        matrix.append(parent.localTransform);\n    }\n}\n\n});\nparcelRegister(\"c9aw6\", function(module, exports) {\n\n$parcel$export(module.exports, \"warn\", function () { return $11b7177c8c78d236$export$c106dd0671a0fc2d; });\n\"use strict\";\nlet $11b7177c8c78d236$var$warnCount = 0;\nconst $11b7177c8c78d236$var$maxWarnings = 500;\nfunction $11b7177c8c78d236$export$c106dd0671a0fc2d(...args) {\n    if ($11b7177c8c78d236$var$warnCount === $11b7177c8c78d236$var$maxWarnings) return;\n    $11b7177c8c78d236$var$warnCount++;\n    if ($11b7177c8c78d236$var$warnCount === $11b7177c8c78d236$var$maxWarnings) console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n    else console.warn(\"PixiJS Warning: \", ...args);\n}\n\n});\n\n\nparcelRegister(\"5mqu4\", function(module, exports) {\n\n$parcel$export(module.exports, \"checkChildrenDidChange\", function () { return $ed41ab72624317d2$export$fd5aadbd3827bcf1; });\n\"use strict\";\nfunction $ed41ab72624317d2$export$fd5aadbd3827bcf1(container, previousData) {\n    const children = container.children;\n    for(let i = 0; i < children.length; i++){\n        const child = children[i];\n        const uid = child.uid;\n        const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;\n        const index = previousData.index;\n        if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {\n            previousData.data[previousData.index] = uid;\n            previousData.data[previousData.index + 1] = didChange;\n            previousData.didChange = true;\n        }\n        previousData.index = index + 2;\n        if (child.children.length) $ed41ab72624317d2$export$fd5aadbd3827bcf1(child, previousData);\n    }\n    return previousData.didChange;\n}\n\n});\n\n\nparcelRegister(\"b7mtY\", function(module, exports) {\n\n$parcel$export(module.exports, \"onRenderMixin\", function () { return $640f79b52c3d06e9$export$2a5246d1114cb81d; });\n\"use strict\";\nconst $640f79b52c3d06e9$export$2a5246d1114cb81d = {\n    _onRender: null,\n    set onRender (func){\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (!func) {\n            if (this._onRender) renderGroup?.removeOnRender(this);\n            this._onRender = null;\n            return;\n        }\n        if (!this._onRender) renderGroup?.addOnRender(this);\n        this._onRender = func;\n    },\n    /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and \"updateTransform\" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */ get onRender () {\n        return this._onRender;\n    }\n};\n\n});\n\nparcelRegister(\"b2N3G\", function(module, exports) {\n\n$parcel$export(module.exports, \"sortMixin\", function () { return $63b0caf6b82b3b6e$export$eb4acdd9f4781aed; });\n\"use strict\";\nconst $63b0caf6b82b3b6e$export$eb4acdd9f4781aed = {\n    _zIndex: 0,\n    /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */ sortDirty: false,\n    /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */ sortableChildren: false,\n    /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */ get zIndex () {\n        return this._zIndex;\n    },\n    set zIndex (value){\n        if (this._zIndex === value) return;\n        this._zIndex = value;\n        this.depthOfChildModified();\n    },\n    depthOfChildModified () {\n        if (this.parent) {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n    },\n    /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */ sortChildren () {\n        if (!this.sortDirty) return;\n        this.sortDirty = false;\n        this.children.sort($63b0caf6b82b3b6e$var$sortChildren);\n    }\n};\nfunction $63b0caf6b82b3b6e$var$sortChildren(a, b) {\n    return a._zIndex - b._zIndex;\n}\n\n});\n\nparcelRegister(\"knQy3\", function(module, exports) {\n\n$parcel$export(module.exports, \"toLocalGlobalMixin\", function () { return $c06aeab6644a02d4$export$38fa7a987602e8dd; });\n\nvar $hbjPo = parcelRequire(\"hbjPo\");\n\nvar $6cT41 = parcelRequire(\"6cT41\");\n\"use strict\";\nconst $c06aeab6644a02d4$export$38fa7a987602e8dd = {\n    /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */ getGlobalPosition (point = new (0, $hbjPo.Point)(), skipUpdate = false) {\n        if (this.parent) this.parent.toGlobal(this._position, point, skipUpdate);\n        else {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n        return point;\n    },\n    /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */ toGlobal (position, point, skipUpdate = false) {\n        const globalMatrix = this.getGlobalTransform((0, $6cT41.matrixPool).get(), skipUpdate);\n        point = globalMatrix.apply(position, point);\n        (0, $6cT41.matrixPool).return(globalMatrix);\n        return point;\n    },\n    /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */ toLocal (position, from, point, skipUpdate) {\n        if (from) position = from.toGlobal(position, point, skipUpdate);\n        const globalMatrix = this.getGlobalTransform((0, $6cT41.matrixPool).get(), skipUpdate);\n        point = globalMatrix.applyInverse(position, point);\n        (0, $6cT41.matrixPool).return(globalMatrix);\n        return point;\n    }\n};\n\n});\n\nparcelRegister(\"2WbnL\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderGroup\", function () { return $492f7157f88f2b52$export$94d273f8d74f2a5; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $9nXu5 = parcelRequire(\"9nXu5\");\n\nvar $2zAQe = parcelRequire(\"2zAQe\");\n\"use strict\";\nclass $492f7157f88f2b52$export$94d273f8d74f2a5 {\n    constructor(){\n        this.renderPipeId = \"renderGroup\";\n        this.root = null;\n        this.canBundle = false;\n        this.renderGroupParent = null;\n        this.renderGroupChildren = [];\n        this.worldTransform = new (0, $0kbcf.Matrix)();\n        this.worldColorAlpha = 4294967295;\n        this.worldColor = 16777215;\n        this.worldAlpha = 1;\n        // these updates are transform changes..\n        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n        this.updateTick = 0;\n        this.gcTick = 0;\n        // these update are renderable changes..\n        this.childrenRenderablesToUpdate = {\n            list: [],\n            index: 0\n        };\n        // other\n        this.structureDidChange = true;\n        this.instructionSet = new (0, $9nXu5.InstructionSet)();\n        this._onRenderContainers = [];\n        /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */ this.textureNeedsUpdate = true;\n        /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */ this.isCachedAsTexture = false;\n        this._matrixDirty = 7;\n    }\n    init(root) {\n        this.root = root;\n        if (root._onRender) this.addOnRender(root);\n        root.didChange = true;\n        const children = root.children;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            child._updateFlags = 15;\n            this.addChild(child);\n        }\n    }\n    enableCacheAsTexture(options = {}) {\n        this.textureOptions = options;\n        this.isCachedAsTexture = true;\n        this.textureNeedsUpdate = true;\n    }\n    disableCacheAsTexture() {\n        this.isCachedAsTexture = false;\n        if (this.texture) {\n            (0, $2zAQe.TexturePool).returnTexture(this.texture);\n            this.texture = null;\n        }\n    }\n    updateCacheTexture() {\n        this.textureNeedsUpdate = true;\n    }\n    reset() {\n        this.renderGroupChildren.length = 0;\n        for(const i in this.childrenToUpdate){\n            const childrenAtDepth = this.childrenToUpdate[i];\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n        this.disableCacheAsTexture();\n    }\n    get localTransform() {\n        return this.root.localTransform;\n    }\n    addRenderGroupChild(renderGroupChild) {\n        if (renderGroupChild.renderGroupParent) renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        renderGroupChild.renderGroupParent = this;\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n    _removeRenderGroupChild(renderGroupChild) {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n        if (index > -1) this.renderGroupChildren.splice(index, 1);\n        renderGroupChild.renderGroupParent = null;\n    }\n    addChild(child) {\n        this.structureDidChange = true;\n        child.parentRenderGroup = this;\n        child.updateTick = -1;\n        if (child.parent === this.root) child.relativeRenderGroupDepth = 1;\n        else child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        child.didChange = true;\n        this.onChildUpdate(child);\n        if (child.renderGroup) {\n            this.addRenderGroupChild(child.renderGroup);\n            return;\n        }\n        if (child._onRender) this.addOnRender(child);\n        const children = child.children;\n        for(let i = 0; i < children.length; i++)this.addChild(children[i]);\n    }\n    removeChild(child) {\n        this.structureDidChange = true;\n        if (child._onRender) {\n            if (!child.renderGroup) this.removeOnRender(child);\n        }\n        child.parentRenderGroup = null;\n        if (child.renderGroup) {\n            this._removeRenderGroupChild(child.renderGroup);\n            return;\n        }\n        const children = child.children;\n        for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n    }\n    removeChildren(children) {\n        for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n    }\n    onChildUpdate(child) {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n        if (!childrenToUpdate) childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n            index: 0,\n            list: []\n        };\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n    updateRenderable(renderable) {\n        if (renderable.globalDisplayStatus < 7) return;\n        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n        renderable.didViewUpdate = false;\n    }\n    onChildViewUpdate(child) {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n    get isRenderable() {\n        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n    }\n    /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */ addOnRender(container) {\n        this._onRenderContainers.push(container);\n    }\n    removeOnRender(container) {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n    runOnRender(renderer) {\n        for(let i = 0; i < this._onRenderContainers.length; i++)this._onRenderContainers[i]._onRender(renderer);\n    }\n    destroy() {\n        this.disableCacheAsTexture();\n        this.renderGroupParent = null;\n        this.root = null;\n        this.childrenRenderablesToUpdate = null;\n        this.childrenToUpdate = null;\n        this.renderGroupChildren = null;\n        this._onRenderContainers = null;\n        this.instructionSet = null;\n    }\n    getChildren(out = []) {\n        const children = this.root.children;\n        for(let i = 0; i < children.length; i++)this._getChildren(children[i], out);\n        return out;\n    }\n    _getChildren(container, out = []) {\n        out.push(container);\n        if (container.renderGroup) return out;\n        const children = container.children;\n        for(let i = 0; i < children.length; i++)this._getChildren(children[i], out);\n        return out;\n    }\n    invalidateMatrices() {\n        this._matrixDirty = 7;\n    }\n    /**\n   * Returns the inverse of the world transform matrix.\n   * @returns {Matrix} The inverse of the world transform matrix.\n   */ get inverseWorldTransform() {\n        if ((this._matrixDirty & 1) === 0) return this._inverseWorldTransform;\n        this._matrixDirty &= -2;\n        this._inverseWorldTransform || (this._inverseWorldTransform = new (0, $0kbcf.Matrix)());\n        return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();\n    }\n    /**\n   * Returns the inverse of the texture offset transform matrix.\n   * @returns {Matrix} The inverse of the texture offset transform matrix.\n   */ get textureOffsetInverseTransform() {\n        if ((this._matrixDirty & 2) === 0) return this._textureOffsetInverseTransform;\n        this._matrixDirty &= -3;\n        this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new (0, $0kbcf.Matrix)());\n        return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y);\n    }\n    /**\n   * Returns the inverse of the parent texture transform matrix.\n   * This is used to properly transform coordinates when rendering into cached textures.\n   * @returns {Matrix} The inverse of the parent texture transform matrix.\n   */ get inverseParentTextureTransform() {\n        if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;\n        this._matrixDirty &= -5;\n        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n        if (parentCacheAsTexture) {\n            this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new (0, $0kbcf.Matrix)());\n            return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(-parentCacheAsTexture._textureBounds.x, -parentCacheAsTexture._textureBounds.y);\n        }\n        return this.worldTransform;\n    }\n    /**\n   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n   * or null if no parent is cached as texture.\n   */ get cacheToLocalTransform() {\n        if (!this._parentCacheAsTextureRenderGroup) return null;\n        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n    }\n}\n\n});\nparcelRegister(\"9nXu5\", function(module, exports) {\n\n$parcel$export(module.exports, \"InstructionSet\", function () { return $fb419862fbc6d473$export$2946bd01f10dd922; });\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\"use strict\";\nclass $fb419862fbc6d473$export$2946bd01f10dd922 {\n    constructor(){\n        /** a unique id for this instruction set used through the renderer */ this.uid = (0, $fTJzX.uid)(\"instructionSet\");\n        /** the array of instructions */ this.instructions = [];\n        /** the actual size of the array (any instructions passed this should be ignored) */ this.instructionSize = 0;\n        this.renderables = [];\n        /** used by the garbage collector to track when the instruction set was last used */ this.gcTick = 0;\n    }\n    /** reset the instruction set so it can be reused set size back to 0 */ reset() {\n        this.instructionSize = 0;\n    }\n    /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */ add(instruction) {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n    /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */ log() {\n        this.instructions.length = this.instructionSize;\n        console.table(this.instructions, [\n            \"type\",\n            \"action\"\n        ]);\n    }\n}\n\n});\n\nparcelRegister(\"2zAQe\", function(module, exports) {\n\n$parcel$export(module.exports, \"TexturePool\", function () { return $42bc20cf880db7b3$export$686d8ddcd5ee6cd2; });\n\nvar $7qPGY = parcelRequire(\"7qPGY\");\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\"use strict\";\nlet $42bc20cf880db7b3$var$count = 0;\nclass $42bc20cf880db7b3$export$f5c6a2d8ed21d1d {\n    /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */ constructor(textureOptions){\n        this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n    /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */ createTexture(pixelWidth, pixelHeight, antialias) {\n        const textureSource = new (0, $3dWsL.TextureSource)({\n            ...this.textureOptions,\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias: antialias,\n            autoGarbageCollect: false\n        });\n        return new (0, $4YnyE.Texture)({\n            source: textureSource,\n            label: `texturePool_${$42bc20cf880db7b3$var$count++}`\n        });\n    }\n    /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */ getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n        po2Width = (0, $7qPGY.nextPow2)(po2Width);\n        po2Height = (0, $7qPGY.nextPow2)(po2Height);\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n        if (!this._texturePool[key]) this._texturePool[key] = [];\n        let texture = this._texturePool[key].pop();\n        if (!texture) texture = this.createTexture(po2Width, po2Height, antialias);\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n        texture.updateUvs();\n        this._poolKeyHash[texture.uid] = key;\n        return texture;\n    }\n    /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */ getSameSizeTexture(texture, antialias = false) {\n        const source = texture.source;\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n    /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */ returnTexture(renderTexture) {\n        const key = this._poolKeyHash[renderTexture.uid];\n        this._texturePool[key].push(renderTexture);\n    }\n    /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */ clear(destroyTextures) {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures) for(const i in this._texturePool){\n            const textures = this._texturePool[i];\n            if (textures) for(let j = 0; j < textures.length; j++)textures[j].destroy(true);\n        }\n        this._texturePool = {};\n    }\n}\nconst $42bc20cf880db7b3$export$686d8ddcd5ee6cd2 = new $42bc20cf880db7b3$export$f5c6a2d8ed21d1d();\n\n});\n\n\nparcelRegister(\"eSqzB\", function(module, exports) {\n\n$parcel$export(module.exports, \"assignWithIgnore\", function () { return $4387f8955fa34540$export$59d0441a278e5935; });\n\"use strict\";\nfunction $4387f8955fa34540$export$59d0441a278e5935(target, options, ignore = {}) {\n    for(const key in options)if (!ignore[key] && options[key] !== void 0) target[key] = options[key];\n}\n\n});\n\n\n\n\nparcelRegister(\"7tYoJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"addMaskBounds\", function () { return $c7cd9b90cecfc44d$export$12af48852c6ac574; });\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $71eSK = parcelRequire(\"71eSK\");\n\"use strict\";\nconst $c7cd9b90cecfc44d$var$tempBounds = new (0, $dtW0p.Bounds)();\nfunction $c7cd9b90cecfc44d$export$12af48852c6ac574(mask, bounds, skipUpdateTransform) {\n    const boundsToMask = $c7cd9b90cecfc44d$var$tempBounds;\n    mask.measurable = true;\n    (0, $71eSK.getGlobalBounds)(mask, skipUpdateTransform, boundsToMask);\n    bounds.addBoundsMask(boundsToMask);\n    mask.measurable = false;\n}\n\n});\n\nparcelRegister(\"ey5hm\", function(module, exports) {\n\n$parcel$export(module.exports, \"addMaskLocalBounds\", function () { return $a634088f289c5bfb$export$7416ac774b1f1a33; });\n\nvar $4316K = parcelRequire(\"4316K\");\n\nvar $6cT41 = parcelRequire(\"6cT41\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\"use strict\";\nfunction $a634088f289c5bfb$export$7416ac774b1f1a33(mask, bounds, localRoot) {\n    const boundsToMask = (0, $6cT41.boundsPool).get();\n    mask.measurable = true;\n    const tempMatrix = (0, $6cT41.matrixPool).get().identity();\n    const relativeMask = $a634088f289c5bfb$export$1536bde1a0bf3cb9(mask, localRoot, tempMatrix);\n    (0, $4316K.getLocalBounds)(mask, boundsToMask, relativeMask);\n    mask.measurable = false;\n    bounds.addBoundsMask(boundsToMask);\n    (0, $6cT41.matrixPool).return(tempMatrix);\n    (0, $6cT41.boundsPool).return(boundsToMask);\n}\nfunction $a634088f289c5bfb$export$1536bde1a0bf3cb9(target, root, matrix) {\n    if (!target) {\n        (0, $c9aw6.warn)(\"Mask bounds, renderable is not inside the root container\");\n        return matrix;\n    }\n    if (target !== root) {\n        $a634088f289c5bfb$export$1536bde1a0bf3cb9(target.parent, root, matrix);\n        target.updateLocalTransform();\n        matrix.append(target.localTransform);\n    }\n    return matrix;\n}\n\n});\n\n\nparcelRegister(\"6yBjn\", function(module, exports) {\n\n$parcel$export(module.exports, \"ColorMask\", function () { return $00b6ade177b7356f$export$1e2a2c76374c2542; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nclass $00b6ade177b7356f$export$1e2a2c76374c2542 {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"colorMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n    }\n    destroy() {}\n    static test(mask) {\n        return typeof mask === \"number\";\n    }\n}\n$00b6ade177b7356f$export$1e2a2c76374c2542.extension = (0, $kFA6i.ExtensionType).MaskEffect;\n\n});\n\nparcelRegister(\"c9Hg5\", function(module, exports) {\n\n$parcel$export(module.exports, \"StencilMask\", function () { return $72f778d04e679ab7$export$abd85894695764cb; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\n\nvar $7tYoJ = parcelRequire(\"7tYoJ\");\n\nvar $ey5hm = parcelRequire(\"ey5hm\");\n\"use strict\";\nclass $72f778d04e679ab7$export$abd85894695764cb {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"stencilMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n    reset() {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n    addBounds(bounds, skipUpdateTransform) {\n        (0, $7tYoJ.addMaskBounds)(this.mask, bounds, skipUpdateTransform);\n    }\n    addLocalBounds(bounds, localRoot) {\n        (0, $ey5hm.addMaskLocalBounds)(this.mask, bounds, localRoot);\n    }\n    containsPoint(point, hitTestFn) {\n        const mask = this.mask;\n        return hitTestFn(mask, point);\n    }\n    destroy() {\n        this.reset();\n    }\n    static test(mask) {\n        return mask instanceof (0, $gRXu9.Container);\n    }\n}\n$72f778d04e679ab7$export$abd85894695764cb.extension = (0, $kFA6i.ExtensionType).MaskEffect;\n\n});\n\nparcelRegister(\"9HCqA\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasSource\", function () { return $10fc6e11e1e5c557$export$ca65ccf5708c6a0c; });\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\"use strict\";\nclass $10fc6e11e1e5c557$export$ca65ccf5708c6a0c extends (0, $3dWsL.TextureSource) {\n    constructor(options){\n        if (!options.resource) options.resource = (0, $d0V4H.DOMAdapter).get().createCanvas();\n        if (!options.width) {\n            options.width = options.resource.width;\n            if (!options.autoDensity) options.width /= options.resolution;\n        }\n        if (!options.height) {\n            options.height = options.resource.height;\n            if (!options.autoDensity) options.height /= options.resolution;\n        }\n        super(options);\n        this.uploadMethodId = \"image\";\n        this.autoDensity = options.autoDensity;\n        this.resizeCanvas();\n        this.transparent = !!options.transparent;\n    }\n    resizeCanvas() {\n        if (this.autoDensity) {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n    resize(width = this.width, height = this.height, resolution = this._resolution) {\n        const didResize = super.resize(width, height, resolution);\n        if (didResize) this.resizeCanvas();\n        return didResize;\n    }\n    static test(resource) {\n        return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n    }\n    /**\n   * Returns the 2D rendering context for the canvas.\n   * Caches the context after creating it.\n   * @returns The 2D rendering context of the canvas.\n   */ get context2D() {\n        return this._context2D || (this._context2D = this.resource.getContext(\"2d\"));\n    }\n}\n$10fc6e11e1e5c557$export$ca65ccf5708c6a0c.extension = (0, $kFA6i.ExtensionType).TextureSource;\n\n});\nparcelRegister(\"d0V4H\", function(module, exports) {\n\n$parcel$export(module.exports, \"DOMAdapter\", function () { return $ddd3a207703846cf$export$d988306fa84f7b44; });\n\nvar $fR5mS = parcelRequire(\"fR5mS\");\n\"use strict\";\nlet $ddd3a207703846cf$var$currentAdapter = (0, $fR5mS.BrowserAdapter);\nconst $ddd3a207703846cf$export$d988306fa84f7b44 = {\n    /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */ get () {\n        return $ddd3a207703846cf$var$currentAdapter;\n    },\n    /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */ set (adapter) {\n        $ddd3a207703846cf$var$currentAdapter = adapter;\n    }\n};\n\n});\nparcelRegister(\"fR5mS\", function(module, exports) {\n\n$parcel$export(module.exports, \"BrowserAdapter\", function () { return $01603200690869e7$export$e467cc3399500025; });\n\"use strict\";\nconst $01603200690869e7$export$e467cc3399500025 = {\n    createCanvas: (width, height)=>{\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    },\n    getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,\n    getWebGLRenderingContext: ()=>WebGLRenderingContext,\n    getNavigator: ()=>navigator,\n    getBaseUrl: ()=>document.baseURI ?? window.location.href,\n    getFontFaceSet: ()=>document.fonts,\n    fetch: (url, options)=>fetch(url, options),\n    parseXML: (xml)=>{\n        const parser = new DOMParser();\n        return parser.parseFromString(xml, \"text/xml\");\n    }\n};\n\n});\n\n\n\nparcelRegister(\"hRHFw\", function(module, exports) {\n\n$parcel$export(module.exports, \"ImageSource\", function () { return $5fe2d0b53155b128$export$280e9a68c3ffd919; });\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\"use strict\";\nclass $5fe2d0b53155b128$export$280e9a68c3ffd919 extends (0, $3dWsL.TextureSource) {\n    constructor(options){\n        if (options.resource && globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement) {\n            const canvas = (0, $d0V4H.DOMAdapter).get().createCanvas(options.resource.width, options.resource.height);\n            const context = canvas.getContext(\"2d\");\n            context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);\n            options.resource = canvas;\n            (0, $c9aw6.warn)(\"ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.\");\n        }\n        super(options);\n        this.uploadMethodId = \"image\";\n        this.autoGarbageCollect = true;\n    }\n    static test(resource) {\n        return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;\n    }\n}\n$5fe2d0b53155b128$export$280e9a68c3ffd919.extension = (0, $kFA6i.ExtensionType).TextureSource;\n\n});\n\nparcelRegister(\"9QDRe\", function(module, exports) {\n\n$parcel$export(module.exports, \"VideoSource\", function () { return $1291ac6120483f91$export$f3a17123d80000c5; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $k3VU1 = parcelRequire(\"k3VU1\");\n\nvar $jQhdF = parcelRequire(\"jQhdF\");\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\"use strict\";\nconst $1291ac6120483f91$var$_VideoSource = class _VideoSource extends (0, $3dWsL.TextureSource) {\n    constructor(options){\n        super(options);\n        // Public\n        /** Whether or not the video is ready to play. */ this.isReady = false;\n        /** The upload method for this texture. */ this.uploadMethodId = \"video\";\n        options = {\n            ..._VideoSource.defaultOptions,\n            ...options\n        };\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n        if (options.autoLoad !== false) this.load();\n    }\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */ updateFrame() {\n        if (this.destroyed) return;\n        if (this._updateFPS) {\n            const elapsedMS = (0, $k3VU1.Ticker).shared.elapsedMS * this.resource.playbackRate;\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n        if (!this._updateFPS || this._msToNextUpdate <= 0) this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n        if (this.isValid) this.update();\n    }\n    /** Callback to update the video frame and potentially request the next frame update. */ _videoFrameRequestCallback() {\n        this.updateFrame();\n        if (this.destroyed) this._videoFrameRequestCallbackHandle = null;\n        else this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);\n    }\n    /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */ get isValid() {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n    /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */ async load() {\n        if (this._load) return this._load;\n        const source = this.resource;\n        const options = this.options;\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) source.complete = true;\n        source.addEventListener(\"play\", this._onPlayStart);\n        source.addEventListener(\"pause\", this._onPlayStop);\n        source.addEventListener(\"seeked\", this._onSeeked);\n        if (!this._isSourceReady()) {\n            if (!options.preload) source.addEventListener(\"canplay\", this._onCanPlay);\n            source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n            source.addEventListener(\"error\", this._onError, true);\n        } else this._mediaReady();\n        this.alphaMode = await (0, $jQhdF.detectVideoAlphaMode)();\n        this._load = new Promise((resolve, reject)=>{\n            if (this.isValid) resolve(this);\n            else {\n                this._resolve = resolve;\n                this._reject = reject;\n                if (options.preloadTimeoutMs !== void 0) this._preloadTimeout = setTimeout(()=>{\n                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                });\n                source.load();\n            }\n        });\n        return this._load;\n    }\n    /**\n   * Handle video error events.\n   * @param event - The error event\n   */ _onError(event) {\n        this.resource.removeEventListener(\"error\", this._onError, true);\n        this.emit(\"error\", event);\n        if (this._reject) {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n    /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */ _isSourcePlaying() {\n        const source = this.resource;\n        return !source.paused && !source.ended;\n    }\n    /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */ _isSourceReady() {\n        const source = this.resource;\n        return source.readyState > 2;\n    }\n    /** Runs the update loop when the video is ready to play. */ _onPlayStart() {\n        if (!this.isValid) this._mediaReady();\n        this._configureAutoUpdate();\n    }\n    /** Stops the update loop when a pause event is triggered. */ _onPlayStop() {\n        this._configureAutoUpdate();\n    }\n    /** Handles behavior when the video completes seeking to the current playback position. */ _onSeeked() {\n        if (this._autoUpdate && !this._isSourcePlaying()) {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n    _onCanPlay() {\n        const source = this.resource;\n        source.removeEventListener(\"canplay\", this._onCanPlay);\n        this._mediaReady();\n    }\n    _onCanPlayThrough() {\n        const source = this.resource;\n        source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n        if (this._preloadTimeout) {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = void 0;\n        }\n        this._mediaReady();\n    }\n    /** Fired when the video is loaded and ready to play. */ _mediaReady() {\n        const source = this.resource;\n        if (this.isValid) {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n        if (this._resolve) {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n        if (this._isSourcePlaying()) this._onPlayStart();\n        else if (this.autoPlay) this.resource.play();\n    }\n    /** Cleans up resources and event listeners associated with this texture. */ destroy() {\n        this._configureAutoUpdate();\n        const source = this.resource;\n        if (source) {\n            source.removeEventListener(\"play\", this._onPlayStart);\n            source.removeEventListener(\"pause\", this._onPlayStop);\n            source.removeEventListener(\"seeked\", this._onSeeked);\n            source.removeEventListener(\"canplay\", this._onCanPlay);\n            source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n            source.removeEventListener(\"error\", this._onError, true);\n            source.pause();\n            source.src = \"\";\n            source.load();\n        }\n        super.destroy();\n    }\n    /** Should the base texture automatically update itself, set to true by default. */ get autoUpdate() {\n        return this._autoUpdate;\n    }\n    set autoUpdate(value) {\n        if (value !== this._autoUpdate) {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n    /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */ get updateFPS() {\n        return this._updateFPS;\n    }\n    set updateFPS(value) {\n        if (value !== this._updateFPS) {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n    /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */ _configureAutoUpdate() {\n        if (this._autoUpdate && this._isSourcePlaying()) {\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n                if (this._isConnectedToTicker) {\n                    (0, $k3VU1.Ticker).shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    this._msToNextUpdate = 0;\n                }\n                if (this._videoFrameRequestCallbackHandle === null) this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);\n            } else {\n                if (this._videoFrameRequestCallbackHandle !== null) {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n                if (!this._isConnectedToTicker) {\n                    (0, $k3VU1.Ticker).shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    this._msToNextUpdate = 0;\n                }\n            }\n        } else {\n            if (this._videoFrameRequestCallbackHandle !== null) {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n            if (this._isConnectedToTicker) {\n                (0, $k3VU1.Ticker).shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n    static test(resource) {\n        return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;\n    }\n};\n$1291ac6120483f91$var$_VideoSource.extension = (0, $kFA6i.ExtensionType).TextureSource;\n/** The default options for video sources. */ $1291ac6120483f91$var$_VideoSource.defaultOptions = {\n    ...(0, $3dWsL.TextureSource).defaultOptions,\n    /** If true, the video will start loading immediately. */ autoLoad: true,\n    /** If true, the video will start playing as soon as it is loaded. */ autoPlay: true,\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */ updateFPS: 0,\n    /** If true, the video will be loaded with the `crossorigin` attribute. */ crossorigin: true,\n    /** If true, the video will loop when it ends. */ loop: false,\n    /** If true, the video will be muted. */ muted: true,\n    /** If true, the video will play inline. */ playsinline: true,\n    /** If true, the video will be preloaded. */ preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */ $1291ac6120483f91$var$_VideoSource.MIME_TYPES = {\n    ogv: \"video/ogg\",\n    mov: \"video/quicktime\",\n    m4v: \"video/mp4\"\n};\nlet $1291ac6120483f91$export$f3a17123d80000c5 = $1291ac6120483f91$var$_VideoSource;\n\n});\nparcelRegister(\"k3VU1\", function(module, exports) {\n\n$parcel$export(module.exports, \"Ticker\", function () { return $bc96cdd8749a7803$export$39c54bcc89dcee11; });\n\nvar $dqvqc = parcelRequire(\"dqvqc\");\n\nvar $gsmTo = parcelRequire(\"gsmTo\");\n\"use strict\";\nconst $bc96cdd8749a7803$var$_Ticker = class _Ticker {\n    constructor(){\n        /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */ this.autoStart = false;\n        /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */ this.deltaTime = 1;\n        /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     */ this.lastTime = -1;\n        /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */ this.speed = 1;\n        /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */ this.started = false;\n        /** Internal current frame request ID */ this._requestId = null;\n        /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */ this._maxElapsedMS = 100;\n        /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */ this._minElapsedMS = 0;\n        /** If enabled, deleting is disabled.*/ this._protected = false;\n        /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */ this._lastFrame = -1;\n        this._head = new (0, $gsmTo.TickerListener)(null, null, Infinity);\n        this.deltaMS = 1 / _Ticker.targetFPMS;\n        this.elapsedMS = 1 / _Ticker.targetFPMS;\n        this._tick = (time)=>{\n            this._requestId = null;\n            if (this.started) {\n                this.update(time);\n                if (this.started && this._requestId === null && this._head.next) this._requestId = requestAnimationFrame(this._tick);\n            }\n        };\n    }\n    /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */ _requestIfNeeded() {\n        if (this._requestId === null && this._head.next) {\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n    /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */ _cancelIfNeeded() {\n        if (this._requestId !== null) {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n    /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */ _startIfPossible() {\n        if (this.started) this._requestIfNeeded();\n        else if (this.autoStart) this.start();\n    }\n    /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */ add(fn, context, priority = (0, $dqvqc.UPDATE_PRIORITY).NORMAL) {\n        return this._addListener(new (0, $gsmTo.TickerListener)(fn, context, priority));\n    }\n    /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */ addOnce(fn, context, priority = (0, $dqvqc.UPDATE_PRIORITY).NORMAL) {\n        return this._addListener(new (0, $gsmTo.TickerListener)(fn, context, priority, true));\n    }\n    /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */ _addListener(listener) {\n        let current = this._head.next;\n        let previous = this._head;\n        if (!current) listener.connect(previous);\n        else {\n            while(current){\n                if (listener.priority > current.priority) {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n            if (!listener.previous) listener.connect(previous);\n        }\n        this._startIfPossible();\n        return this;\n    }\n    /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */ remove(fn, context) {\n        let listener = this._head.next;\n        while(listener)if (listener.match(fn, context)) listener = listener.destroy();\n        else listener = listener.next;\n        if (!this._head.next) this._cancelIfNeeded();\n        return this;\n    }\n    /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */ get count() {\n        if (!this._head) return 0;\n        let count = 0;\n        let current = this._head;\n        while(current = current.next)count++;\n        return count;\n    }\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */ start() {\n        if (!this.started) {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */ stop() {\n        if (this.started) {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */ destroy() {\n        if (!this._protected) {\n            this.stop();\n            let listener = this._head.next;\n            while(listener)listener = listener.destroy(true);\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n    /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */ update(currentTime = performance.now()) {\n        let elapsedMS;\n        if (currentTime > this.lastTime) {\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n            if (elapsedMS > this._maxElapsedMS) elapsedMS = this._maxElapsedMS;\n            elapsedMS *= this.speed;\n            if (this._minElapsedMS) {\n                const delta = currentTime - this._lastFrame | 0;\n                if (delta < this._minElapsedMS) return;\n                this._lastFrame = currentTime - delta % this._minElapsedMS;\n            }\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n            const head = this._head;\n            let listener = head.next;\n            while(listener)listener = listener.emit(this);\n            if (!head.next) this._cancelIfNeeded();\n        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        this.lastTime = currentTime;\n    }\n    /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */ get FPS() {\n        return 1e3 / this.elapsedMS;\n    }\n    /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */ get minFPS() {\n        return 1e3 / this._maxElapsedMS;\n    }\n    set minFPS(fps) {\n        const minFPS = Math.min(this.maxFPS, fps);\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n    /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */ get maxFPS() {\n        if (this._minElapsedMS) return Math.round(1e3 / this._minElapsedMS);\n        return 0;\n    }\n    set maxFPS(fps) {\n        if (fps === 0) this._minElapsedMS = 0;\n        else {\n            const maxFPS = Math.max(this.minFPS, fps);\n            this._minElapsedMS = 1 / (maxFPS / 1e3);\n        }\n    }\n    /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */ static get shared() {\n        if (!_Ticker._shared) {\n            const shared = _Ticker._shared = new _Ticker();\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n        return _Ticker._shared;\n    }\n    /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */ static get system() {\n        if (!_Ticker._system) {\n            const system = _Ticker._system = new _Ticker();\n            system.autoStart = true;\n            system._protected = true;\n        }\n        return _Ticker._system;\n    }\n};\n/**\n * Target frames per millisecond.\n * @static\n */ $bc96cdd8749a7803$var$_Ticker.targetFPMS = 0.06;\nlet $bc96cdd8749a7803$export$39c54bcc89dcee11 = $bc96cdd8749a7803$var$_Ticker;\n\n});\nparcelRegister(\"dqvqc\", function(module, exports) {\n\n$parcel$export(module.exports, \"UPDATE_PRIORITY\", function () { return $31c5039e1c9d5112$export$688aaf132ba9b379; });\n\"use strict\";\nvar $31c5039e1c9d5112$export$688aaf132ba9b379 = /* @__PURE__ */ ((UPDATE_PRIORITY2)=>{\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n    return UPDATE_PRIORITY2;\n})($31c5039e1c9d5112$export$688aaf132ba9b379 || {});\n\n});\n\nparcelRegister(\"gsmTo\", function(module, exports) {\n\n$parcel$export(module.exports, \"TickerListener\", function () { return $a0729dc3dd2f4c84$export$579021a5759a260f; });\n\"use strict\";\nclass $a0729dc3dd2f4c84$export$579021a5759a260f {\n    /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */ constructor(fn, context = null, priority = 0, once = false){\n        /** The next item in chain. */ this.next = null;\n        /** The previous item in chain. */ this.previous = null;\n        /** `true` if this listener has been destroyed already. */ this._destroyed = false;\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n    /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */ match(fn, context = null) {\n        return this._fn === fn && this._context === context;\n    }\n    /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */ emit(ticker) {\n        if (this._fn) {\n            if (this._context) this._fn.call(this._context, ticker);\n            else this._fn(ticker);\n        }\n        const redirect = this.next;\n        if (this._once) this.destroy(true);\n        if (this._destroyed) this.next = null;\n        return redirect;\n    }\n    /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */ connect(previous) {\n        this.previous = previous;\n        if (previous.next) previous.next.previous = this;\n        this.next = previous.next;\n        previous.next = this;\n    }\n    /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */ destroy(hard = false) {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n        if (this.previous) this.previous.next = this.next;\n        if (this.next) this.next.previous = this.previous;\n        const redirect = this.next;\n        this.next = hard ? null : redirect;\n        this.previous = null;\n        return redirect;\n    }\n}\n\n});\n\n\nparcelRegister(\"jQhdF\", function(module, exports) {\n\n$parcel$export(module.exports, \"detectVideoAlphaMode\", function () { return $0a777883e8dc2369$export$8df68d58aae31877; });\n\"use strict\";\nlet $0a777883e8dc2369$var$promise;\nasync function $0a777883e8dc2369$export$8df68d58aae31877() {\n    $0a777883e8dc2369$var$promise ?? ($0a777883e8dc2369$var$promise = (async ()=>{\n        const canvas = document.createElement(\"canvas\");\n        const gl = canvas.getContext(\"webgl\");\n        if (!gl) return \"premultiply-alpha-on-upload\";\n        const video = await new Promise((resolve)=>{\n            const video2 = document.createElement(\"video\");\n            video2.onloadeddata = ()=>resolve(video2);\n            video2.onerror = ()=>resolve(null);\n            video2.autoplay = false;\n            video2.crossOrigin = \"anonymous\";\n            video2.preload = \"auto\";\n            video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n            video2.load();\n        });\n        if (!video) return \"premultiply-alpha-on-upload\";\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        const framebuffer = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n        const pixel = new Uint8Array(4);\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n    })());\n    return $0a777883e8dc2369$var$promise;\n}\n\n});\n\n\nparcelRegister(\"9ErZc\", function(module, exports) {\n\nvar $6n8as = parcelRequire(\"6n8as\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $3dWsL = parcelRequire(\"3dWsL\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\"use strict\";\nconst $bd3dd523c9bd39bd$var$sources = [];\n(0, $kFA6i.extensions).handleByList((0, $kFA6i.ExtensionType).TextureSource, $bd3dd523c9bd39bd$var$sources);\nfunction $bd3dd523c9bd39bd$export$688bcf31fbf7eb15(options = {}) {\n    return $bd3dd523c9bd39bd$var$textureSourceFrom(options);\n}\nfunction $bd3dd523c9bd39bd$var$textureSourceFrom(options = {}) {\n    const hasResource = options && options.resource;\n    const res = hasResource ? options.resource : options;\n    const opts = hasResource ? options : {\n        resource: options\n    };\n    for(let i = 0; i < $bd3dd523c9bd39bd$var$sources.length; i++){\n        const Source = $bd3dd523c9bd39bd$var$sources[i];\n        if (Source.test(res)) return new Source(opts);\n    }\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction $bd3dd523c9bd39bd$export$3b748ed6327ec85b(options = {}, skipCache = false) {\n    const hasResource = options && options.resource;\n    const resource = hasResource ? options.resource : options;\n    const opts = hasResource ? options : {\n        resource: options\n    };\n    if (!skipCache && (0, $6n8as.Cache).has(resource)) return (0, $6n8as.Cache).get(resource);\n    const texture = new (0, $4YnyE.Texture)({\n        source: $bd3dd523c9bd39bd$var$textureSourceFrom(opts)\n    });\n    texture.on(\"destroy\", ()=>{\n        if ((0, $6n8as.Cache).has(resource)) (0, $6n8as.Cache).remove(resource);\n    });\n    if (!skipCache) (0, $6n8as.Cache).set(resource, texture);\n    return texture;\n}\nfunction $bd3dd523c9bd39bd$export$4266177d9730bb1(id, skipCache = false) {\n    if (typeof id === \"string\") return (0, $6n8as.Cache).get(id);\n    else if (id instanceof (0, $3dWsL.TextureSource)) return new (0, $4YnyE.Texture)({\n        source: id\n    });\n    return $bd3dd523c9bd39bd$export$3b748ed6327ec85b(id, skipCache);\n}\n(0, $4YnyE.Texture).from = $bd3dd523c9bd39bd$export$4266177d9730bb1;\n(0, $3dWsL.TextureSource).from = $bd3dd523c9bd39bd$var$textureSourceFrom;\n\n});\nparcelRegister(\"6n8as\", function(module, exports) {\n\n$parcel$export(module.exports, \"Cache\", function () { return $5e185831a7060818$export$94affb487e701bf2; });\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $anknw = parcelRequire(\"anknw\");\n\"use strict\";\nclass $5e185831a7060818$var$CacheClass {\n    constructor(){\n        this._parsers = [];\n        this._cache = /* @__PURE__ */ new Map();\n        this._cacheMap = /* @__PURE__ */ new Map();\n    }\n    /** Clear all entries. */ reset() {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n    /**\n   * Check if the key exists\n   * @param key - The key to check\n   */ has(key) {\n        return this._cache.has(key);\n    }\n    /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */ get(key) {\n        const result = this._cache.get(key);\n        if (!result) (0, $c9aw6.warn)(`[Assets] Asset id ${key} was not found in the Cache`);\n        return result;\n    }\n    /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */ set(key, value) {\n        const keys = (0, $anknw.convertToList)(key);\n        let cacheableAssets;\n        for(let i = 0; i < this.parsers.length; i++){\n            const parser = this.parsers[i];\n            if (parser.test(value)) {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n                break;\n            }\n        }\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n        if (!cacheableAssets) keys.forEach((key2)=>{\n            cacheableMap.set(key2, value);\n        });\n        const cacheKeys = [\n            ...cacheableMap.keys()\n        ];\n        const cachedAssets = {\n            cacheKeys: cacheKeys,\n            keys: keys\n        };\n        keys.forEach((key2)=>{\n            this._cacheMap.set(key2, cachedAssets);\n        });\n        cacheKeys.forEach((key2)=>{\n            const val = cacheableAssets ? cacheableAssets[key2] : value;\n            if (this._cache.has(key2) && this._cache.get(key2) !== val) (0, $c9aw6.warn)(\"[Cache] already has key:\", key2);\n            this._cache.set(key2, cacheableMap.get(key2));\n        });\n    }\n    /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */ remove(key) {\n        if (!this._cacheMap.has(key)) {\n            (0, $c9aw6.warn)(`[Assets] Asset id ${key} was not found in the Cache`);\n            return;\n        }\n        const cacheMap = this._cacheMap.get(key);\n        const cacheKeys = cacheMap.cacheKeys;\n        cacheKeys.forEach((key2)=>{\n            this._cache.delete(key2);\n        });\n        cacheMap.keys.forEach((key2)=>{\n            this._cacheMap.delete(key2);\n        });\n    }\n    /** All loader parsers registered */ get parsers() {\n        return this._parsers;\n    }\n}\nconst $5e185831a7060818$export$94affb487e701bf2 = new $5e185831a7060818$var$CacheClass();\n\n});\nparcelRegister(\"anknw\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertToList\", function () { return $9e74290aa41ef06d$export$b01be8e180bf3d9b; });\n\"use strict\";\nconst $9e74290aa41ef06d$export$b01be8e180bf3d9b = (input, transform, forceTransform = false)=>{\n    if (!Array.isArray(input)) input = [\n        input\n    ];\n    if (!transform) return input;\n    return input.map((item)=>{\n        if (typeof item === \"string\" || forceTransform) return transform(item);\n        return item;\n    });\n};\n\n});\n\n\n\n\nparcelRegister(\"cqGna\", function(module, exports) {\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $a9cWg = parcelRequire(\"a9cWg\");\n\"use strict\";\n(0, $kFA6i.extensions).add((0, $a9cWg.spritesheetAsset));\n\n});\nparcelRegister(\"a9cWg\", function(module, exports) {\n\n$parcel$export(module.exports, \"spritesheetAsset\", function () { return $4eef9ce476ca77e7$export$46dcda4f1cdd80fe; });\n\nvar $4Gouu = parcelRequire(\"4Gouu\");\n\nvar $em7uH = parcelRequire(\"em7uH\");\n\nvar $abXd6 = parcelRequire(\"abXd6\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $gOHW1 = parcelRequire(\"gOHW1\");\n\nvar $dvQOG = parcelRequire(\"dvQOG\");\n\"use strict\";\nconst $4eef9ce476ca77e7$var$validImages = [\n    \"jpg\",\n    \"png\",\n    \"jpeg\",\n    \"avif\",\n    \"webp\",\n    \"basis\",\n    \"etc2\",\n    \"bc7\",\n    \"bc6h\",\n    \"bc5\",\n    \"bc4\",\n    \"bc3\",\n    \"bc2\",\n    \"bc1\",\n    \"eac\",\n    \"astc\"\n];\nfunction $4eef9ce476ca77e7$var$getCacheableAssets(keys, asset, ignoreMultiPack) {\n    const out = {};\n    keys.forEach((key)=>{\n        out[key] = asset;\n    });\n    Object.keys(asset.textures).forEach((key)=>{\n        out[key] = asset.textures[key];\n    });\n    if (!ignoreMultiPack) {\n        const basePath = (0, $gOHW1.path).dirname(keys[0]);\n        asset.linkedSheets.forEach((item, i)=>{\n            const out2 = $4eef9ce476ca77e7$var$getCacheableAssets([\n                `${basePath}/${asset.data.meta.related_multi_packs[i]}`\n            ], item, true);\n            Object.assign(out, out2);\n        });\n    }\n    return out;\n}\nconst $4eef9ce476ca77e7$export$46dcda4f1cdd80fe = {\n    extension: (0, $kFA6i.ExtensionType).Asset,\n    /** Handle the caching of the related Spritesheet Textures */ cache: {\n        test: (asset)=>asset instanceof (0, $dvQOG.Spritesheet),\n        getCacheableAssets: (keys, asset)=>$4eef9ce476ca77e7$var$getCacheableAssets(keys, asset, false)\n    },\n    /** Resolve the resolution of the asset. */ resolver: {\n        extension: {\n            type: (0, $kFA6i.ExtensionType).ResolveParser,\n            name: \"resolveSpritesheet\"\n        },\n        test: (value)=>{\n            const tempURL = value.split(\"?\")[0];\n            const split = tempURL.split(\".\");\n            const extension = split.pop();\n            const format = split.pop();\n            return extension === \"json\" && $4eef9ce476ca77e7$var$validImages.includes(format);\n        },\n        parse: (value)=>{\n            const split = value.split(\".\");\n            return {\n                resolution: parseFloat((0, $em7uH.Resolver).RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n                format: split[split.length - 2],\n                src: value\n            };\n        }\n    },\n    /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */ loader: {\n        name: \"spritesheetLoader\",\n        extension: {\n            type: (0, $kFA6i.ExtensionType).LoadParser,\n            priority: (0, $4Gouu.LoaderParserPriority).Normal,\n            name: \"spritesheetLoader\"\n        },\n        async testParse (asset, options) {\n            return (0, $gOHW1.path).extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n        },\n        async parse (asset, options, loader) {\n            const { texture: imageTexture, imageFilename: // if user need to use preloaded texture\n            imageFilename, textureOptions: // if user need to use custom filename (not from jsonFile.meta.image)\n            textureOptions } = options?.data ?? {};\n            let basePath = (0, $gOHW1.path).dirname(options.src);\n            if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) basePath += \"/\";\n            let texture;\n            if (imageTexture instanceof (0, $4YnyE.Texture)) texture = imageTexture;\n            else {\n                const imagePath = (0, $abXd6.copySearchParams)(basePath + (imageFilename ?? asset.meta.image), options.src);\n                const assets = await loader.load([\n                    {\n                        src: imagePath,\n                        data: textureOptions\n                    }\n                ]);\n                texture = assets[imagePath];\n            }\n            const spritesheet = new (0, $dvQOG.Spritesheet)(texture.source, asset);\n            await spritesheet.parse();\n            const multiPacks = asset?.meta?.related_multi_packs;\n            if (Array.isArray(multiPacks)) {\n                const promises = [];\n                for (const item of multiPacks){\n                    if (typeof item !== \"string\") continue;\n                    let itemUrl = basePath + item;\n                    if (options.data?.ignoreMultiPack) continue;\n                    itemUrl = (0, $abXd6.copySearchParams)(itemUrl, options.src);\n                    promises.push(loader.load({\n                        src: itemUrl,\n                        data: {\n                            ignoreMultiPack: true\n                        }\n                    }));\n                }\n                const res = await Promise.all(promises);\n                spritesheet.linkedSheets = res;\n                res.forEach((item)=>{\n                    item.linkedSheets = [\n                        spritesheet\n                    ].concat(spritesheet.linkedSheets.filter((sp)=>sp !== item));\n                });\n            }\n            return spritesheet;\n        },\n        async unload (spritesheet, _resolvedAsset, loader) {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n            spritesheet.destroy(false);\n        }\n    }\n};\n\n});\nparcelRegister(\"4Gouu\", function(module, exports) {\n\n$parcel$export(module.exports, \"LoaderParserPriority\", function () { return $98c7bf0715e5eba0$export$820ed6348c4f2750; });\n\"use strict\";\nvar $98c7bf0715e5eba0$export$820ed6348c4f2750 = /* @__PURE__ */ ((LoaderParserPriority2)=>{\n    LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n    LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n    LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n    return LoaderParserPriority2;\n})($98c7bf0715e5eba0$export$820ed6348c4f2750 || {});\n\n});\n\nparcelRegister(\"em7uH\", function(module, exports) {\n\n$parcel$export(module.exports, \"Resolver\", function () { return $18afcceb16531a4f$export$8b4c839865b08288; });\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $gOHW1 = parcelRequire(\"gOHW1\");\n\nvar $anknw = parcelRequire(\"anknw\");\n\nvar $c284d = parcelRequire(\"c284d\");\n\nvar $bBvqO = parcelRequire(\"bBvqO\");\n\"use strict\";\nclass $18afcceb16531a4f$export$8b4c839865b08288 {\n    constructor(){\n        this._defaultBundleIdentifierOptions = {\n            connector: \"-\",\n            createBundleAssetId: (bundleId, assetId)=>`${bundleId}${this._bundleIdConnector}${assetId}`,\n            extractAssetIdFromBundle: (bundleId, assetBundleId)=>assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n        };\n        /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */ this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n        /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */ this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n        /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */ this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n        this._assetMap = {};\n        this._preferredOrder = [];\n        this._parsers = [];\n        this._resolverHash = {};\n        this._bundles = {};\n    }\n    /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */ setBundleIdentifier(bundleIdentifier) {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n        if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n    /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */ prefer(...preferOrders) {\n        preferOrders.forEach((prefer)=>{\n            this._preferredOrder.push(prefer);\n            if (!prefer.priority) prefer.priority = Object.keys(prefer.params);\n        });\n        this._resolverHash = {};\n    }\n    /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */ set basePath(basePath) {\n        this._basePath = basePath;\n    }\n    get basePath() {\n        return this._basePath;\n    }\n    /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */ set rootPath(rootPath) {\n        this._rootPath = rootPath;\n    }\n    get rootPath() {\n        return this._rootPath;\n    }\n    /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */ get parsers() {\n        return this._parsers;\n    }\n    /** Used for testing, this resets the resolver to its initial state */ reset() {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n        this._assetMap = {};\n        this._preferredOrder = [];\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n    /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */ setDefaultSearchParams(searchParams) {\n        if (typeof searchParams === \"string\") this._defaultSearchParams = searchParams;\n        else {\n            const queryValues = searchParams;\n            this._defaultSearchParams = Object.keys(queryValues).map((key)=>`${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n        }\n    }\n    /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */ getAlias(asset) {\n        const { alias: alias, src: src } = asset;\n        const aliasesToUse = (0, $anknw.convertToList)(alias || src, (value)=>{\n            if (typeof value === \"string\") return value;\n            if (Array.isArray(value)) return value.map((v)=>v?.src ?? v);\n            if (value?.src) return value.src;\n            return value;\n        }, true);\n        return aliasesToUse;\n    }\n    /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */ addManifest(manifest) {\n        if (this._manifest) (0, $c9aw6.warn)(\"[Resolver] Manifest already exists, this will be overwritten\");\n        this._manifest = manifest;\n        manifest.bundles.forEach((bundle)=>{\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n    /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */ addBundle(bundleId, assets) {\n        const assetNames = [];\n        let convertedAssets = assets;\n        if (!Array.isArray(assets)) convertedAssets = Object.entries(assets).map(([alias, src])=>{\n            if (typeof src === \"string\" || Array.isArray(src)) return {\n                alias: alias,\n                src: src\n            };\n            return {\n                alias: alias,\n                ...src\n            };\n        });\n        convertedAssets.forEach((asset)=>{\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids;\n            if (typeof aliases === \"string\") {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n                assetNames.push(bundleAssetId);\n                ids = [\n                    aliases,\n                    bundleAssetId\n                ];\n            } else {\n                const bundleIds = aliases.map((name)=>this._createBundleAssetId(bundleId, name));\n                assetNames.push(...bundleIds);\n                ids = [\n                    ...aliases,\n                    ...bundleIds\n                ];\n            }\n            this.add({\n                ...asset,\n                alias: ids,\n                src: srcs\n            });\n        });\n        this._bundles[bundleId] = assetNames;\n    }\n    /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */ add(aliases) {\n        const assets = [];\n        if (Array.isArray(aliases)) assets.push(...aliases);\n        else assets.push(aliases);\n        let keyCheck;\n        keyCheck = (key)=>{\n            if (this.hasKey(key)) (0, $c9aw6.warn)(`[Resolver] already has key: ${key} overwriting`);\n        };\n        const assetArray = (0, $anknw.convertToList)(assets);\n        assetArray.forEach((asset)=>{\n            const { src: src } = asset;\n            let { data: data, format: format, loadParser: loadParser } = asset;\n            const srcsToUse = (0, $anknw.convertToList)(src).map((src2)=>{\n                if (typeof src2 === \"string\") return (0, $c284d.createStringVariations)(src2);\n                return Array.isArray(src2) ? src2 : [\n                    src2\n                ];\n            });\n            const aliasesToUse = this.getAlias(asset);\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            const resolvedAssets = [];\n            srcsToUse.forEach((srcs)=>{\n                srcs.forEach((src2)=>{\n                    let formattedAsset = {};\n                    if (typeof src2 !== \"object\") {\n                        formattedAsset.src = src2;\n                        for(let i = 0; i < this._parsers.length; i++){\n                            const parser = this._parsers[i];\n                            if (parser.test(src2)) {\n                                formattedAsset = parser.parse(src2);\n                                break;\n                            }\n                        }\n                    } else {\n                        data = src2.data ?? data;\n                        format = src2.format ?? format;\n                        loadParser = src2.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src2\n                        };\n                    }\n                    if (!aliasesToUse) throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data: data,\n                        format: format,\n                        loadParser: loadParser\n                    });\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n            aliasesToUse.forEach((alias)=>{\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n    // TODO: this needs an overload like load did in Assets\n    /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */ resolveBundle(bundleIds) {\n        const singleAsset = (0, $bBvqO.isSingleItem)(bundleIds);\n        bundleIds = (0, $anknw.convertToList)(bundleIds);\n        const out = {};\n        bundleIds.forEach((bundleId)=>{\n            const assetNames = this._bundles[bundleId];\n            if (assetNames) {\n                const results = this.resolve(assetNames);\n                const assets = {};\n                for(const key in results){\n                    const asset = results[key];\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n                out[bundleId] = assets;\n            }\n        });\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n    /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */ resolveUrl(key) {\n        const result = this.resolve(key);\n        if (typeof key !== \"string\") {\n            const out = {};\n            for(const i in result)out[i] = result[i].src;\n            return out;\n        }\n        return result.src;\n    }\n    resolve(keys) {\n        const singleAsset = (0, $bBvqO.isSingleItem)(keys);\n        keys = (0, $anknw.convertToList)(keys);\n        const result = {};\n        keys.forEach((key)=>{\n            if (!this._resolverHash[key]) {\n                if (this._assetMap[key]) {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n                    preferredOrder?.priority.forEach((priorityKey)=>{\n                        preferredOrder.params[priorityKey].forEach((value)=>{\n                            const filteredAssets = assets.filter((asset)=>{\n                                if (asset[priorityKey]) return asset[priorityKey] === value;\n                                return false;\n                            });\n                            if (filteredAssets.length) assets = filteredAssets;\n                        });\n                    });\n                    this._resolverHash[key] = assets[0];\n                } else this._resolverHash[key] = this._buildResolvedAsset({\n                    alias: [\n                        key\n                    ],\n                    src: key\n                }, {});\n            }\n            result[key] = this._resolverHash[key];\n        });\n        return singleAsset ? result[keys[0]] : result;\n    }\n    /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */ hasKey(key) {\n        return !!this._assetMap[key];\n    }\n    /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */ hasBundle(key) {\n        return !!this._bundles[key];\n    }\n    /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */ _getPreferredOrder(assets) {\n        for(let i = 0; i < assets.length; i++){\n            const asset = assets[i];\n            const preferred = this._preferredOrder.find((preference)=>preference.params.format.includes(asset.format));\n            if (preferred) return preferred;\n        }\n        return this._preferredOrder[0];\n    }\n    /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */ _appendDefaultSearchParams(url) {\n        if (!this._defaultSearchParams) return url;\n        const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n    _buildResolvedAsset(formattedAsset, data) {\n        const { aliases: aliases, data: assetData, loadParser: loadParser, format: format } = data;\n        if (this._basePath || this._rootPath) formattedAsset.src = (0, $gOHW1.path).toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [\n            formattedAsset.src\n        ];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = {\n            ...assetData || {},\n            ...formattedAsset.data\n        };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? $18afcceb16531a4f$export$4bb0ea38086a2ed5(formattedAsset.src);\n        return formattedAsset;\n    }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */ $18afcceb16531a4f$export$8b4c839865b08288.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction $18afcceb16531a4f$export$4bb0ea38086a2ed5(url) {\n    return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\n});\nparcelRegister(\"gOHW1\", function(module, exports) {\n\n$parcel$export(module.exports, \"path\", function () { return $843d7bf2b54bdd7d$export$bb654e07daaf8c3a; });\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\"use strict\";\nfunction $843d7bf2b54bdd7d$var$assertPath(path2) {\n    if (typeof path2 !== \"string\") throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n}\nfunction $843d7bf2b54bdd7d$var$removeUrlParams(url) {\n    const re = url.split(\"?\")[0];\n    return re.split(\"#\")[0];\n}\nfunction $843d7bf2b54bdd7d$var$escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction $843d7bf2b54bdd7d$var$replaceAll(str, find, replace) {\n    return str.replace(new RegExp($843d7bf2b54bdd7d$var$escapeRegExp(find), \"g\"), replace);\n}\nfunction $843d7bf2b54bdd7d$var$normalizeStringPosix(path2, allowAboveRoot) {\n    let res = \"\";\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n    for(let i = 0; i <= path2.length; ++i){\n        if (i < path2.length) code = path2.charCodeAt(i);\n        else if (code === 47) break;\n        else code = 47;\n        if (code === 47) {\n            if (lastSlash === i - 1 || dots === 1) ;\n            else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(\"/\");\n                        if (lastSlashIndex !== res.length - 1) {\n                            if (lastSlashIndex === -1) {\n                                res = \"\";\n                                lastSegmentLength = 0;\n                            } else {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    } else if (res.length === 2 || res.length === 1) {\n                        res = \"\";\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0) res += \"/..\";\n                    else res = \"..\";\n                    lastSegmentLength = 2;\n                }\n            } else {\n                if (res.length > 0) res += `/${path2.slice(lastSlash + 1, i)}`;\n                else res = path2.slice(lastSlash + 1, i);\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        } else if (code === 46 && dots !== -1) ++dots;\n        else dots = -1;\n    }\n    return res;\n}\nconst $843d7bf2b54bdd7d$export$bb654e07daaf8c3a = {\n    /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */ toPosix (path2) {\n        return $843d7bf2b54bdd7d$var$replaceAll(path2, \"\\\\\", \"/\");\n    },\n    /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */ isUrl (path2) {\n        return /^https?:/.test(this.toPosix(path2));\n    },\n    /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */ isDataUrl (path2) {\n        return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n    },\n    /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */ isBlobUrl (path2) {\n        return path2.startsWith(\"blob:\");\n    },\n    /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */ hasProtocol (path2) {\n        return /^[^/:]+:/.test(this.toPosix(path2));\n    },\n    /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */ getProtocol (path2) {\n        $843d7bf2b54bdd7d$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        const matchFile = /^file:\\/\\/\\//.exec(path2);\n        if (matchFile) return matchFile[0];\n        const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n        if (matchProtocol) return matchProtocol[0];\n        return \"\";\n    },\n    /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */ toAbsolute (url, customBaseUrl, customRootUrl) {\n        $843d7bf2b54bdd7d$var$assertPath(url);\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n        const baseUrl = $843d7bf2b54bdd7d$var$removeUrlParams(this.toPosix(customBaseUrl ?? (0, $d0V4H.DOMAdapter).get().getBaseUrl()));\n        const rootUrl = $843d7bf2b54bdd7d$var$removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n        url = this.toPosix(url);\n        if (url.startsWith(\"/\")) return $843d7bf2b54bdd7d$export$bb654e07daaf8c3a.join(rootUrl, url.slice(1));\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n        return absolutePath;\n    },\n    /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */ normalize (path2) {\n        $843d7bf2b54bdd7d$var$assertPath(path2);\n        if (path2.length === 0) return \".\";\n        if (this.isDataUrl(path2) || this.isBlobUrl(path2)) return path2;\n        path2 = this.toPosix(path2);\n        let protocol = \"\";\n        const isAbsolute = path2.startsWith(\"/\");\n        if (this.hasProtocol(path2)) {\n            protocol = this.rootname(path2);\n            path2 = path2.slice(protocol.length);\n        }\n        const trailingSeparator = path2.endsWith(\"/\");\n        path2 = $843d7bf2b54bdd7d$var$normalizeStringPosix(path2, false);\n        if (path2.length > 0 && trailingSeparator) path2 += \"/\";\n        if (isAbsolute) return `/${path2}`;\n        return protocol + path2;\n    },\n    /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */ isAbsolute (path2) {\n        $843d7bf2b54bdd7d$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        if (this.hasProtocol(path2)) return true;\n        return path2.startsWith(\"/\");\n    },\n    /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */ join (...segments) {\n        if (segments.length === 0) return \".\";\n        let joined;\n        for(let i = 0; i < segments.length; ++i){\n            const arg = segments[i];\n            $843d7bf2b54bdd7d$var$assertPath(arg);\n            if (arg.length > 0) {\n                if (joined === void 0) joined = arg;\n                else {\n                    const prevArg = segments[i - 1] ?? \"\";\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) joined += `/../${arg}`;\n                    else joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === void 0) return \".\";\n        return this.normalize(joined);\n    },\n    /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */ dirname (path2) {\n        $843d7bf2b54bdd7d$var$assertPath(path2);\n        if (path2.length === 0) return \".\";\n        path2 = this.toPosix(path2);\n        let code = path2.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n        const proto = this.getProtocol(path2);\n        const origpath = path2;\n        path2 = path2.slice(proto.length);\n        for(let i = path2.length - 1; i >= 1; --i){\n            code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            } else matchedSlash = false;\n        }\n        if (end === -1) return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n        if (hasRoot && end === 1) return \"//\";\n        return proto + path2.slice(0, end);\n    },\n    /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */ rootname (path2) {\n        $843d7bf2b54bdd7d$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        let root = \"\";\n        if (path2.startsWith(\"/\")) root = \"/\";\n        else root = this.getProtocol(path2);\n        if (this.isUrl(path2)) {\n            const index = path2.indexOf(\"/\", root.length);\n            if (index !== -1) root = path2.slice(0, index);\n            else root = path2;\n            if (!root.endsWith(\"/\")) root += \"/\";\n        }\n        return root;\n    },\n    /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */ basename (path2, ext) {\n        $843d7bf2b54bdd7d$var$assertPath(path2);\n        if (ext) $843d7bf2b54bdd7d$var$assertPath(ext);\n        path2 = $843d7bf2b54bdd7d$var$removeUrlParams(this.toPosix(path2));\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n            if (ext.length === path2.length && ext === path2) return \"\";\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for(i = path2.length - 1; i >= 0; --i){\n                const code = path2.charCodeAt(i);\n                if (code === 47) {\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                } else {\n                    if (firstNonSlashEnd === -1) {\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) end = i;\n                        } else {\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) end = firstNonSlashEnd;\n            else if (end === -1) end = path2.length;\n            return path2.slice(start, end);\n        }\n        for(i = path2.length - 1; i >= 0; --i){\n            if (path2.charCodeAt(i) === 47) {\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            } else if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) return \"\";\n        return path2.slice(start, end);\n    },\n    /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */ extname (path2) {\n        $843d7bf2b54bdd7d$var$assertPath(path2);\n        path2 = $843d7bf2b54bdd7d$var$removeUrlParams(this.toPosix(path2));\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let preDotState = 0;\n        for(let i = path2.length - 1; i >= 0; --i){\n            const code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46) {\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) preDotState = -1;\n        }\n        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return \"\";\n        return path2.slice(startDot, end);\n    },\n    /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */ parse (path2) {\n        $843d7bf2b54bdd7d$var$assertPath(path2);\n        const ret = {\n            root: \"\",\n            dir: \"\",\n            base: \"\",\n            ext: \"\",\n            name: \"\"\n        };\n        if (path2.length === 0) return ret;\n        path2 = $843d7bf2b54bdd7d$var$removeUrlParams(this.toPosix(path2));\n        let code = path2.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path2);\n        let start;\n        const protocol = \"\";\n        ret.root = this.rootname(path2);\n        if (isAbsolute || this.hasProtocol(path2)) start = 1;\n        else start = 0;\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path2.length - 1;\n        let preDotState = 0;\n        for(; i >= start; --i){\n            code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46) {\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) preDotState = -1;\n        }\n        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n            if (end !== -1) {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);\n                else ret.base = ret.name = path2.slice(startPart, end);\n            }\n        } else {\n            if (startPart === 0 && isAbsolute) {\n                ret.name = path2.slice(1, startDot);\n                ret.base = path2.slice(1, end);\n            } else {\n                ret.name = path2.slice(startPart, startDot);\n                ret.base = path2.slice(startPart, end);\n            }\n            ret.ext = path2.slice(startDot, end);\n        }\n        ret.dir = this.dirname(path2);\n        if (protocol) ret.dir = protocol + ret.dir;\n        return ret;\n    },\n    sep: \"/\",\n    delimiter: \":\",\n    joinExtensions: [\n        \".html\"\n    ]\n};\n\n});\n\nparcelRegister(\"c284d\", function(module, exports) {\n\n$parcel$export(module.exports, \"createStringVariations\", function () { return $8c10bb5b06f25484$export$738117acc6638004; });\n\"use strict\";\nfunction $8c10bb5b06f25484$var$processX(base, ids, depth, result, tags) {\n    const id = ids[depth];\n    for(let i = 0; i < id.length; i++){\n        const value = id[i];\n        if (depth < ids.length - 1) $8c10bb5b06f25484$var$processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        else tags.push(base.replace(result[depth], value));\n    }\n}\nfunction $8c10bb5b06f25484$export$738117acc6638004(string) {\n    const regex = /\\{(.*?)\\}/g;\n    const result = string.match(regex);\n    const tags = [];\n    if (result) {\n        const ids = [];\n        result.forEach((vars)=>{\n            const split = vars.substring(1, vars.length - 1).split(\",\");\n            ids.push(split);\n        });\n        $8c10bb5b06f25484$var$processX(string, ids, 0, result, tags);\n    } else tags.push(string);\n    return tags;\n}\n\n});\n\nparcelRegister(\"bBvqO\", function(module, exports) {\n\n$parcel$export(module.exports, \"isSingleItem\", function () { return $a9e658f99f1b9d1e$export$16a80d27953452d4; });\n\"use strict\";\nconst $a9e658f99f1b9d1e$export$16a80d27953452d4 = (item)=>!Array.isArray(item);\n\n});\n\n\nparcelRegister(\"abXd6\", function(module, exports) {\n\n$parcel$export(module.exports, \"copySearchParams\", function () { return $300312e7105a88be$export$f57b97ef8be10dda; });\n\"use strict\";\nconst $300312e7105a88be$export$f57b97ef8be10dda = (targetUrl, sourceUrl)=>{\n    const searchParams = sourceUrl.split(\"?\")[1];\n    if (searchParams) targetUrl += `?${searchParams}`;\n    return targetUrl;\n};\n\n});\n\nparcelRegister(\"dvQOG\", function(module, exports) {\n\n$parcel$export(module.exports, \"Spritesheet\", function () { return $aee523b97dd2ab9f$export$674d2eb4debbef0c; });\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\"use strict\";\nconst $aee523b97dd2ab9f$var$_Spritesheet = class _Spritesheet {\n    /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */ constructor(texture, data){\n        /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */ this.linkedSheets = [];\n        this._texture = texture instanceof (0, $4YnyE.Texture) ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {};\n        this.animations = {};\n        this.data = data;\n        const metaResolution = parseFloat(data.meta.scale);\n        if (metaResolution) {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        } else this.resolution = texture.source._resolution;\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n    /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */ parse() {\n        return new Promise((resolve)=>{\n            this._callback = resolve;\n            this._batchIndex = 0;\n            if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            } else this._nextBatch();\n        });\n    }\n    /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */ _processFrames(initialFrameIndex) {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = _Spritesheet.BATCH_SIZE;\n        while(frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length){\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n            if (rect) {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n                const orig = new (0, $ec4lc.Rectangle)(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n                if (data.rotated) frame = new (0, $ec4lc.Rectangle)(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n                else frame = new (0, $ec4lc.Rectangle)(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                if (data.trimmed !== false && data.spriteSourceSize) trim = new (0, $ec4lc.Rectangle)(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                this.textures[i] = new (0, $4YnyE.Texture)({\n                    source: this.textureSource,\n                    frame: frame,\n                    orig: orig,\n                    trim: trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n                    label: i.toString()\n                });\n            }\n            frameIndex++;\n        }\n    }\n    /** Parse animations config. */ _processAnimations() {\n        const animations = this.data.animations || {};\n        for(const animName in animations){\n            this.animations[animName] = [];\n            for(let i = 0; i < animations[animName].length; i++){\n                const frameName = animations[animName][i];\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n    /** The parse has completed. */ _parseComplete() {\n        const callback = this._callback;\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n    /** Begin the next batch of textures. */ _nextBatch() {\n        this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(()=>{\n            if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) this._nextBatch();\n            else {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n    /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */ destroy(destroyBase = false) {\n        for(const i in this.textures)this.textures[i].destroy();\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase) {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n};\n/** The maximum number of Textures to build per process. */ $aee523b97dd2ab9f$var$_Spritesheet.BATCH_SIZE = 1e3;\nlet $aee523b97dd2ab9f$export$674d2eb4debbef0c = $aee523b97dd2ab9f$var$_Spritesheet;\n\n});\n\n\n\nparcelRegister(\"bk2f9\", function(module, exports) {\n\n$parcel$export(module.exports, \"AbstractRenderer\", function () { return $919233a2fae5198d$export$58ab3ed211eed562; });\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $eYZeV = parcelRequire(\"eYZeV\");\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\n\nvar $bjxKI = parcelRequire(\"bjxKI\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\n\nvar $7gR5c = parcelRequire(\"7gR5c\");\n\nvar $4EOMD = parcelRequire(\"4EOMD\");\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\"use strict\";\nconst $919233a2fae5198d$var$defaultRunners = [\n    \"init\",\n    \"destroy\",\n    \"contextChange\",\n    \"resolutionChange\",\n    \"resetState\",\n    \"renderEnd\",\n    \"renderStart\",\n    \"render\",\n    \"update\",\n    \"postrender\",\n    \"prerender\"\n];\nconst $919233a2fae5198d$var$_AbstractRenderer = class _AbstractRenderer extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */ constructor(config){\n        super();\n        this.runners = /* @__PURE__ */ Object.create(null);\n        this.renderPipes = /* @__PURE__ */ Object.create(null);\n        this._initOptions = {};\n        this._systemsHash = /* @__PURE__ */ Object.create(null);\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n        const combinedRunners = [\n            ...$919233a2fae5198d$var$defaultRunners,\n            ...this.config.runners ?? []\n        ];\n        this._addRunners(...combinedRunners);\n        this._unsafeEvalCheck();\n    }\n    /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */ async init(options = {}) {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n        await (0, $eYZeV.loadEnvironmentExtensions)(skip);\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n        for(const systemName in this._systemsHash){\n            const system = this._systemsHash[systemName];\n            const defaultSystemOptions = system.constructor.defaultOptions;\n            options = {\n                ...defaultSystemOptions,\n                ...options\n            };\n        }\n        options = {\n            ..._AbstractRenderer.defaultOptions,\n            ...options\n        };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n        for(let i = 0; i < this.runners.init.items.length; i++)await this.runners.init.items[i].init(options);\n        this._initOptions = options;\n    }\n    render(args, deprecated) {\n        let options = args;\n        if (options instanceof (0, $gRXu9.Container)) {\n            options = {\n                container: options\n            };\n            if (deprecated) {\n                (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"passing a second argument is deprecated, please use render options instead\");\n                options.target = deprecated.renderTexture;\n            }\n        }\n        options.target || (options.target = this.view.renderTarget);\n        if (options.target === this.view.renderTarget) {\n            this._lastObjectRendered = options.container;\n            options.clearColor ?? (options.clearColor = this.background.colorRgba);\n            options.clear ?? (options.clear = this.background.clearBeforeRender);\n        }\n        if (options.clearColor) {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n            options.clearColor = isRGBAArray ? options.clearColor : (0, $hFslp.Color).shared.setValue(options.clearColor).toArray();\n        }\n        if (!options.transform) {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n        options.container.enableRenderGroup();\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n    /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */ resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n        const previousResolution = this.view.resolution;\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit(\"resize\", this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== void 0 && resolution !== previousResolution) this.runners.resolutionChange.emit(resolution);\n    }\n    clear(options = {}) {\n        const renderer = this;\n        options.target || (options.target = renderer.renderTarget.renderTarget);\n        options.clearColor || (options.clearColor = this.background.colorRgba);\n        options.clear ?? (options.clear = (0, $7gR5c.CLEAR).ALL);\n        const { clear: clear, clearColor: clearColor, target: target } = options;\n        (0, $hFslp.Color).shared.setValue(clearColor ?? this.background.colorRgba);\n        renderer.renderTarget.clear(target, clear, (0, $hFslp.Color).shared.toArray());\n    }\n    /** The resolution / device pixel ratio of the renderer. */ get resolution() {\n        return this.view.resolution;\n    }\n    set resolution(value) {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n    /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */ get width() {\n        return this.view.texture.frame.width;\n    }\n    /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */ get height() {\n        return this.view.texture.frame.height;\n    }\n    // NOTE: this was `view` in v7\n    /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */ get canvas() {\n        return this.view.canvas;\n    }\n    /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */ get lastObjectRendered() {\n        return this._lastObjectRendered;\n    }\n    /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */ get renderingToScreen() {\n        const renderer = this;\n        return renderer.renderTarget.renderingToScreen;\n    }\n    /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */ get screen() {\n        return this.view.screen;\n    }\n    /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */ _addRunners(...runnerIds) {\n        runnerIds.forEach((runnerId)=>{\n            this.runners[runnerId] = new (0, $4EOMD.SystemRunner)(runnerId);\n        });\n    }\n    _addSystems(systems) {\n        let i;\n        for(i in systems){\n            const val = systems[i];\n            this._addSystem(val.value, val.name);\n        }\n    }\n    /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn't collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */ _addSystem(ClassRef, name) {\n        const system = new ClassRef(this);\n        if (this[name]) throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        this[name] = system;\n        this._systemsHash[name] = system;\n        for(const i in this.runners)this.runners[i].add(system);\n        return this;\n    }\n    _addPipes(pipes, pipeAdaptors) {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor)=>{\n            acc[adaptor.name] = adaptor.value;\n            return acc;\n        }, {});\n        pipes.forEach((pipe)=>{\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n            const Adaptor = adaptors[name];\n            this.renderPipes[name] = new PipeClass(this, Adaptor ? new Adaptor() : null);\n        });\n    }\n    destroy(options = false) {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n        Object.values(this.runners).forEach((runner)=>{\n            runner.destroy();\n        });\n        this._systemsHash = null;\n        this.renderPipes = null;\n    }\n    /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */ generateTexture(options) {\n        return this.textureGenerator.generateTexture(options);\n    }\n    /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   * @ignore\n   */ _unsafeEvalCheck() {\n        if (!(0, $bjxKI.unsafeEvalSupported)()) throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n    /**\n   * Resets the rendering state of the renderer.\n   * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n   * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n   * render will reset all internal caches and ensure it executes correctly.\n   *\n   * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n   * ```js\n   * // Reset Three.js state\n   * threeRenderer.resetState();\n   *\n   * // Render a Three.js scene\n   * threeRenderer.render(threeScene, threeCamera);\n   *\n   * // Reset PixiJS state since Three.js modified the WebGL context\n   * pixiRenderer.resetState();\n   *\n   * // Now render Pixi content\n   * pixiRenderer.render(pixiScene);\n   * ```\n   */ resetState() {\n        this.runners.resetState.emit();\n    }\n};\n/** The default options for the renderer. */ $919233a2fae5198d$var$_AbstractRenderer.defaultOptions = {\n    /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */ resolution: 1,\n    /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */ failIfMajorPerformanceCaveat: false,\n    /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */ roundPixels: false\n};\nlet $919233a2fae5198d$export$58ab3ed211eed562 = $919233a2fae5198d$var$_AbstractRenderer;\n\n});\nparcelRegister(\"eYZeV\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadEnvironmentExtensions\", function () { return $dfc22c56eea0b6b6$export$3b30260a318c769f; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nconst $dfc22c56eea0b6b6$var$environments = [];\n(0, $kFA6i.extensions).handleByNamedList((0, $kFA6i.ExtensionType).Environment, $dfc22c56eea0b6b6$var$environments);\nasync function $dfc22c56eea0b6b6$export$3b30260a318c769f(skip) {\n    if (skip) return;\n    for(let i = 0; i < $dfc22c56eea0b6b6$var$environments.length; i++){\n        const env = $dfc22c56eea0b6b6$var$environments[i];\n        if (env.value.test()) {\n            await env.value.load();\n            return;\n        }\n    }\n}\nasync function $dfc22c56eea0b6b6$export$72225172dd907279(add) {\n    return $dfc22c56eea0b6b6$export$3b30260a318c769f(!add);\n}\n\n});\n\nparcelRegister(\"bjxKI\", function(module, exports) {\n\n$parcel$export(module.exports, \"unsafeEvalSupported\", function () { return $c98ba44347fdd13b$export$70c0711f29adc5cf; });\n\"use strict\";\nlet $c98ba44347fdd13b$var$unsafeEval;\nfunction $c98ba44347fdd13b$export$70c0711f29adc5cf() {\n    if (typeof $c98ba44347fdd13b$var$unsafeEval === \"boolean\") return $c98ba44347fdd13b$var$unsafeEval;\n    try {\n        const func = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n        $c98ba44347fdd13b$var$unsafeEval = func({\n            a: \"b\"\n        }, \"a\", \"b\") === true;\n    } catch (_e) {\n        $c98ba44347fdd13b$var$unsafeEval = false;\n    }\n    return $c98ba44347fdd13b$var$unsafeEval;\n}\n\n});\n\nparcelRegister(\"7gR5c\", function(module, exports) {\n\n$parcel$export(module.exports, \"CLEAR\", function () { return $213211d020523f6c$export$6c4d37c7f376a1de; });\n\"use strict\";\nvar $213211d020523f6c$export$6c4d37c7f376a1de = /* @__PURE__ */ ((CLEAR2)=>{\n    CLEAR2[CLEAR2[\"NONE\"] = 0] = \"NONE\";\n    CLEAR2[CLEAR2[\"COLOR\"] = 16384] = \"COLOR\";\n    CLEAR2[CLEAR2[\"STENCIL\"] = 1024] = \"STENCIL\";\n    CLEAR2[CLEAR2[\"DEPTH\"] = 256] = \"DEPTH\";\n    CLEAR2[CLEAR2[\"COLOR_DEPTH\"] = 16640] = \"COLOR_DEPTH\";\n    CLEAR2[CLEAR2[\"COLOR_STENCIL\"] = 17408] = \"COLOR_STENCIL\";\n    CLEAR2[CLEAR2[\"DEPTH_STENCIL\"] = 1280] = \"DEPTH_STENCIL\";\n    CLEAR2[CLEAR2[\"ALL\"] = 17664] = \"ALL\";\n    return CLEAR2;\n})($213211d020523f6c$export$6c4d37c7f376a1de || {});\n\n});\n\nparcelRegister(\"4EOMD\", function(module, exports) {\n\n$parcel$export(module.exports, \"SystemRunner\", function () { return $a9ab149507b541d6$export$ff5f2fe687fe3979; });\n\"use strict\";\nclass $a9ab149507b541d6$export$ff5f2fe687fe3979 {\n    /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */ constructor(name){\n        this.items = [];\n        this._name = name;\n    }\n    /* jsdoc/check-param-names */ /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */ /* jsdoc/check-param-names */ emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n        const { name: name, items: items } = this;\n        for(let i = 0, len = items.length; i < len; i++)items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        return this;\n    }\n    /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */ add(item) {\n        if (item[this._name]) {\n            this.remove(item);\n            this.items.push(item);\n        }\n        return this;\n    }\n    /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */ remove(item) {\n        const index = this.items.indexOf(item);\n        if (index !== -1) this.items.splice(index, 1);\n        return this;\n    }\n    /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */ contains(item) {\n        return this.items.indexOf(item) !== -1;\n    }\n    /** Remove all listeners from the Runner */ removeAll() {\n        this.items.length = 0;\n        return this;\n    }\n    /** Remove all references, don't use after this. */ destroy() {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n    /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */ get empty() {\n        return this.items.length === 0;\n    }\n    /**\n   * The name of the runner.\n   * @readonly\n   */ get name() {\n        return this._name;\n    }\n}\n\n});\n\n\nparcelRegister(\"6BhUg\", function(module, exports) {\n\nvar $hffE7 = parcelRequire(\"hffE7\");\nmodule.exports = Promise.all([\n    $hffE7(\"gyKa4\"),\n    $hffE7(\"fqXAI\")\n]).then(()=>parcelRequire('hfuCN'));\n\n});\n\nparcelRegister(\"8qkEh\", function(module, exports) {\n\nvar $hffE7 = parcelRequire(\"hffE7\");\nmodule.exports = Promise.all([\n    $hffE7(\"gyKa4\"),\n    $hffE7(\"dgumL\")\n]).then(()=>parcelRequire('c8FrZ'));\n\n});\n\nparcelRegister(\"d6zIN\", function(module, exports) {\n\n$parcel$export(module.exports, \"ApplicationInitHook\", function () { return $7ebc6c78daad8ca3$export$918f3e4d2b801859; });\n$parcel$export(module.exports, \"RendererInitHook\", function () { return $7ebc6c78daad8ca3$export$5fba6e443d2fb64; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $2wPJh = parcelRequire(\"2wPJh\");\n\"use strict\";\nclass $7ebc6c78daad8ca3$export$918f3e4d2b801859 {\n    static init() {\n        globalThis.__PIXI_APP_INIT__?.(this, (0, $2wPJh.VERSION));\n    }\n    static destroy() {}\n}\n/** @ignore */ $7ebc6c78daad8ca3$export$918f3e4d2b801859.extension = (0, $kFA6i.ExtensionType).Application;\nclass $7ebc6c78daad8ca3$export$5fba6e443d2fb64 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    init() {\n        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, (0, $2wPJh.VERSION));\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $7ebc6c78daad8ca3$export$5fba6e443d2fb64.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem\n    ],\n    name: \"initHook\",\n    priority: -10\n};\n\n});\nparcelRegister(\"2wPJh\", function(module, exports) {\n\n$parcel$export(module.exports, \"VERSION\", function () { return $96ae7b02363e72a9$export$a4ad2735b021c132; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\"use strict\";\nconst $96ae7b02363e72a9$export$dbafa72958753fce = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\nconst $96ae7b02363e72a9$export$a4ad2735b021c132 = \"8.7.2\";\n\n});\n\n\nparcelRegister(\"lQbVo\", function(module, exports) {\n\n$parcel$export(module.exports, \"BitmapFontManager\", function () { return $13872b1604cc36b4$export$d2ee57cdc0e1ed7f; });\n\nvar $6n8as = parcelRequire(\"6n8as\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $2oqF9 = parcelRequire(\"2oqF9\");\n\nvar $1Fy2M = parcelRequire(\"1Fy2M\");\n\nvar $c57nt = parcelRequire(\"c57nt\");\n\nvar $8VyWJ = parcelRequire(\"8VyWJ\");\n\"use strict\";\nlet $13872b1604cc36b4$var$fontCount = 0;\nclass $13872b1604cc36b4$var$BitmapFontManagerClass {\n    constructor(){\n        /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */ this.ALPHA = [\n            [\n                \"a\",\n                \"z\"\n            ],\n            [\n                \"A\",\n                \"Z\"\n            ],\n            \" \"\n        ];\n        /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */ this.NUMERIC = [\n            [\n                \"0\",\n                \"9\"\n            ]\n        ];\n        /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */ this.ALPHANUMERIC = [\n            [\n                \"a\",\n                \"z\"\n            ],\n            [\n                \"A\",\n                \"Z\"\n            ],\n            [\n                \"0\",\n                \"9\"\n            ],\n            \" \"\n        ];\n        /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */ this.ASCII = [\n            [\n                \" \",\n                \"~\"\n            ]\n        ];\n        /** Default options for installing a new BitmapFont. */ this.defaultOptions = {\n            chars: this.ALPHANUMERIC,\n            resolution: 1,\n            padding: 4,\n            skipKerning: false\n        };\n    }\n    /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */ getFont(text, style) {\n        let fontFamilyKey = `${style.fontFamily}-bitmap`;\n        let overrideFill = true;\n        if (style._fill.fill && !style._stroke) {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        } else if (style._stroke || style.dropShadow) {\n            let key = style.styleKey;\n            key = key.substring(0, key.lastIndexOf(\"-\"));\n            fontFamilyKey = `${key}-bitmap`;\n            overrideFill = false;\n        }\n        if (!(0, $6n8as.Cache).has(fontFamilyKey)) {\n            const fnt = new (0, $1Fy2M.DynamicBitmapFont)({\n                style: style,\n                overrideFill: overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions\n            });\n            $13872b1604cc36b4$var$fontCount++;\n            if ($13872b1604cc36b4$var$fontCount > 50) (0, $c9aw6.warn)(\"BitmapText\", `You have dynamically created ${$13872b1604cc36b4$var$fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            fnt.once(\"destroy\", ()=>{\n                $13872b1604cc36b4$var$fontCount--;\n                (0, $6n8as.Cache).remove(fontFamilyKey);\n            });\n            (0, $6n8as.Cache).set(fontFamilyKey, fnt);\n        }\n        const dynamicFont = (0, $6n8as.Cache).get(fontFamilyKey);\n        dynamicFont.ensureCharacters?.(text);\n        return dynamicFont;\n    }\n    /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */ getLayout(text, style, trimEnd = true) {\n        const bitmapFont = this.getFont(text, style);\n        return (0, $c57nt.getBitmapTextLayout)([\n            ...text\n        ], style, bitmapFont, trimEnd);\n    }\n    /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */ measureText(text, style, trimEnd = true) {\n        return this.getLayout(text, style, trimEnd);\n    }\n    // eslint-disable-next-line max-len\n    install(...args) {\n        let options = args[0];\n        if (typeof options === \"string\") {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning\n            };\n            (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})\");\n        }\n        const name = options?.name;\n        if (!name) throw new Error(\"[BitmapFontManager] Property `name` is required.\");\n        options = {\n            ...this.defaultOptions,\n            ...options\n        };\n        const textStyle = options.style;\n        const style = textStyle instanceof (0, $2oqF9.TextStyle) ? textStyle : new (0, $2oqF9.TextStyle)(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n        const font = new (0, $1Fy2M.DynamicBitmapFont)({\n            style: style,\n            overrideFill: overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n        const flatChars = (0, $8VyWJ.resolveCharacters)(options.chars);\n        font.ensureCharacters(flatChars.join(\"\"));\n        (0, $6n8as.Cache).set(`${name}-bitmap`, font);\n        font.once(\"destroy\", ()=>(0, $6n8as.Cache).remove(`${name}-bitmap`));\n        return font;\n    }\n    /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */ uninstall(name) {\n        const cacheKey = `${name}-bitmap`;\n        const font = (0, $6n8as.Cache).get(cacheKey);\n        if (font) font.destroy();\n    }\n}\nconst $13872b1604cc36b4$export$d2ee57cdc0e1ed7f = new $13872b1604cc36b4$var$BitmapFontManagerClass();\n\n});\nparcelRegister(\"2oqF9\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextStyle\", function () { return $3db57088bb20238a$export$1df879243bf2e42d; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $faWAK = parcelRequire(\"faWAK\");\n\nvar $iKeQS = parcelRequire(\"iKeQS\");\n\nvar $lfe2w = parcelRequire(\"lfe2w\");\n\nvar $jzyMN = parcelRequire(\"jzyMN\");\n\nvar $7oI6r = parcelRequire(\"7oI6r\");\n\"use strict\";\nconst $3db57088bb20238a$var$_TextStyle = class _TextStyle extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    constructor(style = {}){\n        super();\n        $3db57088bb20238a$var$convertV7Tov8Style(style);\n        const fullStyle = {\n            ..._TextStyle.defaultTextStyle,\n            ...style\n        };\n        for(const key in fullStyle){\n            const thisKey = key;\n            this[thisKey] = fullStyle[key];\n        }\n        this.update();\n    }\n    /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */ get align() {\n        return this._align;\n    }\n    set align(value) {\n        this._align = value;\n        this.update();\n    }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */ get breakWords() {\n        return this._breakWords;\n    }\n    set breakWords(value) {\n        this._breakWords = value;\n        this.update();\n    }\n    /** Set a drop shadow for the text. */ get dropShadow() {\n        return this._dropShadow;\n    }\n    set dropShadow(value) {\n        if (value !== null && typeof value === \"object\") this._dropShadow = this._createProxy({\n            ..._TextStyle.defaultDropShadow,\n            ...value\n        });\n        else this._dropShadow = value ? this._createProxy({\n            ..._TextStyle.defaultDropShadow\n        }) : null;\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */ get fontFamily() {\n        return this._fontFamily;\n    }\n    set fontFamily(value) {\n        this._fontFamily = value;\n        this.update();\n    }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */ get fontSize() {\n        return this._fontSize;\n    }\n    set fontSize(value) {\n        if (typeof value === \"string\") this._fontSize = parseInt(value, 10);\n        else this._fontSize = value;\n        this.update();\n    }\n    /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */ get fontStyle() {\n        return this._fontStyle;\n    }\n    set fontStyle(value) {\n        this._fontStyle = value.toLowerCase();\n        this.update();\n    }\n    /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */ get fontVariant() {\n        return this._fontVariant;\n    }\n    set fontVariant(value) {\n        this._fontVariant = value;\n        this.update();\n    }\n    /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */ get fontWeight() {\n        return this._fontWeight;\n    }\n    set fontWeight(value) {\n        this._fontWeight = value;\n        this.update();\n    }\n    /** The space between lines. */ get leading() {\n        return this._leading;\n    }\n    set leading(value) {\n        this._leading = value;\n        this.update();\n    }\n    /** The amount of spacing between letters, default is 0. */ get letterSpacing() {\n        return this._letterSpacing;\n    }\n    set letterSpacing(value) {\n        this._letterSpacing = value;\n        this.update();\n    }\n    /** The line height, a number that represents the vertical space that a letter uses. */ get lineHeight() {\n        return this._lineHeight;\n    }\n    set lineHeight(value) {\n        this._lineHeight = value;\n        this.update();\n    }\n    /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */ get padding() {\n        return this._padding;\n    }\n    set padding(value) {\n        this._padding = value;\n        this.update();\n    }\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */ get trim() {\n        return this._trim;\n    }\n    set trim(value) {\n        this._trim = value;\n        this.update();\n    }\n    /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */ get textBaseline() {\n        return this._textBaseline;\n    }\n    set textBaseline(value) {\n        this._textBaseline = value;\n        this.update();\n    }\n    /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */ get whiteSpace() {\n        return this._whiteSpace;\n    }\n    set whiteSpace(value) {\n        this._whiteSpace = value;\n        this.update();\n    }\n    /** Indicates if word wrap should be used. */ get wordWrap() {\n        return this._wordWrap;\n    }\n    set wordWrap(value) {\n        this._wordWrap = value;\n        this.update();\n    }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */ get wordWrapWidth() {\n        return this._wordWrapWidth;\n    }\n    set wordWrapWidth(value) {\n        this._wordWrapWidth = value;\n        this.update();\n    }\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */ get fill() {\n        return this._originalFill;\n    }\n    set fill(value) {\n        if (value === this._originalFill) return;\n        this._originalFill = value;\n        if (this._isFillStyle(value)) this._originalFill = this._createProxy({\n            ...(0, $lfe2w.GraphicsContext).defaultFillStyle,\n            ...value\n        }, ()=>{\n            this._fill = (0, $jzyMN.toFillStyle)({\n                ...this._originalFill\n            }, (0, $lfe2w.GraphicsContext).defaultFillStyle);\n        });\n        this._fill = (0, $jzyMN.toFillStyle)(value === 0 ? \"black\" : value, (0, $lfe2w.GraphicsContext).defaultFillStyle);\n        this.update();\n    }\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */ get stroke() {\n        return this._originalStroke;\n    }\n    set stroke(value) {\n        if (value === this._originalStroke) return;\n        this._originalStroke = value;\n        if (this._isFillStyle(value)) this._originalStroke = this._createProxy({\n            ...(0, $lfe2w.GraphicsContext).defaultStrokeStyle,\n            ...value\n        }, ()=>{\n            this._stroke = (0, $jzyMN.toStrokeStyle)({\n                ...this._originalStroke\n            }, (0, $lfe2w.GraphicsContext).defaultStrokeStyle);\n        });\n        this._stroke = (0, $jzyMN.toStrokeStyle)(value, (0, $lfe2w.GraphicsContext).defaultStrokeStyle);\n        this.update();\n    }\n    _generateKey() {\n        this._styleKey = (0, $7oI6r.generateTextStyleKey)(this);\n        return this._styleKey;\n    }\n    update() {\n        this._styleKey = null;\n        this.emit(\"update\", this);\n    }\n    /** Resets all properties to the default values */ reset() {\n        const defaultStyle = _TextStyle.defaultTextStyle;\n        for(const key in defaultStyle)this[key] = defaultStyle[key];\n    }\n    get styleKey() {\n        return this._styleKey || this._generateKey();\n    }\n    /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */ clone() {\n        return new _TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? {\n                ...this._dropShadow\n            } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth\n        });\n    }\n    /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */ destroy(options = false) {\n        this.removeAllListeners();\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            if (this._fill?.texture) this._fill.texture.destroy(destroyTextureSource);\n            if (this._originalFill?.texture) this._originalFill.texture.destroy(destroyTextureSource);\n            if (this._stroke?.texture) this._stroke.texture.destroy(destroyTextureSource);\n            if (this._originalStroke?.texture) this._originalStroke.texture.destroy(destroyTextureSource);\n        }\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n    _createProxy(value, cb) {\n        return new Proxy(value, {\n            set: (target, property, newValue)=>{\n                target[property] = newValue;\n                cb?.(property, newValue);\n                this.update();\n                return true;\n            }\n        });\n    }\n    _isFillStyle(value) {\n        return (value ?? null) !== null && !((0, $hFslp.Color).isColorLike(value) || value instanceof (0, $faWAK.FillGradient) || value instanceof (0, $iKeQS.FillPattern));\n    }\n};\n/** The default drop shadow settings */ $3db57088bb20238a$var$_TextStyle.defaultDropShadow = {\n    /** Set alpha for the drop shadow */ alpha: 1,\n    /** Set a angle of the drop shadow */ angle: Math.PI / 6,\n    /** Set a shadow blur radius */ blur: 0,\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */ color: \"black\",\n    /** Set a distance of the drop shadow */ distance: 5\n};\n/** The default text style settings */ $3db57088bb20238a$var$_TextStyle.defaultTextStyle = {\n    /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */ align: \"left\",\n    /** See {@link TextStyle.breakWords} */ breakWords: false,\n    /** See {@link TextStyle.dropShadow} */ dropShadow: null,\n    /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */ fill: \"black\",\n    /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */ fontFamily: \"Arial\",\n    /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */ fontSize: 26,\n    /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */ fontStyle: \"normal\",\n    /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */ fontVariant: \"normal\",\n    /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */ fontWeight: \"normal\",\n    /** See {@link TextStyle.leading} */ leading: 0,\n    /** See {@link TextStyle.letterSpacing} */ letterSpacing: 0,\n    /** See {@link TextStyle.lineHeight} */ lineHeight: 0,\n    /** See {@link TextStyle.padding} */ padding: 0,\n    /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */ stroke: null,\n    /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */ textBaseline: \"alphabetic\",\n    /** See {@link TextStyle.trim} */ trim: false,\n    /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */ whiteSpace: \"pre\",\n    /** See {@link TextStyle.wordWrap} */ wordWrap: false,\n    /** See {@link TextStyle.wordWrapWidth} */ wordWrapWidth: 100\n};\nlet $3db57088bb20238a$export$1df879243bf2e42d = $3db57088bb20238a$var$_TextStyle;\nfunction $3db57088bb20238a$var$convertV7Tov8Style(style) {\n    const oldStyle = style;\n    if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n        const defaults = $3db57088bb20238a$export$1df879243bf2e42d.defaultDropShadow;\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance: oldStyle.dropShadowDistance ?? defaults.distance\n        };\n    }\n    if (oldStyle.strokeThickness !== void 0) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"strokeThickness is now a part of stroke\");\n        const color = oldStyle.stroke;\n        let obj = {};\n        if ((0, $hFslp.Color).isColorLike(color)) obj.color = color;\n        else if (color instanceof (0, $faWAK.FillGradient) || color instanceof (0, $iKeQS.FillPattern)) obj.fill = color;\n        else if (Object.hasOwnProperty.call(color, \"color\") || Object.hasOwnProperty.call(color, \"fill\")) obj = color;\n        else throw new Error(\"Invalid stroke value.\");\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n    if (Array.isArray(oldStyle.fillGradientStops)) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n        let fontSize;\n        if (style.fontSize == null) style.fontSize = $3db57088bb20238a$export$1df879243bf2e42d.defaultTextStyle.fontSize;\n        else if (typeof style.fontSize === \"string\") fontSize = parseInt(style.fontSize, 10);\n        else fontSize = style.fontSize;\n        const gradientFill = new (0, $faWAK.FillGradient)(0, 0, 0, fontSize * 1.7);\n        const fills = oldStyle.fillGradientStops.map((color)=>(0, $hFslp.Color).shared.setValue(color).toNumber());\n        fills.forEach((number, index)=>{\n            const ratio = index / (fills.length - 1);\n            gradientFill.addColorStop(ratio, number);\n        });\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n});\nparcelRegister(\"faWAK\", function(module, exports) {\n\n$parcel$export(module.exports, \"FillGradient\", function () { return $986bc8a8a4c2a5b3$export$722a6ea8c60ca86; });\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $hRHFw = parcelRequire(\"hRHFw\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\"use strict\";\nconst $986bc8a8a4c2a5b3$var$_FillGradient = class _FillGradient {\n    constructor(x0, y0, x1, y1){\n        /** unique id for this fill gradient */ this.uid = (0, $fTJzX.uid)(\"fillGradient\");\n        this.type = \"linear\";\n        this.gradientStops = [];\n        this._styleKey = null;\n        this.x0 = x0;\n        this.y0 = y0;\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n    addColorStop(offset, color) {\n        this.gradientStops.push({\n            offset: offset,\n            color: (0, $hFslp.Color).shared.setValue(color).toHexa()\n        });\n        this._styleKey = null;\n        return this;\n    }\n    // TODO move to the system!\n    buildLinearGradient() {\n        if (this.texture) return;\n        const defaultSize = _FillGradient.defaultTextureSize;\n        const { gradientStops: gradientStops } = this;\n        const canvas = (0, $d0V4H.DOMAdapter).get().createCanvas();\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n        const ctx = canvas.getContext(\"2d\");\n        const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n        for(let i = 0; i < gradientStops.length; i++){\n            const stop = gradientStops[i];\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n        this.texture = new (0, $4YnyE.Texture)({\n            source: new (0, $hRHFw.ImageSource)({\n                resource: canvas,\n                addressModeU: \"clamp-to-edge\",\n                addressModeV: \"repeat\"\n            })\n        });\n        const { x0: x0, y0: y0, x1: x1, y1: y1 } = this;\n        const m = new (0, $0kbcf.Matrix)();\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const angle = Math.atan2(dy, dx);\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n        this.transform = m;\n        this._styleKey = null;\n    }\n    get styleKey() {\n        if (this._styleKey) return this._styleKey;\n        const stops = this.gradientStops.map((stop)=>`${stop.offset}-${stop.color}`).join(\"-\");\n        const texture = this.texture.uid;\n        const transform = this.transform.toArray().join(\"-\");\n        return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n    }\n};\n$986bc8a8a4c2a5b3$var$_FillGradient.defaultTextureSize = 256;\nlet $986bc8a8a4c2a5b3$export$722a6ea8c60ca86 = $986bc8a8a4c2a5b3$var$_FillGradient;\n\n});\n\nparcelRegister(\"iKeQS\", function(module, exports) {\n\n$parcel$export(module.exports, \"FillPattern\", function () { return $4ebf970abba832e6$export$3d1378c7410cd8e; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\"use strict\";\nconst $4ebf970abba832e6$var$repetitionMap = {\n    repeat: {\n        addressModeU: \"repeat\",\n        addressModeV: \"repeat\"\n    },\n    \"repeat-x\": {\n        addressModeU: \"repeat\",\n        addressModeV: \"clamp-to-edge\"\n    },\n    \"repeat-y\": {\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"repeat\"\n    },\n    \"no-repeat\": {\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"clamp-to-edge\"\n    }\n};\nclass $4ebf970abba832e6$export$3d1378c7410cd8e {\n    constructor(texture, repetition){\n        /** unique id for this fill pattern */ this.uid = (0, $fTJzX.uid)(\"fillPattern\");\n        this.transform = new (0, $0kbcf.Matrix)();\n        this._styleKey = null;\n        this.texture = texture;\n        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);\n        if (repetition) {\n            texture.source.style.addressModeU = $4ebf970abba832e6$var$repetitionMap[repetition].addressModeU;\n            texture.source.style.addressModeV = $4ebf970abba832e6$var$repetitionMap[repetition].addressModeV;\n        }\n    }\n    setTransform(transform) {\n        const texture = this.texture;\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);\n        this._styleKey = null;\n    }\n    get styleKey() {\n        if (this._styleKey) return this._styleKey;\n        this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join(\"-\")}`;\n        return this._styleKey;\n    }\n}\n\n});\n\nparcelRegister(\"lfe2w\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsContext\", function () { return $17adac14b4ad4eee$export$cde35afe8b5f985; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $hbjPo = parcelRequire(\"hbjPo\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $d32rq = parcelRequire(\"d32rq\");\n\nvar $aplex = parcelRequire(\"aplex\");\n\nvar $jzyMN = parcelRequire(\"jzyMN\");\n\"use strict\";\nconst $17adac14b4ad4eee$var$tmpPoint = new (0, $hbjPo.Point)();\nconst $17adac14b4ad4eee$var$tempMatrix = new (0, $0kbcf.Matrix)();\nconst $17adac14b4ad4eee$var$_GraphicsContext = class _GraphicsContext extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    constructor(){\n        super(...arguments);\n        /** unique id for this graphics context */ this.uid = (0, $fTJzX.uid)(\"graphicsContext\");\n        this.dirty = true;\n        this.batchMode = \"auto\";\n        this.instructions = [];\n        this._activePath = new (0, $d32rq.GraphicsPath)();\n        this._transform = new (0, $0kbcf.Matrix)();\n        this._fillStyle = {\n            ..._GraphicsContext.defaultFillStyle\n        };\n        this._strokeStyle = {\n            ..._GraphicsContext.defaultStrokeStyle\n        };\n        this._stateStack = [];\n        this._tick = 0;\n        this._bounds = new (0, $dtW0p.Bounds)();\n        this._boundsDirty = true;\n    }\n    /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */ clone() {\n        const clone = new _GraphicsContext();\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = {\n            ...this._fillStyle\n        };\n        clone._strokeStyle = {\n            ...this._strokeStyle\n        };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n        return clone;\n    }\n    /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */ get fillStyle() {\n        return this._fillStyle;\n    }\n    set fillStyle(value) {\n        this._fillStyle = (0, $jzyMN.toFillStyle)(value, _GraphicsContext.defaultFillStyle);\n    }\n    /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */ get strokeStyle() {\n        return this._strokeStyle;\n    }\n    set strokeStyle(value) {\n        this._strokeStyle = (0, $jzyMN.toStrokeStyle)(value, _GraphicsContext.defaultStrokeStyle);\n    }\n    /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setFillStyle(style) {\n        this._fillStyle = (0, $jzyMN.toFillStyle)(style, _GraphicsContext.defaultFillStyle);\n        return this;\n    }\n    /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setStrokeStyle(style) {\n        this._strokeStyle = (0, $jzyMN.toFillStyle)(style, _GraphicsContext.defaultStrokeStyle);\n        return this;\n    }\n    texture(texture, tint, dx, dy, dw, dh) {\n        this.instructions.push({\n            action: \"texture\",\n            data: {\n                image: texture,\n                dx: dx || 0,\n                dy: dy || 0,\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? (0, $hFslp.Color).shared.setValue(tint).toNumber() : 16777215\n            }\n        });\n        this.onUpdate();\n        return this;\n    }\n    /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ beginPath() {\n        this._activePath = new (0, $d32rq.GraphicsPath)();\n        return this;\n    }\n    fill(style, alpha) {\n        let path;\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") path = lastInstruction.data.path;\n        else path = this._activePath.clone();\n        if (!path) return this;\n        if (style != null) {\n            if (alpha !== void 0 && typeof style === \"number\") {\n                (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n                style = {\n                    color: style,\n                    alpha: alpha\n                };\n            }\n            this._fillStyle = (0, $jzyMN.toFillStyle)(style, _GraphicsContext.defaultFillStyle);\n        }\n        this.instructions.push({\n            action: \"fill\",\n            // TODO copy fill style!\n            data: {\n                style: this.fillStyle,\n                path: path\n            }\n        });\n        this.onUpdate();\n        this._initNextPathLocation();\n        this._tick = 0;\n        return this;\n    }\n    _initNextPathLocation() {\n        const { x: x, y: y } = this._activePath.getLastPoint((0, $hbjPo.Point).shared);\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n    /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ stroke(style) {\n        let path;\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") path = lastInstruction.data.path;\n        else path = this._activePath.clone();\n        if (!path) return this;\n        if (style != null) this._strokeStyle = (0, $jzyMN.toStrokeStyle)(style, _GraphicsContext.defaultStrokeStyle);\n        this.instructions.push({\n            action: \"stroke\",\n            // TODO copy fill style!\n            data: {\n                style: this.strokeStyle,\n                path: path\n            }\n        });\n        this.onUpdate();\n        this._initNextPathLocation();\n        this._tick = 0;\n        return this;\n    }\n    /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ cut() {\n        for(let i = 0; i < 2; i++){\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n            const holePath = this._activePath.clone();\n            if (lastInstruction) {\n                if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n                    if (lastInstruction.data.hole) lastInstruction.data.hole.addPath(holePath);\n                    else {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n        this._initNextPathLocation();\n        return this;\n    }\n    /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arc(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, radius, startAngle, endAngle, counterclockwise);\n        return this;\n    }\n    /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ arcTo(x1, y1, x2, y2, radius) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arcTo(t.a * x1 + t.c * y1 + t.tx, t.b * x1 + t.d * y1 + t.ty, t.a * x2 + t.c * y2 + t.tx, t.b * x2 + t.d * y2 + t.ty, radius);\n        return this;\n    }\n    /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arcToSvg(rx, ry, xAxisRotation, // should we rotate this with transform??\n        largeArcFlag, sweepFlag, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.bezierCurveTo(t.a * cp1x + t.c * cp1y + t.tx, t.b * cp1x + t.d * cp1y + t.ty, t.a * cp2x + t.c * cp2y + t.tx, t.b * cp2x + t.d * cp2y + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this._tick++;\n        this._activePath?.closePath();\n        return this;\n    }\n    /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */ ellipse(x, y, radiusX, radiusY) {\n        this._tick++;\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius) {\n        this._tick++;\n        this._activePath.circle(x, y, radius, this._transform.clone());\n        return this;\n    }\n    /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */ path(path) {\n        this._tick++;\n        this._activePath.addPath(path, this._transform.clone());\n        return this;\n    }\n    /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */ lineTo(x, y) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.lineTo(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n        return this;\n    }\n    /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */ moveTo(x, y) {\n        this._tick++;\n        const t = this._transform;\n        const instructions = this._activePath.instructions;\n        const transformedX = t.a * x + t.c * y + t.tx;\n        const transformedY = t.b * x + t.d * y + t.ty;\n        if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n            return this;\n        }\n        this._activePath.moveTo(transformedX, transformedY);\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.quadraticCurveTo(t.a * cpx + t.c * cpy + t.tx, t.b * cpx + t.d * cpy + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n        return this;\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h) {\n        this._tick++;\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */ roundRect(x, y, w, h, radius) {\n        this._tick++;\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */ poly(points, close) {\n        this._tick++;\n        this._activePath.poly(points, close, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n        return this;\n    }\n    /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */ roundPoly(x, y, radius, sides, corner, rotation) {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n        return this;\n    }\n    /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */ roundShape(points, radius, useQuadratic, smoothness) {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n        return this;\n    }\n    /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */ filletRect(x, y, width, height, fillet) {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n        return this;\n    }\n    /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */ chamferRect(x, y, width, height, chamfer, transform) {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n        return this;\n    }\n    /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */ star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n        this._tick++;\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n        return this;\n    }\n    /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */ svg(svg) {\n        this._tick++;\n        (0, $aplex.SVGParser)(svg, this);\n        return this;\n    }\n    /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */ restore() {\n        const state = this._stateStack.pop();\n        if (state) {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n        return this;\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */ save() {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: {\n                ...this._fillStyle\n            },\n            strokeStyle: {\n                ...this._strokeStyle\n            }\n        });\n        return this;\n    }\n    /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */ getTransform() {\n        return this._transform;\n    }\n    /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ resetTransform() {\n        this._transform.identity();\n        return this;\n    }\n    /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ rotate(angle) {\n        this._transform.rotate(angle);\n        return this;\n    }\n    /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ scale(x, y = x) {\n        this._transform.scale(x, y);\n        return this;\n    }\n    setTransform(a, b, c, d, dx, dy) {\n        if (a instanceof (0, $0kbcf.Matrix)) {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n            return this;\n        }\n        this._transform.set(a, b, c, d, dx, dy);\n        return this;\n    }\n    transform(a, b, c, d, dx, dy) {\n        if (a instanceof (0, $0kbcf.Matrix)) {\n            this._transform.append(a);\n            return this;\n        }\n        $17adac14b4ad4eee$var$tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append($17adac14b4ad4eee$var$tempMatrix);\n        return this;\n    }\n    /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ translate(x, y = x) {\n        this._transform.translate(x, y);\n        return this;\n    }\n    /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ clear() {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n        this.onUpdate();\n        return this;\n    }\n    onUpdate() {\n        if (this.dirty) return;\n        this.emit(\"update\", this, 16);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n    /** The bounds of the graphic shape. */ get bounds() {\n        if (!this._boundsDirty) return this._bounds;\n        const bounds = this._bounds;\n        bounds.clear();\n        for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n            if (action === \"fill\") {\n                const data = instruction.data;\n                bounds.addBounds(data.path.bounds);\n            } else if (action === \"texture\") {\n                const data = instruction.data;\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === \"stroke\") {\n                const data = instruction.data;\n                const alignment = data.style.alignment;\n                const outerPadding = data.style.width * (1 - alignment);\n                const _bounds = data.path.bounds;\n                bounds.addFrame(_bounds.minX - outerPadding, _bounds.minY - outerPadding, _bounds.maxX + outerPadding, _bounds.maxY + outerPadding);\n            }\n        }\n        return bounds;\n    }\n    /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */ containsPoint(point) {\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n        const instructions = this.instructions;\n        let hasHit = false;\n        for(let k = 0; k < instructions.length; k++){\n            const instruction = instructions[k];\n            const data = instruction.data;\n            const path = data.path;\n            if (!instruction.action || !path) continue;\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n            for(let i = 0; i < shapes.length; i++){\n                const shape = shapes[i].shape;\n                if (!style || !shape) continue;\n                const transform = shapes[i].transform;\n                const transformedPoint = transform ? transform.applyInverse(point, $17adac14b4ad4eee$var$tmpPoint) : point;\n                if (instruction.action === \"fill\") hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                else {\n                    const strokeStyle = style;\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n                }\n                const holes = data.hole;\n                if (holes) {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n                    if (holeShapes) {\n                        for(let j = 0; j < holeShapes.length; j++)if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) hasHit = false;\n                    }\n                }\n                if (hasHit) return true;\n            }\n        }\n        return hasHit;\n    }\n    /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */ destroy(options = false) {\n        this._stateStack.length = 0;\n        this._transform = null;\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            if (this._fillStyle.texture) this._fillStyle.texture.destroy(destroyTextureSource);\n            if (this._strokeStyle.texture) this._strokeStyle.texture.destroy(destroyTextureSource);\n        }\n        this._fillStyle = null;\n        this._strokeStyle = null;\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n};\n/** The default fill style to use when none is provided. */ $17adac14b4ad4eee$var$_GraphicsContext.defaultFillStyle = {\n    /** The color to use for the fill. */ color: 16777215,\n    /** The alpha value to use for the fill. */ alpha: 1,\n    /** The texture to use for the fill. */ texture: (0, $4YnyE.Texture).WHITE,\n    /** The matrix to apply. */ matrix: null,\n    /** The fill pattern to use. */ fill: null\n};\n/** The default stroke style to use when none is provided. */ $17adac14b4ad4eee$var$_GraphicsContext.defaultStrokeStyle = {\n    /** The width of the stroke. */ width: 1,\n    /** The color to use for the stroke. */ color: 16777215,\n    /** The alpha value to use for the stroke. */ alpha: 1,\n    /** The alignment of the stroke. */ alignment: 0.5,\n    /** The miter limit to use. */ miterLimit: 10,\n    /** The line cap style to use. */ cap: \"butt\",\n    /** The line join style to use. */ join: \"miter\",\n    /** The texture to use for the fill. */ texture: (0, $4YnyE.Texture).WHITE,\n    /** The matrix to apply. */ matrix: null,\n    /** The fill pattern to use. */ fill: null,\n    /** If the stroke is a pixel line. */ pixelLine: false\n};\nlet $17adac14b4ad4eee$export$cde35afe8b5f985 = $17adac14b4ad4eee$var$_GraphicsContext;\n\n});\nparcelRegister(\"d32rq\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsPath\", function () { return $8f14847d3669f69c$export$7e54506375634c19; });\n\nvar $hbjPo = parcelRequire(\"hbjPo\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $f9kKY = parcelRequire(\"f9kKY\");\n\nvar $krLTT = parcelRequire(\"krLTT\");\n\"use strict\";\nclass $8f14847d3669f69c$export$7e54506375634c19 {\n    /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */ constructor(instructions){\n        this.instructions = [];\n        /** unique id for this graphics path */ this.uid = (0, $fTJzX.uid)(\"graphicsPath\");\n        this._dirty = true;\n        if (typeof instructions === \"string\") (0, $f9kKY.SVGToGraphicsPath)(instructions, this);\n        else this.instructions = instructions?.slice() ?? [];\n    }\n    /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */ get shapePath() {\n        if (!this._shapePath) this._shapePath = new (0, $krLTT.ShapePath)(this);\n        if (this._dirty) {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n        return this._shapePath;\n    }\n    /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */ addPath(path, transform) {\n        path = path.clone();\n        this.instructions.push({\n            action: \"addPath\",\n            data: [\n                path,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    arc(...args) {\n        this.instructions.push({\n            action: \"arc\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    arcTo(...args) {\n        this.instructions.push({\n            action: \"arcTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    arcToSvg(...args) {\n        this.instructions.push({\n            action: \"arcToSvg\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    bezierCurveTo(...args) {\n        this.instructions.push({\n            action: \"bezierCurveTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n        const last = this.instructions[this.instructions.length - 1];\n        const lastPoint = this.getLastPoint((0, $hbjPo.Point).shared);\n        let cp1x = 0;\n        let cp1y = 0;\n        if (!last || last.action !== \"bezierCurveTo\") {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        } else {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n        this.instructions.push({\n            action: \"bezierCurveTo\",\n            data: [\n                cp1x,\n                cp1y,\n                cp2x,\n                cp2y,\n                x,\n                y,\n                smoothness\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this.instructions.push({\n            action: \"closePath\",\n            data: []\n        });\n        this._dirty = true;\n        return this;\n    }\n    ellipse(...args) {\n        this.instructions.push({\n            action: \"ellipse\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    lineTo(...args) {\n        this.instructions.push({\n            action: \"lineTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    moveTo(...args) {\n        this.instructions.push({\n            action: \"moveTo\",\n            data: args\n        });\n        return this;\n    }\n    quadraticCurveTo(...args) {\n        this.instructions.push({\n            action: \"quadraticCurveTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveToShort(x, y, smoothness) {\n        const last = this.instructions[this.instructions.length - 1];\n        const lastPoint = this.getLastPoint((0, $hbjPo.Point).shared);\n        let cpx1 = 0;\n        let cpy1 = 0;\n        if (!last || last.action !== \"quadraticCurveTo\") {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        } else {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n        this.instructions.push({\n            action: \"quadraticCurveTo\",\n            data: [\n                cpx1,\n                cpy1,\n                x,\n                y,\n                smoothness\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h, transform) {\n        this.instructions.push({\n            action: \"rect\",\n            data: [\n                x,\n                y,\n                w,\n                h,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius, transform) {\n        this.instructions.push({\n            action: \"circle\",\n            data: [\n                x,\n                y,\n                radius,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundRect(...args) {\n        this.instructions.push({\n            action: \"roundRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    poly(...args) {\n        this.instructions.push({\n            action: \"poly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    regularPoly(...args) {\n        this.instructions.push({\n            action: \"regularPoly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundPoly(...args) {\n        this.instructions.push({\n            action: \"roundPoly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundShape(...args) {\n        this.instructions.push({\n            action: \"roundShape\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    filletRect(...args) {\n        this.instructions.push({\n            action: \"filletRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    chamferRect(...args) {\n        this.instructions.push({\n            action: \"chamferRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */ // eslint-disable-next-line max-len\n    star(x, y, points, radius, innerRadius, rotation, transform) {\n        innerRadius || (innerRadius = radius / 2);\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const len = points * 2;\n        const delta = Math.PI * 2 / len;\n        const polygon = [];\n        for(let i = 0; i < len; i++){\n            const r = i % 2 ? innerRadius : radius;\n            const angle = i * delta + startAngle;\n            polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n        }\n        this.poly(polygon, true, transform);\n        return this;\n    }\n    /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */ clone(deep = false) {\n        const newGraphicsPath2D = new $8f14847d3669f69c$export$7e54506375634c19();\n        if (!deep) newGraphicsPath2D.instructions = this.instructions.slice();\n        else for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            newGraphicsPath2D.instructions.push({\n                action: instruction.action,\n                data: instruction.data.slice()\n            });\n        }\n        return newGraphicsPath2D;\n    }\n    clear() {\n        this.instructions.length = 0;\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */ transform(matrix) {\n        if (matrix.isIdentity()) return this;\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        let x = 0;\n        let y = 0;\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n        let rx = 0;\n        let ry = 0;\n        for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            const data = instruction.data;\n            switch(instruction.action){\n                case \"moveTo\":\n                case \"lineTo\":\n                    x = data[0];\n                    y = data[1];\n                    data[0] = a * x + c * y + tx;\n                    data[1] = b * x + d * y + ty;\n                    break;\n                case \"bezierCurveTo\":\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n                    x = data[4];\n                    y = data[5];\n                    data[0] = a * cpx1 + c * cpy1 + tx;\n                    data[1] = b * cpx1 + d * cpy1 + ty;\n                    data[2] = a * cpx2 + c * cpy2 + tx;\n                    data[3] = b * cpx2 + d * cpy2 + ty;\n                    data[4] = a * x + c * y + tx;\n                    data[5] = b * x + d * y + ty;\n                    break;\n                case \"quadraticCurveTo\":\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    x = data[2];\n                    y = data[3];\n                    data[0] = a * cpx1 + c * cpy1 + tx;\n                    data[1] = b * cpx1 + d * cpy1 + ty;\n                    data[2] = a * x + c * y + tx;\n                    data[3] = b * x + d * y + ty;\n                    break;\n                case \"arcToSvg\":\n                    x = data[5];\n                    y = data[6];\n                    rx = data[0];\n                    ry = data[1];\n                    data[0] = a * rx + c * ry;\n                    data[1] = b * rx + d * ry;\n                    data[5] = a * x + c * y + tx;\n                    data[6] = b * x + d * y + ty;\n                    break;\n                case \"circle\":\n                    data[4] = $8f14847d3669f69c$var$adjustTransform(data[3], matrix);\n                    break;\n                case \"rect\":\n                    data[4] = $8f14847d3669f69c$var$adjustTransform(data[4], matrix);\n                    break;\n                case \"ellipse\":\n                    data[8] = $8f14847d3669f69c$var$adjustTransform(data[8], matrix);\n                    break;\n                case \"roundRect\":\n                    data[5] = $8f14847d3669f69c$var$adjustTransform(data[5], matrix);\n                    break;\n                case \"addPath\":\n                    data[0].transform(matrix);\n                    break;\n                case \"poly\":\n                    data[2] = $8f14847d3669f69c$var$adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    (0, $c9aw6.warn)(\"unknown transform action\", instruction.action);\n                    break;\n            }\n        }\n        this._dirty = true;\n        return this;\n    }\n    get bounds() {\n        return this.shapePath.bounds;\n    }\n    /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */ getLastPoint(out) {\n        let index = this.instructions.length - 1;\n        let lastInstruction = this.instructions[index];\n        if (!lastInstruction) {\n            out.x = 0;\n            out.y = 0;\n            return out;\n        }\n        while(lastInstruction.action === \"closePath\"){\n            index--;\n            if (index < 0) {\n                out.x = 0;\n                out.y = 0;\n                return out;\n            }\n            lastInstruction = this.instructions[index];\n        }\n        switch(lastInstruction.action){\n            case \"moveTo\":\n            case \"lineTo\":\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case \"quadraticCurveTo\":\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case \"bezierCurveTo\":\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case \"arc\":\n            case \"arcToSvg\":\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case \"addPath\":\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n        return out;\n    }\n}\nfunction $8f14847d3669f69c$var$adjustTransform(currentMatrix, transform) {\n    if (currentMatrix) return currentMatrix.prepend(transform);\n    return transform.clone();\n}\n\n});\nparcelRegister(\"f9kKY\", function(module, exports) {\n\n$parcel$export(module.exports, \"SVGToGraphicsPath\", function () { return $7a56f5fc0fada619$export$14a4a8042d02aa8d; });\n\nvar $fcYjq = parcelRequire(\"fcYjq\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\"use strict\";\nfunction $7a56f5fc0fada619$export$14a4a8042d02aa8d(svgPath, path) {\n    const commands = (0, (/*@__PURE__*/$parcel$interopDefault($fcYjq)))(svgPath);\n    const subpaths = [];\n    let currentSubPath = null;\n    let lastX = 0;\n    let lastY = 0;\n    for(let i = 0; i < commands.length; i++){\n        const command = commands[i];\n        const type = command[0];\n        const data = command;\n        switch(type){\n            case \"M\":\n                lastX = data[1];\n                lastY = data[2];\n                path.moveTo(lastX, lastY);\n                break;\n            case \"m\":\n                lastX += data[1];\n                lastY += data[2];\n                path.moveTo(lastX, lastY);\n                break;\n            case \"H\":\n                lastX = data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"h\":\n                lastX += data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"V\":\n                lastY = data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"v\":\n                lastY += data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"L\":\n                lastX = data[1];\n                lastY = data[2];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"l\":\n                lastX += data[1];\n                lastY += data[2];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"C\":\n                lastX = data[5];\n                lastY = data[6];\n                path.bezierCurveTo(data[1], data[2], data[3], data[4], lastX, lastY);\n                break;\n            case \"c\":\n                path.bezierCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4], lastX + data[5], lastY + data[6]);\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case \"S\":\n                lastX = data[3];\n                lastY = data[4];\n                path.bezierCurveToShort(data[1], data[2], lastX, lastY);\n                break;\n            case \"s\":\n                path.bezierCurveToShort(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case \"Q\":\n                lastX = data[3];\n                lastY = data[4];\n                path.quadraticCurveTo(data[1], data[2], lastX, lastY);\n                break;\n            case \"q\":\n                path.quadraticCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case \"T\":\n                lastX = data[1];\n                lastY = data[2];\n                path.quadraticCurveToShort(lastX, lastY);\n                break;\n            case \"t\":\n                lastX += data[1];\n                lastY += data[2];\n                path.quadraticCurveToShort(lastX, lastY);\n                break;\n            case \"A\":\n                lastX = data[6];\n                lastY = data[7];\n                path.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);\n                break;\n            case \"a\":\n                lastX += data[6];\n                lastY += data[7];\n                path.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);\n                break;\n            case \"Z\":\n            case \"z\":\n                path.closePath();\n                if (subpaths.length > 0) {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath) {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    } else {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                (0, $c9aw6.warn)(`Unknown SVG path command: ${type}`);\n        }\n        if (type !== \"Z\" && type !== \"z\") {\n            if (currentSubPath === null) {\n                currentSubPath = {\n                    startX: lastX,\n                    startY: lastY\n                };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n    return path;\n}\n\n});\nparcelRegister(\"fcYjq\", function(module, exports) {\nmodule.exports = $b126c2cb4bd2f87c$var$parse;\n/**\n * expected argument lengths\n * @type {Object}\n */ var $b126c2cb4bd2f87c$var$length = {\n    a: 7,\n    c: 6,\n    h: 1,\n    l: 2,\n    m: 2,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    z: 0\n};\n/**\n * segment pattern\n * @type {RegExp}\n */ var $b126c2cb4bd2f87c$var$segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */ function $b126c2cb4bd2f87c$var$parse(path) {\n    var data = [];\n    path.replace($b126c2cb4bd2f87c$var$segment, function(_, command, args) {\n        var type = command.toLowerCase();\n        args = $b126c2cb4bd2f87c$var$parseValues(args);\n        // overloaded moveTo\n        if (type == 'm' && args.length > 2) {\n            data.push([\n                command\n            ].concat(args.splice(0, 2)));\n            type = 'l';\n            command = command == 'm' ? 'l' : 'L';\n        }\n        while(true){\n            if (args.length == $b126c2cb4bd2f87c$var$length[type]) {\n                args.unshift(command);\n                return data.push(args);\n            }\n            if (args.length < $b126c2cb4bd2f87c$var$length[type]) throw new Error('malformed path data');\n            data.push([\n                command\n            ].concat(args.splice(0, $b126c2cb4bd2f87c$var$length[type])));\n        }\n    });\n    return data;\n}\nvar $b126c2cb4bd2f87c$var$number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig;\nfunction $b126c2cb4bd2f87c$var$parseValues(args) {\n    var numbers = args.match($b126c2cb4bd2f87c$var$number);\n    return numbers ? numbers.map(Number) : [];\n}\n\n});\n\n\nparcelRegister(\"krLTT\", function(module, exports) {\n\n$parcel$export(module.exports, \"ShapePath\", function () { return $137401cd8060a2ad$export$148534a3c727230b; });\n\nvar $aXuc6 = parcelRequire(\"aXuc6\");\n\nvar $dAKnc = parcelRequire(\"dAKnc\");\n\nvar $beTo1 = parcelRequire(\"beTo1\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\nvar $j2N26 = parcelRequire(\"j2N26\");\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $dVeJc = parcelRequire(\"dVeJc\");\n\nvar $7VTKT = parcelRequire(\"7VTKT\");\n\nvar $9HsoA = parcelRequire(\"9HsoA\");\n\nvar $iiH2h = parcelRequire(\"iiH2h\");\n\nvar $t0jfs = parcelRequire(\"t0jfs\");\n\nvar $97zsF = parcelRequire(\"97zsF\");\n\"use strict\";\nconst $137401cd8060a2ad$var$tempRectangle = new (0, $ec4lc.Rectangle)();\nclass $137401cd8060a2ad$export$148534a3c727230b {\n    constructor(graphicsPath2D){\n        /** The list of shape primitives that make up the path. */ this.shapePrimitives = [];\n        this._currentPoly = null;\n        this._bounds = new (0, $dtW0p.Bounds)();\n        this._graphicsPath2D = graphicsPath2D;\n    }\n    /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */ moveTo(x, y) {\n        this.startPoly(x, y);\n        return this;\n    }\n    /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */ lineTo(x, y) {\n        this._ensurePoly();\n        const points = this._currentPoly.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n        if (fromX !== x || fromY !== y) points.push(x, y);\n        return this;\n    }\n    /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        this._ensurePoly(false);\n        const points = this._currentPoly.points;\n        (0, $9HsoA.buildArc)(points, x, y, radius, startAngle, endAngle, counterclockwise);\n        return this;\n    }\n    /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */ arcTo(x1, y1, x2, y2, radius) {\n        this._ensurePoly();\n        const points = this._currentPoly.points;\n        (0, $iiH2h.buildArcTo)(points, x1, y1, x2, y2, radius);\n        return this;\n    }\n    /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        const points = this._currentPoly.points;\n        (0, $t0jfs.buildArcToSvg)(points, this._currentPoly.lastX, this._currentPoly.lastY, x, y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n        this._ensurePoly();\n        const currentPoly = this._currentPoly;\n        (0, $dVeJc.buildAdaptiveBezier)(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x, y, smoothness);\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n        this._ensurePoly();\n        const currentPoly = this._currentPoly;\n        (0, $7VTKT.buildAdaptiveQuadratic)(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x, y, smoothing);\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this.endPoly(true);\n        return this;\n    }\n    /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */ addPath(path, transform) {\n        this.endPoly();\n        if (transform && !transform.isIdentity()) {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n        for(let i = 0; i < path.instructions.length; i++){\n            const instruction = path.instructions[i];\n            this[instruction.action](...instruction.data);\n        }\n        return this;\n    }\n    /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */ finish(closePath = false) {\n        this.endPoly(closePath);\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h, transform) {\n        this.drawShape(new (0, $ec4lc.Rectangle)(x, y, w, h), transform);\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius, transform) {\n        this.drawShape(new (0, $aXuc6.Circle)(x, y, radius), transform);\n        return this;\n    }\n    /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ poly(points, close, transform) {\n        const polygon = new (0, $beTo1.Polygon)(points);\n        polygon.closePath = close;\n        this.drawShape(polygon, transform);\n        return this;\n    }\n    /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const delta = Math.PI * 2 / sides;\n        const polygon = [];\n        for(let i = 0; i < sides; i++){\n            const angle = startAngle - i * delta;\n            polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));\n        }\n        this.poly(polygon, true, transform);\n        return this;\n    }\n    /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */ roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n        sides = Math.max(sides | 0, 3);\n        if (corner <= 0) return this.regularPoly(x, y, radius, sides, rotation);\n        const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n        corner = Math.min(corner, sideLength);\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const delta = Math.PI * 2 / sides;\n        const internalAngle = (sides - 2) * Math.PI / sides / 2;\n        for(let i = 0; i < sides; i++){\n            const angle = i * delta + startAngle;\n            const x0 = x + radius * Math.cos(angle);\n            const y0 = y + radius * Math.sin(angle);\n            const a1 = angle + Math.PI + internalAngle;\n            const a2 = angle - Math.PI - internalAngle;\n            const x1 = x0 + corner * Math.cos(a1);\n            const y1 = y0 + corner * Math.sin(a1);\n            const x3 = x0 + corner * Math.cos(a2);\n            const y3 = y0 + corner * Math.sin(a2);\n            if (i === 0) this.moveTo(x1, y1);\n            else this.lineTo(x1, y1);\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n        return this.closePath();\n    }\n    /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */ roundShape(points, radius, useQuadratic = false, smoothness) {\n        if (points.length < 3) return this;\n        if (useQuadratic) (0, $97zsF.roundedShapeQuadraticCurve)(this, points, radius, smoothness);\n        else (0, $97zsF.roundedShapeArc)(this, points, radius);\n        return this.closePath();\n    }\n    /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */ filletRect(x, y, width, height, fillet) {\n        if (fillet === 0) return this.rect(x, y, width, height);\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n        return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n    }\n    /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */ chamferRect(x, y, width, height, chamfer, transform) {\n        if (chamfer <= 0) return this.rect(x, y, width, height);\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset,\n            y,\n            right - inset,\n            y,\n            right,\n            y + inset,\n            right,\n            bottom - inset,\n            right - inset,\n            bottom,\n            x + inset,\n            bottom,\n            x,\n            bottom - inset,\n            x,\n            y + inset\n        ];\n        for(let i = points.length - 1; i >= 2; i -= 2)if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) points.splice(i - 1, 2);\n        return this.poly(points, true, transform);\n    }\n    /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */ ellipse(x, y, radiusX, radiusY, transform) {\n        this.drawShape(new (0, $dAKnc.Ellipse)(x, y, radiusX, radiusY), transform);\n        return this;\n    }\n    /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ roundRect(x, y, w, h, radius, transform) {\n        this.drawShape(new (0, $j2N26.RoundedRectangle)(x, y, w, h, radius), transform);\n        return this;\n    }\n    /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */ drawShape(shape, matrix) {\n        this.endPoly();\n        this.shapePrimitives.push({\n            shape: shape,\n            transform: matrix\n        });\n        return this;\n    }\n    /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */ startPoly(x, y) {\n        let currentPoly = this._currentPoly;\n        if (currentPoly) this.endPoly();\n        currentPoly = new (0, $beTo1.Polygon)();\n        currentPoly.points.push(x, y);\n        this._currentPoly = currentPoly;\n        return this;\n    }\n    /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */ endPoly(closePath = false) {\n        const shape = this._currentPoly;\n        if (shape && shape.points.length > 2) {\n            shape.closePath = closePath;\n            this.shapePrimitives.push({\n                shape: shape\n            });\n        }\n        this._currentPoly = null;\n        return this;\n    }\n    _ensurePoly(start = true) {\n        if (this._currentPoly) return;\n        this._currentPoly = new (0, $beTo1.Polygon)();\n        if (start) {\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n            if (lastShape) {\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n                if (lastShape.transform && !lastShape.transform.isIdentity()) {\n                    const t = lastShape.transform;\n                    const tempX = lx;\n                    lx = t.a * lx + t.c * ly + t.tx;\n                    ly = t.b * tempX + t.d * ly + t.ty;\n                }\n                this._currentPoly.points.push(lx, ly);\n            } else this._currentPoly.points.push(0, 0);\n        }\n    }\n    /** Builds the path. */ buildPath() {\n        const path = this._graphicsPath2D;\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n        for(let i = 0; i < path.instructions.length; i++){\n            const instruction = path.instructions[i];\n            this[instruction.action](...instruction.data);\n        }\n        this.finish();\n    }\n    /** Gets the bounds of the path. */ get bounds() {\n        const bounds = this._bounds;\n        bounds.clear();\n        const shapePrimitives = this.shapePrimitives;\n        for(let i = 0; i < shapePrimitives.length; i++){\n            const shapePrimitive = shapePrimitives[i];\n            const boundsRect = shapePrimitive.shape.getBounds($137401cd8060a2ad$var$tempRectangle);\n            if (shapePrimitive.transform) bounds.addRect(boundsRect, shapePrimitive.transform);\n            else bounds.addRect(boundsRect);\n        }\n        return bounds;\n    }\n}\n\n});\nparcelRegister(\"aXuc6\", function(module, exports) {\n\n$parcel$export(module.exports, \"Circle\", function () { return $b67928a604dbb421$export$c89a927ffc67e6fa; });\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\"use strict\";\nclass $b67928a604dbb421$export$c89a927ffc67e6fa {\n    /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */ constructor(x = 0, y = 0, radius = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */ this.type = \"circle\";\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n    /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */ clone() {\n        return new $b67928a604dbb421$export$c89a927ffc67e6fa(this.x, this.y, this.radius);\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */ contains(x, y) {\n        if (this.radius <= 0) return false;\n        const r2 = this.radius * this.radius;\n        let dx = this.x - x;\n        let dy = this.y - y;\n        dx *= dx;\n        dy *= dy;\n        return dx + dy <= r2;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this Circle\n   */ strokeContains(x, y, width, alignment = 0.5) {\n        if (this.radius === 0) return false;\n        const dx = this.x - x;\n        const dy = this.y - y;\n        const radius = this.radius;\n        const outerWidth = (1 - alignment) * width;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance <= radius + outerWidth && distance > radius - (width - outerWidth);\n    }\n    /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out || (out = new (0, $ec4lc.Rectangle)());\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n        return out;\n    }\n    /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(circle) {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n        return this;\n    }\n    /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(circle) {\n        circle.copyFrom(this);\n        return circle;\n    }\n    toString() {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n}\n\n});\n\nparcelRegister(\"dAKnc\", function(module, exports) {\n\n$parcel$export(module.exports, \"Ellipse\", function () { return $604e3e1f5c82e53e$export$80b0269ab108fa11; });\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\"use strict\";\nclass $604e3e1f5c82e53e$export$80b0269ab108fa11 {\n    /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */ constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */ this.type = \"ellipse\";\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n    /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */ clone() {\n        return new $604e3e1f5c82e53e$export$80b0269ab108fa11(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */ contains(x, y) {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;\n        let normx = (x - this.x) / this.halfWidth;\n        let normy = (y - this.y) / this.halfHeight;\n        normx *= normx;\n        normy *= normy;\n        return normx + normy <= 1;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke\n   * @returns Whether the x/y coords are within this ellipse\n   */ strokeContains(x, y, strokeWidth, alignment = 0.5) {\n        const { halfWidth: halfWidth, halfHeight: halfHeight } = this;\n        if (halfWidth <= 0 || halfHeight <= 0) return false;\n        const strokeOuterWidth = strokeWidth * (1 - alignment);\n        const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n        const innerHorizontal = halfWidth - strokeInnerWidth;\n        const innerVertical = halfHeight - strokeInnerWidth;\n        const outerHorizontal = halfWidth + strokeOuterWidth;\n        const outerVertical = halfHeight + strokeOuterWidth;\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n        const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);\n        const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n    /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out || (out = new (0, $ec4lc.Rectangle)());\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n        return out;\n    }\n    /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */ copyFrom(ellipse) {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n        return this;\n    }\n    /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(ellipse) {\n        ellipse.copyFrom(this);\n        return ellipse;\n    }\n    toString() {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n}\n\n});\n\nparcelRegister(\"beTo1\", function(module, exports) {\n\n$parcel$export(module.exports, \"Polygon\", function () { return $2dbc06dd0b1d055c$export$7d31b617c820d435; });\n\nvar $4UUML = parcelRequire(\"4UUML\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\"use strict\";\nclass $2dbc06dd0b1d055c$export$7d31b617c820d435 {\n    /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */ constructor(...points){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */ this.type = \"polygon\";\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n        if (typeof flat[0] !== \"number\") {\n            const p = [];\n            for(let i = 0, il = flat.length; i < il; i++)p.push(flat[i].x, flat[i].y);\n            flat = p;\n        }\n        this.points = flat;\n        this.closePath = true;\n    }\n    /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */ clone() {\n        const points = this.points.slice();\n        const polygon = new $2dbc06dd0b1d055c$export$7d31b617c820d435(points);\n        polygon.closePath = this.closePath;\n        return polygon;\n    }\n    /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */ contains(x, y) {\n        let inside = false;\n        const length = this.points.length / 2;\n        for(let i = 0, j = length - 1; i < length; j = i++){\n            const xi = this.points[i * 2];\n            const yi = this.points[i * 2 + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[j * 2 + 1];\n            const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n            if (intersect) inside = !inside;\n        }\n        return inside;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this polygon\n   */ strokeContains(x, y, strokeWidth, alignment = 0.5) {\n        const strokeWidthSquared = strokeWidth * strokeWidth;\n        const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n        const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n        const { points: points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n        for(let i = 0; i < iterationLength; i += 2){\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n            const distanceSquared = (0, $4UUML.squaredDistanceToLineSegment)(x, y, x1, y1, x2, y2);\n            const sign = Math.sign((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1));\n            if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared)) return true;\n        }\n        return false;\n    }\n    /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out || (out = new (0, $ec4lc.Rectangle)());\n        const points = this.points;\n        let minX = Infinity;\n        let maxX = -Infinity;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        for(let i = 0, n = points.length; i < n; i += 2){\n            const x = points[i];\n            const y = points[i + 1];\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n        out.x = minX;\n        out.width = maxX - minX;\n        out.y = minY;\n        out.height = maxY - minY;\n        return out;\n    }\n    /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */ copyFrom(polygon) {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n        return this;\n    }\n    /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(polygon) {\n        polygon.copyFrom(this);\n        return polygon;\n    }\n    toString() {\n        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint)=>`${pointsDesc}, ${currentPoint}`, \"\")}]`;\n    }\n    /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */ get lastX() {\n        return this.points[this.points.length - 2];\n    }\n    /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */ get lastY() {\n        return this.points[this.points.length - 1];\n    }\n    /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */ get x() {\n        return this.points[this.points.length - 2];\n    }\n    /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */ get y() {\n        return this.points[this.points.length - 1];\n    }\n}\n\n});\nparcelRegister(\"4UUML\", function(module, exports) {\n\n$parcel$export(module.exports, \"squaredDistanceToLineSegment\", function () { return $e33a1a10321a9001$export$db32ff20ff695a; });\n\"use strict\";\nfunction $e33a1a10321a9001$export$db32ff20ff695a(x, y, x1, y1, x2, y2) {\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n    const dot = a * c + b * d;\n    const lenSq = c * c + d * d;\n    let param = -1;\n    if (lenSq !== 0) param = dot / lenSq;\n    let xx;\n    let yy;\n    if (param < 0) {\n        xx = x1;\n        yy = y1;\n    } else if (param > 1) {\n        xx = x2;\n        yy = y2;\n    } else {\n        xx = x1 + param * c;\n        yy = y1 + param * d;\n    }\n    const dx = x - xx;\n    const dy = y - yy;\n    return dx * dx + dy * dy;\n}\n\n});\n\n\nparcelRegister(\"j2N26\", function(module, exports) {\n\n$parcel$export(module.exports, \"RoundedRectangle\", function () { return $709fb74830b2b0ca$export$d55ab2e3dc5a4263; });\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\"use strict\";\nconst $709fb74830b2b0ca$var$isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter)=>{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;\n};\nclass $709fb74830b2b0ca$export$d55ab2e3dc5a4263 {\n    /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */ constructor(x = 0, y = 0, width = 0, height = 0, radius = 20){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */ this.type = \"roundedRectangle\";\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n    /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out || (out = new (0, $ec4lc.Rectangle)());\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n        return out;\n    }\n    /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */ clone() {\n        return new $709fb74830b2b0ca$export$d55ab2e3dc5a4263(this.x, this.y, this.width, this.height, this.radius);\n    }\n    /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n        return this;\n    }\n    /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(rectangle) {\n        rectangle.copyFrom(this);\n        return rectangle;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */ contains(x, y) {\n        if (this.width <= 0 || this.height <= 0) return false;\n        if (x >= this.x && x <= this.x + this.width) {\n            if (y >= this.y && y <= this.y + this.height) {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n                if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) return true;\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n                if (dx * dx + dy * dy <= radius2) return true;\n                dx = x - (this.x + this.width - radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n                dy = y - (this.y + this.height - radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n                dx = x - (this.x + radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this rectangle\n   */ strokeContains(pX, pY, strokeWidth, alignment = 0.5) {\n        const { x: x, y: y, width: width, height: height, radius: radius } = this;\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - radius * 2;\n        const innerHeight = height - radius * 2;\n        const rightBound = x + width;\n        const bottomBound = y + height;\n        if ((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) return true;\n        if ((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) return true;\n        return(// Top-left\n        pX < innerX && pY < innerY && $709fb74830b2b0ca$var$isCornerWithinStroke(pX, pY, innerX, innerY, radius, strokeWidthInner, strokeWidthOuter) || pX > rightBound - radius && pY < innerY && $709fb74830b2b0ca$var$isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, strokeWidthInner, strokeWidthOuter) || pX > rightBound - radius && pY > bottomBound - radius && $709fb74830b2b0ca$var$isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, strokeWidthInner, strokeWidthOuter) || pX < innerX && pY > bottomBound - radius && $709fb74830b2b0ca$var$isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, strokeWidthInner, strokeWidthOuter));\n    }\n    toString() {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n}\n\n});\n\nparcelRegister(\"dVeJc\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildAdaptiveBezier\", function () { return $2a5e53fd99b4041c$export$7dab5eac414ecba2; });\n\nvar $inK6t = parcelRequire(\"inK6t\");\n\"use strict\";\nconst $2a5e53fd99b4041c$var$RECURSION_LIMIT = 8;\nconst $2a5e53fd99b4041c$var$FLT_EPSILON = 11920929e-14;\nconst $2a5e53fd99b4041c$var$PATH_DISTANCE_EPSILON = 1;\nconst $2a5e53fd99b4041c$var$curveAngleToleranceEpsilon = 0.01;\nconst $2a5e53fd99b4041c$var$mAngleTolerance = 0;\nconst $2a5e53fd99b4041c$var$mCuspLimit = 0;\nfunction $2a5e53fd99b4041c$export$7dab5eac414ecba2(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n    const scale = 1;\n    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? (0, $inK6t.GraphicsContextSystem).defaultOptions.bezierSmoothness));\n    let distanceTolerance = ($2a5e53fd99b4041c$var$PATH_DISTANCE_EPSILON - smoothing) / scale;\n    distanceTolerance *= distanceTolerance;\n    $2a5e53fd99b4041c$var$begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n    return points;\n}\nfunction $2a5e53fd99b4041c$var$begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n    $2a5e53fd99b4041c$var$recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\nfunction $2a5e53fd99b4041c$var$recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n    if (level > $2a5e53fd99b4041c$var$RECURSION_LIMIT) return;\n    const pi = Math.PI;\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n    if (level > 0) {\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n        const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n        const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n        let da1;\n        let da2;\n        if (d2 > $2a5e53fd99b4041c$var$FLT_EPSILON && d3 > $2a5e53fd99b4041c$var$FLT_EPSILON) {\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($2a5e53fd99b4041c$var$mAngleTolerance < $2a5e53fd99b4041c$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da2 >= pi) da2 = 2 * pi - da2;\n                if (da1 + da2 < $2a5e53fd99b4041c$var$mAngleTolerance) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                if ($2a5e53fd99b4041c$var$mCuspLimit !== 0) {\n                    if (da1 > $2a5e53fd99b4041c$var$mCuspLimit) {\n                        points.push(x2, y2);\n                        return;\n                    }\n                    if (da2 > $2a5e53fd99b4041c$var$mCuspLimit) {\n                        points.push(x3, y3);\n                        return;\n                    }\n                }\n            }\n        } else if (d2 > $2a5e53fd99b4041c$var$FLT_EPSILON) {\n            if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($2a5e53fd99b4041c$var$mAngleTolerance < $2a5e53fd99b4041c$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da1 < $2a5e53fd99b4041c$var$mAngleTolerance) {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n                    return;\n                }\n                if ($2a5e53fd99b4041c$var$mCuspLimit !== 0) {\n                    if (da1 > $2a5e53fd99b4041c$var$mCuspLimit) {\n                        points.push(x2, y2);\n                        return;\n                    }\n                }\n            }\n        } else if (d3 > $2a5e53fd99b4041c$var$FLT_EPSILON) {\n            if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($2a5e53fd99b4041c$var$mAngleTolerance < $2a5e53fd99b4041c$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da1 < $2a5e53fd99b4041c$var$mAngleTolerance) {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n                    return;\n                }\n                if ($2a5e53fd99b4041c$var$mCuspLimit !== 0) {\n                    if (da1 > $2a5e53fd99b4041c$var$mCuspLimit) {\n                        points.push(x3, y3);\n                        return;\n                    }\n                }\n            }\n        } else {\n            dx = x1234 - (x1 + x4) / 2;\n            dy = y1234 - (y1 + y4) / 2;\n            if (dx * dx + dy * dy <= distanceTolerance) {\n                points.push(x1234, y1234);\n                return;\n            }\n        }\n    }\n    $2a5e53fd99b4041c$var$recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    $2a5e53fd99b4041c$var$recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n});\nparcelRegister(\"inK6t\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsContextSystem\", function () { return $c6470e81ca790c51$export$f2f3ca33e4c65172; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $4ukOR = parcelRequire(\"4ukOR\");\n\nvar $c0cbH = parcelRequire(\"c0cbH\");\n\nvar $9nXu5 = parcelRequire(\"9nXu5\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $dLv5L = parcelRequire(\"dLv5L\");\n\nvar $7gnh5 = parcelRequire(\"7gnh5\");\n\"use strict\";\nclass $c6470e81ca790c51$export$e3e348c254036d55 {\n    constructor(){\n        this.batches = [];\n        this.geometryData = {\n            vertices: [],\n            uvs: [],\n            indices: []\n        };\n    }\n}\nclass $c6470e81ca790c51$export$9b6a6c5b37fc8f49 {\n    constructor(){\n        this.batcher = new (0, $c0cbH.DefaultBatcher)();\n        this.instructions = new (0, $9nXu5.InstructionSet)();\n    }\n    init() {\n        this.instructions.reset();\n    }\n    /**\n   * @deprecated since version 8.0.0\n   * Use `batcher.geometry` instead.\n   * @see {Batcher#geometry}\n   */ get geometry() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_3_4), \"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.\");\n        return this.batcher.geometry;\n    }\n}\nconst $c6470e81ca790c51$var$_GraphicsContextSystem = class _GraphicsContextSystem {\n    constructor(renderer){\n        // the root context batches, used to either make a batch or geometry\n        // all graphics use this as a base\n        this._gpuContextHash = {};\n        // used for non-batchable graphics\n        this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n        renderer.renderableGC.addManagedHash(this, \"_gpuContextHash\");\n        renderer.renderableGC.addManagedHash(this, \"_graphicsDataContextHash\");\n    }\n    /**\n   * Runner init called, update the default options\n   * @ignore\n   */ init(options) {\n        _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n    getContextRenderData(context) {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n    // Context management functions\n    updateGpuContext(context) {\n        let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n        if (context.dirty) {\n            if (gpuContext) this._cleanGraphicsContextData(context);\n            else gpuContext = this._initContext(context);\n            (0, $7gnh5.buildContextBatches)(context, gpuContext);\n            const batchMode = context.batchMode;\n            if (context.customShader || batchMode === \"no-batch\") gpuContext.isBatchable = false;\n            else if (batchMode === \"auto\") gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n            context.dirty = false;\n        }\n        return gpuContext;\n    }\n    getGpuContext(context) {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n    _initContextRenderData(context) {\n        const graphicsData = (0, $dLv5L.BigPool).get($c6470e81ca790c51$export$9b6a6c5b37fc8f49);\n        const { batches: batches, geometryData: geometryData } = this._gpuContextHash[context.uid];\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n        for(let i = 0; i < batches.length; i++)batches[i].applyTransform = false;\n        const batcher = graphicsData.batcher;\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n        batcher.begin();\n        for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batcher.add(batch);\n        }\n        batcher.finish(graphicsData.instructions);\n        const geometry = batcher.geometry;\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n        const drawBatches = batcher.batches;\n        for(let i = 0; i < drawBatches.length; i++){\n            const batch = drawBatches[i];\n            batch.bindGroup = (0, $4ukOR.getTextureBatchBindGroup)(batch.textures.textures, batch.textures.count);\n        }\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n        return graphicsData;\n    }\n    _initContext(context) {\n        const gpuContext = new $c6470e81ca790c51$export$e3e348c254036d55();\n        gpuContext.context = context;\n        this._gpuContextHash[context.uid] = gpuContext;\n        context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n        return this._gpuContextHash[context.uid];\n    }\n    onGraphicsContextDestroy(context) {\n        this._cleanGraphicsContextData(context);\n        context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n        this._gpuContextHash[context.uid] = null;\n    }\n    _cleanGraphicsContextData(context) {\n        const gpuContext = this._gpuContextHash[context.uid];\n        if (!gpuContext.isBatchable) {\n            if (this._graphicsDataContextHash[context.uid]) {\n                (0, $dLv5L.BigPool).return(this.getContextRenderData(context));\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n        if (gpuContext.batches) gpuContext.batches.forEach((batch)=>{\n            (0, $dLv5L.BigPool).return(batch);\n        });\n    }\n    destroy() {\n        for(const i in this._gpuContextHash)if (this._gpuContextHash[i]) this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n    }\n};\n/** @ignore */ $c6470e81ca790c51$var$_GraphicsContextSystem.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).WebGLSystem,\n        (0, $kFA6i.ExtensionType).WebGPUSystem,\n        (0, $kFA6i.ExtensionType).CanvasSystem\n    ],\n    name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */ $c6470e81ca790c51$var$_GraphicsContextSystem.defaultOptions = {\n    /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */ bezierSmoothness: 0.5\n};\nlet $c6470e81ca790c51$export$f2f3ca33e4c65172 = $c6470e81ca790c51$var$_GraphicsContextSystem;\n\n});\nparcelRegister(\"4ukOR\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTextureBatchBindGroup\", function () { return $49422cac07553829$export$84c26df82650dc9b; });\n\nvar $lc03N = parcelRequire(\"lc03N\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $2nbUJ = parcelRequire(\"2nbUJ\");\n\"use strict\";\nconst $49422cac07553829$var$cachedGroups = {};\nfunction $49422cac07553829$export$84c26df82650dc9b(textures, size) {\n    let uid = 2166136261;\n    for(let i = 0; i < size; i++){\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n    return $49422cac07553829$var$cachedGroups[uid] || $49422cac07553829$var$generateTextureBatchBindGroup(textures, size, uid);\n}\nlet $49422cac07553829$var$maxTextures = 0;\nfunction $49422cac07553829$var$generateTextureBatchBindGroup(textures, size, key) {\n    const bindGroupResources = {};\n    let bindIndex = 0;\n    if (!$49422cac07553829$var$maxTextures) $49422cac07553829$var$maxTextures = (0, $2nbUJ.getMaxTexturesPerBatch)();\n    for(let i = 0; i < $49422cac07553829$var$maxTextures; i++){\n        const texture = i < size ? textures[i] : (0, $4YnyE.Texture).EMPTY.source;\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n    const bindGroup = new (0, $lc03N.BindGroup)(bindGroupResources);\n    $49422cac07553829$var$cachedGroups[key] = bindGroup;\n    return bindGroup;\n}\n\n});\nparcelRegister(\"lc03N\", function(module, exports) {\n\n$parcel$export(module.exports, \"BindGroup\", function () { return $8dd82b22d6c6be67$export$6f452ee382def63c; });\n\"use strict\";\nclass $8dd82b22d6c6be67$export$6f452ee382def63c {\n    /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */ constructor(resources){\n        /** The resources that are bound together for use by a shader. */ this.resources = /* @__PURE__ */ Object.create(null);\n        this._dirty = true;\n        let index = 0;\n        for(const i in resources){\n            const resource = resources[i];\n            this.setResource(resource, index++);\n        }\n        this._updateKey();\n    }\n    /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */ _updateKey() {\n        if (!this._dirty) return;\n        this._dirty = false;\n        const keyParts = [];\n        let index = 0;\n        for(const i in this.resources)keyParts[index++] = this.resources[i]._resourceId;\n        this._key = keyParts.join(\"|\");\n    }\n    /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */ setResource(resource, index) {\n        const currentResource = this.resources[index];\n        if (resource === currentResource) return;\n        if (currentResource) resource.off?.(\"change\", this.onResourceChange, this);\n        resource.on?.(\"change\", this.onResourceChange, this);\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n    /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */ getResource(index) {\n        return this.resources[index];\n    }\n    /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */ _touch(tick) {\n        const resources = this.resources;\n        for(const i in resources)resources[i]._touched = tick;\n    }\n    /** Destroys this bind group and removes all listeners. */ destroy() {\n        const resources = this.resources;\n        for(const i in resources){\n            const resource = resources[i];\n            resource.off?.(\"change\", this.onResourceChange, this);\n        }\n        this.resources = null;\n    }\n    onResourceChange(resource) {\n        this._dirty = true;\n        if (resource.destroyed) {\n            const resources = this.resources;\n            for(const i in resources)if (resources[i] === resource) resources[i] = null;\n        } else this._updateKey();\n    }\n}\n\n});\n\nparcelRegister(\"2nbUJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"getMaxTexturesPerBatch\", function () { return $9709da504abace0e$export$313b92466c30ee73; });\n\nvar $cQZoA = parcelRequire(\"cQZoA\");\n\nvar $hsqkK = parcelRequire(\"hsqkK\");\n\"use strict\";\nlet $9709da504abace0e$var$maxTexturesPerBatchCache = null;\nfunction $9709da504abace0e$export$313b92466c30ee73() {\n    if ($9709da504abace0e$var$maxTexturesPerBatchCache) return $9709da504abace0e$var$maxTexturesPerBatchCache;\n    const gl = (0, $cQZoA.getTestContext)();\n    $9709da504abace0e$var$maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    $9709da504abace0e$var$maxTexturesPerBatchCache = (0, $hsqkK.checkMaxIfStatementsInShader)($9709da504abace0e$var$maxTexturesPerBatchCache, gl);\n    gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    return $9709da504abace0e$var$maxTexturesPerBatchCache;\n}\n\n});\nparcelRegister(\"cQZoA\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTestContext\", function () { return $57c7d5024495d73f$export$f034b2d55f8df08b; });\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\"use strict\";\nlet $57c7d5024495d73f$var$context;\nfunction $57c7d5024495d73f$export$f034b2d55f8df08b() {\n    if (!$57c7d5024495d73f$var$context || $57c7d5024495d73f$var$context?.isContextLost()) {\n        const canvas = (0, $d0V4H.DOMAdapter).get().createCanvas();\n        $57c7d5024495d73f$var$context = canvas.getContext(\"webgl\", {});\n    }\n    return $57c7d5024495d73f$var$context;\n}\n\n});\n\nparcelRegister(\"hsqkK\", function(module, exports) {\n\n$parcel$export(module.exports, \"checkMaxIfStatementsInShader\", function () { return $fa0b436be19527d6$export$fb6ad4e758d74cc0; });\n\"use strict\";\nconst $fa0b436be19527d6$var$fragTemplate = [\n    \"precision mediump float;\",\n    \"void main(void){\",\n    \"float test = 0.1;\",\n    \"%forloop%\",\n    \"gl_FragColor = vec4(0.0);\",\n    \"}\"\n].join(\"\\n\");\nfunction $fa0b436be19527d6$var$generateIfTestSrc(maxIfs) {\n    let src = \"\";\n    for(let i = 0; i < maxIfs; ++i){\n        if (i > 0) src += \"\\nelse \";\n        if (i < maxIfs - 1) src += `if(test == ${i}.0){}`;\n    }\n    return src;\n}\nfunction $fa0b436be19527d6$export$fb6ad4e758d74cc0(maxIfs, gl) {\n    if (maxIfs === 0) throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n    try {\n        while(true){\n            const fragmentSrc = $fa0b436be19527d6$var$fragTemplate.replace(/%forloop%/gi, $fa0b436be19527d6$var$generateIfTestSrc(maxIfs));\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) maxIfs = maxIfs / 2 | 0;\n            else break;\n        }\n    } finally{\n        gl.deleteShader(shader);\n    }\n    return maxIfs;\n}\n\n});\n\n\n\nparcelRegister(\"c0cbH\", function(module, exports) {\n\n$parcel$export(module.exports, \"DefaultBatcher\", function () { return $929d647851e09b11$export$34bf80542893bcb; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $cdPyH = parcelRequire(\"cdPyH\");\n\nvar $52hCV = parcelRequire(\"52hCV\");\n\nvar $VBW7g = parcelRequire(\"VBW7g\");\n\"use strict\";\nlet $929d647851e09b11$var$defaultShader = null;\nconst $929d647851e09b11$var$_DefaultBatcher = class _DefaultBatcher extends (0, $cdPyH.Batcher) {\n    constructor(){\n        super(...arguments);\n        this.geometry = new (0, $52hCV.BatchGeometry)();\n        this.shader = $929d647851e09b11$var$defaultShader || ($929d647851e09b11$var$defaultShader = new (0, $VBW7g.DefaultShader)(this.maxTextures));\n        this.name = _DefaultBatcher.extension.name;\n        /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */ this.vertexSize = 6;\n    }\n    /**\n   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n   * @param element - The DefaultBatchableMeshElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */ packAttributes(element, float32View, uint32View, index, textureId) {\n        const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n        const wt = element.transform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n        const { positions: positions, uvs: uvs } = element;\n        const argb = element.color;\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n        for(let i = offset; i < end; i++){\n            const i2 = i * 2;\n            const x = positions[i2];\n            const y = positions[i2 + 1];\n            float32View[index++] = a * x + c * y + tx;\n            float32View[index++] = d * y + b * x + ty;\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[i2 + 1];\n            uint32View[index++] = argb;\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n    /**\n   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n   * @param element - The DefaultBatchableQuadElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */ packQuadAttributes(element, float32View, uint32View, index, textureId) {\n        const texture = element.texture;\n        const wt = element.transform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n        const bounds = element.bounds;\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n        const uvs = texture.uvs;\n        const argb = element.color;\n        const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n        float32View[index + 0] = a * w1 + c * h1 + tx;\n        float32View[index + 1] = d * h1 + b * w1 + ty;\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        float32View[index + 6] = a * w0 + c * h1 + tx;\n        float32View[index + 7] = d * h1 + b * w0 + ty;\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n        float32View[index + 12] = a * w0 + c * h0 + tx;\n        float32View[index + 13] = d * h0 + b * w0 + ty;\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n        float32View[index + 18] = a * w1 + c * h0 + tx;\n        float32View[index + 19] = d * h0 + b * w1 + ty;\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n};\n/** @ignore */ $929d647851e09b11$var$_DefaultBatcher.extension = {\n    type: [\n        (0, $kFA6i.ExtensionType).Batcher\n    ],\n    name: \"default\"\n};\nlet $929d647851e09b11$export$34bf80542893bcb = $929d647851e09b11$var$_DefaultBatcher;\n\n});\nparcelRegister(\"cdPyH\", function(module, exports) {\n\n$parcel$export(module.exports, \"Batcher\", function () { return $6dd97214b150f91d$export$704b12ddc1dacdd2; });\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $3S0BG = parcelRequire(\"3S0BG\");\n\nvar $iOvyc = parcelRequire(\"iOvyc\");\n\nvar $ccFr4 = parcelRequire(\"ccFr4\");\n\nvar $2nbUJ = parcelRequire(\"2nbUJ\");\n\nvar $4iag5 = parcelRequire(\"4iag5\");\n\"use strict\";\nclass $6dd97214b150f91d$export$33b107562567fc47 {\n    constructor(){\n        this.renderPipeId = \"batch\";\n        this.action = \"startBatch\";\n        // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n        // public elementStart = 0;\n        // public elementSize = 0;\n        // for drawing..\n        this.start = 0;\n        this.size = 0;\n        this.textures = new (0, $4iag5.BatchTextureArray)();\n        this.blendMode = \"normal\";\n        this.topology = \"triangle-strip\";\n        this.canBundle = true;\n    }\n    destroy() {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\nconst $6dd97214b150f91d$var$batchPool = [];\nlet $6dd97214b150f91d$var$batchPoolIndex = 0;\nfunction $6dd97214b150f91d$var$getBatchFromPool() {\n    return $6dd97214b150f91d$var$batchPoolIndex > 0 ? $6dd97214b150f91d$var$batchPool[--$6dd97214b150f91d$var$batchPoolIndex] : new $6dd97214b150f91d$export$33b107562567fc47();\n}\nfunction $6dd97214b150f91d$var$returnBatchToPool(batch) {\n    $6dd97214b150f91d$var$batchPool[$6dd97214b150f91d$var$batchPoolIndex++] = batch;\n}\nlet $6dd97214b150f91d$var$BATCH_TICK = 0;\nconst $6dd97214b150f91d$var$_Batcher = class _Batcher {\n    constructor(options = {}){\n        /** unique id for this batcher */ this.uid = (0, $fTJzX.uid)(\"batcher\");\n        /** Indicates whether the batch data has been modified and needs updating. */ this.dirty = true;\n        /** The current index of the batch being processed. */ this.batchIndex = 0;\n        /** An array of all batches created during the current rendering process. */ this.batches = [];\n        this._elements = [];\n        _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? (0, $2nbUJ.getMaxTexturesPerBatch)();\n        options = {\n            ..._Batcher.defaultOptions,\n            ...options\n        };\n        const { maxTextures: maxTextures, attributesInitialSize: attributesInitialSize, indicesInitialSize: indicesInitialSize } = options;\n        this.attributeBuffer = new (0, $3S0BG.ViewableBuffer)(attributesInitialSize * 4);\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n        this.maxTextures = maxTextures;\n    }\n    begin() {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n        for(let i = 0; i < this.batchIndex; i++)$6dd97214b150f91d$var$returnBatchToPool(this.batches[i]);\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n        this.dirty = true;\n    }\n    add(batchableObject) {\n        this._elements[this.elementSize++] = batchableObject;\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += batchableObject.attributeSize * this.vertexSize;\n    }\n    checkAndUpdateTexture(batchableObject, texture) {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n        if (!textureId && textureId !== 0) return false;\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n        return true;\n    }\n    updateElement(batchableObject) {\n        this.dirty = true;\n        const attributeBuffer = this.attributeBuffer;\n        if (batchableObject.packAsQuad) this.packQuadAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId);\n        else this.packAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId);\n    }\n    /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */ break(instructionSet) {\n        const elements = this._elements;\n        if (!elements[this.elementStart]) return;\n        let batch = $6dd97214b150f91d$var$getBatchFromPool();\n        let textureBatch = batch.textures;\n        textureBatch.clear();\n        const firstElement = elements[this.elementStart];\n        let blendMode = (0, $ccFr4.getAdjustedBlendModeBlend)(firstElement.blendMode, firstElement.texture._source);\n        let topology = firstElement.topology;\n        if (this.attributeSize * 4 > this.attributeBuffer.size) this._resizeAttributeBuffer(this.attributeSize * 4);\n        if (this.indexSize > this.indexBuffer.length) this._resizeIndexBuffer(this.indexSize);\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n        let action = \"startBatch\";\n        const maxTextures = this.maxTextures;\n        for(let i = this.elementStart; i < this.elementSize; ++i){\n            const element = elements[i];\n            elements[i] = null;\n            const texture = element.texture;\n            const source = texture._source;\n            const adjustedBlendMode = (0, $ccFr4.getAdjustedBlendModeBlend)(element.blendMode, source);\n            const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n            if (source._batchTick === $6dd97214b150f91d$var$BATCH_TICK && !breakRequired) {\n                element._textureId = source._textureBindLocation;\n                size += element.indexSize;\n                if (element.packAsQuad) {\n                    this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId);\n                    this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);\n                } else {\n                    this.packAttributes(element, f32, u32, element._attributeStart, element._textureId);\n                    this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);\n                }\n                element._batch = batch;\n                continue;\n            }\n            source._batchTick = $6dd97214b150f91d$var$BATCH_TICK;\n            if (textureBatch.count >= maxTextures || breakRequired) {\n                this._finishBatch(batch, start, size - start, textureBatch, blendMode, topology, instructionSet, action);\n                action = \"renderBatch\";\n                start = size;\n                blendMode = adjustedBlendMode;\n                topology = element.topology;\n                batch = $6dd97214b150f91d$var$getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n                ++$6dd97214b150f91d$var$BATCH_TICK;\n            }\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n            size += element.indexSize;\n            if (element.packAsQuad) {\n                this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId);\n                this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);\n            } else {\n                this.packAttributes(element, f32, u32, element._attributeStart, element._textureId);\n                this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);\n            }\n        }\n        if (textureBatch.count > 0) {\n            this._finishBatch(batch, start, size - start, textureBatch, blendMode, topology, instructionSet, action);\n            start = size;\n            ++$6dd97214b150f91d$var$BATCH_TICK;\n        }\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n    _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.topology = topology;\n        batch.start = indexStart;\n        batch.size = indexSize;\n        ++$6dd97214b150f91d$var$BATCH_TICK;\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n    finish(instructionSet) {\n        this.break(instructionSet);\n    }\n    /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */ ensureAttributeBuffer(size) {\n        if (size * 4 <= this.attributeBuffer.size) return;\n        this._resizeAttributeBuffer(size * 4);\n    }\n    /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */ ensureIndexBuffer(size) {\n        if (size <= this.indexBuffer.length) return;\n        this._resizeIndexBuffer(size);\n    }\n    _resizeAttributeBuffer(size) {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n        const newArrayBuffer = new (0, $3S0BG.ViewableBuffer)(newSize);\n        (0, $iOvyc.fastCopy)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n        this.attributeBuffer = newArrayBuffer;\n    }\n    _resizeIndexBuffer(size) {\n        const indexBuffer = this.indexBuffer;\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n        newSize += newSize % 2;\n        const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) for(let i = 0; i < indexBuffer.length; i++)newIndexBuffer[i] = indexBuffer[i];\n        else (0, $iOvyc.fastCopy)(indexBuffer.buffer, newIndexBuffer.buffer);\n        this.indexBuffer = newIndexBuffer;\n    }\n    packQuadIndex(indexBuffer, index, indicesOffset) {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n    packIndex(element, indexBuffer, index, indicesOffset) {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n        for(let i = 0; i < size; i++)indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n    }\n    destroy() {\n        for(let i = 0; i < this.batches.length; i++)$6dd97214b150f91d$var$returnBatchToPool(this.batches[i]);\n        this.batches = null;\n        for(let i = 0; i < this._elements.length; i++)this._elements[i]._batch = null;\n        this._elements = null;\n        this.indexBuffer = null;\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n};\n$6dd97214b150f91d$var$_Batcher.defaultOptions = {\n    maxTextures: null,\n    attributesInitialSize: 4,\n    indicesInitialSize: 6\n};\nlet $6dd97214b150f91d$export$704b12ddc1dacdd2 = $6dd97214b150f91d$var$_Batcher;\n\n});\nparcelRegister(\"3S0BG\", function(module, exports) {\n\n$parcel$export(module.exports, \"ViewableBuffer\", function () { return $5270473618e0032a$export$4fdbf0662aa3047a; });\n\"use strict\";\nclass $5270473618e0032a$export$4fdbf0662aa3047a {\n    constructor(sizeOrBuffer){\n        if (typeof sizeOrBuffer === \"number\") this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        else if (sizeOrBuffer instanceof Uint8Array) this.rawBinaryData = sizeOrBuffer.buffer;\n        else this.rawBinaryData = sizeOrBuffer;\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n        this.size = this.rawBinaryData.byteLength;\n    }\n    /** View on the raw binary data as a `Int8Array`. */ get int8View() {\n        if (!this._int8View) this._int8View = new Int8Array(this.rawBinaryData);\n        return this._int8View;\n    }\n    /** View on the raw binary data as a `Uint8Array`. */ get uint8View() {\n        if (!this._uint8View) this._uint8View = new Uint8Array(this.rawBinaryData);\n        return this._uint8View;\n    }\n    /**  View on the raw binary data as a `Int16Array`. */ get int16View() {\n        if (!this._int16View) this._int16View = new Int16Array(this.rawBinaryData);\n        return this._int16View;\n    }\n    /** View on the raw binary data as a `Int32Array`. */ get int32View() {\n        if (!this._int32View) this._int32View = new Int32Array(this.rawBinaryData);\n        return this._int32View;\n    }\n    /** View on the raw binary data as a `Float64Array`. */ get float64View() {\n        if (!this._float64Array) this._float64Array = new Float64Array(this.rawBinaryData);\n        return this._float64Array;\n    }\n    /** View on the raw binary data as a `BigUint64Array`. */ get bigUint64View() {\n        if (!this._bigUint64Array) this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        return this._bigUint64Array;\n    }\n    /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */ view(type) {\n        return this[`${type}View`];\n    }\n    /** Destroys all buffer references. Do not use after calling this. */ destroy() {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n    /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */ static sizeOf(type) {\n        switch(type){\n            case \"int8\":\n            case \"uint8\":\n                return 1;\n            case \"int16\":\n            case \"uint16\":\n                return 2;\n            case \"int32\":\n            case \"uint32\":\n            case \"float32\":\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n\n});\n\nparcelRegister(\"iOvyc\", function(module, exports) {\n\n$parcel$export(module.exports, \"fastCopy\", function () { return $607c9d28533128bf$export$c691b0c42debe682; });\n\"use strict\";\nfunction $607c9d28533128bf$export$c691b0c42debe682(sourceBuffer, destinationBuffer) {\n    const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n    destinationFloat64View.set(sourceFloat64View);\n    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n    if (remainingBytes > 0) {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n\n});\n\nparcelRegister(\"ccFr4\", function(module, exports) {\n\n$parcel$export(module.exports, \"getAdjustedBlendModeBlend\", function () { return $e4ad5d3a4270ea86$export$ab2fc5cf3fe899fe; });\n\nvar $6MbTD = parcelRequire(\"6MbTD\");\n\"use strict\";\nfunction $e4ad5d3a4270ea86$export$ab2fc5cf3fe899fe(blendMode, textureSource) {\n    if (textureSource.alphaMode === \"no-premultiply-alpha\") return (0, $6MbTD.BLEND_TO_NPM)[blendMode] || blendMode;\n    return blendMode;\n}\n\n});\nparcelRegister(\"6MbTD\", function(module, exports) {\n\n$parcel$export(module.exports, \"BLEND_TO_NPM\", function () { return $9609253dda04f98f$export$8c0bd2ccaa4a8d5e; });\n$parcel$export(module.exports, \"STENCIL_MODES\", function () { return $9609253dda04f98f$export$c250b85d73a91bdf; });\n\"use strict\";\nconst $9609253dda04f98f$export$8c0bd2ccaa4a8d5e = {\n    normal: \"normal-npm\",\n    add: \"add-npm\",\n    screen: \"screen-npm\"\n};\nvar $9609253dda04f98f$export$c250b85d73a91bdf = /* @__PURE__ */ ((STENCIL_MODES2)=>{\n    STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n    STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n    STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n    STENCIL_MODES2[STENCIL_MODES2[\"INVERSE_MASK_ACTIVE\"] = 3] = \"INVERSE_MASK_ACTIVE\";\n    STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 4] = \"RENDERING_MASK_REMOVE\";\n    STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 5] = \"NONE\";\n    return STENCIL_MODES2;\n})($9609253dda04f98f$export$c250b85d73a91bdf || {});\n\n});\n\n\nparcelRegister(\"4iag5\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchTextureArray\", function () { return $2f1e6c41cc08f185$export$aa760e0febf1a758; });\n\"use strict\";\nclass $2f1e6c41cc08f185$export$aa760e0febf1a758 {\n    constructor(){\n        /** Respective locations for textures. */ this.ids = /* @__PURE__ */ Object.create(null);\n        this.textures = [];\n        this.count = 0;\n    }\n    /** Clear the textures and their locations. */ clear() {\n        for(let i = 0; i < this.count; i++){\n            const t = this.textures[i];\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n        this.count = 0;\n    }\n}\n\n});\n\n\nparcelRegister(\"52hCV\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchGeometry\", function () { return $10a242cb20b9e4c2$export$449e8d355fd68e43; });\n\nvar $3wxNZ = parcelRequire(\"3wxNZ\");\n\nvar $iZU4m = parcelRequire(\"iZU4m\");\n\nvar $gT67d = parcelRequire(\"gT67d\");\n\"use strict\";\nconst $10a242cb20b9e4c2$var$placeHolderBufferData = new Float32Array(1);\nconst $10a242cb20b9e4c2$var$placeHolderIndexData = new Uint32Array(1);\nclass $10a242cb20b9e4c2$export$449e8d355fd68e43 extends (0, $gT67d.Geometry) {\n    constructor(){\n        const vertexSize = 6;\n        const attributeBuffer = new (0, $3wxNZ.Buffer)({\n            data: $10a242cb20b9e4c2$var$placeHolderBufferData,\n            label: \"attribute-batch-buffer\",\n            usage: (0, $iZU4m.BufferUsage).VERTEX | (0, $iZU4m.BufferUsage).COPY_DST,\n            shrinkToFit: false\n        });\n        const indexBuffer = new (0, $3wxNZ.Buffer)({\n            data: $10a242cb20b9e4c2$var$placeHolderIndexData,\n            label: \"index-batch-buffer\",\n            usage: (0, $iZU4m.BufferUsage).INDEX | (0, $iZU4m.BufferUsage).COPY_DST,\n            // | BufferUsage.STATIC,\n            shrinkToFit: false\n        });\n        const stride = vertexSize * 4;\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: \"float32x2\",\n                    stride: stride,\n                    offset: 0\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: \"float32x2\",\n                    stride: stride,\n                    offset: 8\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: \"unorm8x4\",\n                    stride: stride,\n                    offset: 16\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: \"uint16x2\",\n                    stride: stride,\n                    offset: 20\n                }\n            },\n            indexBuffer: indexBuffer\n        });\n    }\n}\n\n});\nparcelRegister(\"3wxNZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"Buffer\", function () { return $c5f6ca81ecc0d8c6$export$a143d493d941bafc; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $iZU4m = parcelRequire(\"iZU4m\");\n\"use strict\";\nclass $c5f6ca81ecc0d8c6$export$a143d493d941bafc extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */ constructor(options){\n        let { data: data, size: size } = options;\n        const { usage: usage, label: label, shrinkToFit: shrinkToFit } = options;\n        super();\n        /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */ /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */ /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */ /** a unique id for this uniform group used through the renderer */ this.uid = (0, $fTJzX.uid)(\"buffer\");\n        /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */ this._resourceType = \"buffer\";\n        /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */ this._resourceId = (0, $fTJzX.uid)(\"resource\");\n        /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */ this._touched = 0;\n        /**\n     * @internal\n     * @ignore\n     */ this._updateID = 1;\n        this._dataInt32 = null;\n        /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */ this.shrinkToFit = true;\n        /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */ this.destroyed = false;\n        if (data instanceof Array) data = new Float32Array(data);\n        this._data = data;\n        size ?? (size = data?.byteLength);\n        const mappedAtCreation = !!data;\n        this.descriptor = {\n            size: size,\n            usage: usage,\n            mappedAtCreation: mappedAtCreation,\n            label: label\n        };\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n    /** the data in the buffer */ get data() {\n        return this._data;\n    }\n    set data(value) {\n        this.setDataWithSize(value, value.length, true);\n    }\n    get dataInt32() {\n        if (!this._dataInt32) this._dataInt32 = new Int32Array(this.data.buffer);\n        return this._dataInt32;\n    }\n    /** whether the buffer is static or not */ get static() {\n        return !!(this.descriptor.usage & (0, $iZU4m.BufferUsage).STATIC);\n    }\n    set static(value) {\n        if (value) this.descriptor.usage |= (0, $iZU4m.BufferUsage).STATIC;\n        else this.descriptor.usage &= ~(0, $iZU4m.BufferUsage).STATIC;\n    }\n    /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */ setDataWithSize(value, size, syncGPU) {\n        this._updateID++;\n        this._updateSize = size * value.BYTES_PER_ELEMENT;\n        if (this._data === value) {\n            if (syncGPU) this.emit(\"update\", this);\n            return;\n        }\n        const oldData = this._data;\n        this._data = value;\n        this._dataInt32 = null;\n        if (!oldData || oldData.length !== value.length) {\n            if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {\n                if (syncGPU) this.emit(\"update\", this);\n            } else {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = (0, $fTJzX.uid)(\"resource\");\n                this.emit(\"change\", this);\n            }\n            return;\n        }\n        if (syncGPU) this.emit(\"update\", this);\n    }\n    /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */ update(sizeInBytes) {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n        this._updateID++;\n        this.emit(\"update\", this);\n    }\n    /** Destroys the buffer */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.emit(\"change\", this);\n        this._data = null;\n        this.descriptor = null;\n        this.removeAllListeners();\n    }\n}\n\n});\nparcelRegister(\"iZU4m\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferUsage\", function () { return $ed51a487692b4c37$export$f8deb2be8632fd10; });\n\"use strict\";\nvar $ed51a487692b4c37$export$f8deb2be8632fd10 = /* @__PURE__ */ ((BufferUsage2)=>{\n    BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n    BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n    BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n    BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n    BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n    BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n    BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n    BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n    BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n    BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n    BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n    return BufferUsage2;\n})($ed51a487692b4c37$export$f8deb2be8632fd10 || {});\n\n});\n\n\nparcelRegister(\"gT67d\", function(module, exports) {\n\n$parcel$export(module.exports, \"Geometry\", function () { return $31912b62f4ce0357$export$2db6c17465f94a2; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $dtW0p = parcelRequire(\"dtW0p\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $3wxNZ = parcelRequire(\"3wxNZ\");\n\nvar $5TxGW = parcelRequire(\"5TxGW\");\n\nvar $h12Mt = parcelRequire(\"h12Mt\");\n\"use strict\";\nfunction $31912b62f4ce0357$var$ensureIsAttribute(attribute) {\n    if (attribute instanceof (0, $3wxNZ.Buffer) || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) attribute = {\n        buffer: attribute\n    };\n    attribute.buffer = (0, $5TxGW.ensureIsBuffer)(attribute.buffer, false);\n    return attribute;\n}\nclass $31912b62f4ce0357$export$2db6c17465f94a2 extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */ constructor(options = {}){\n        super();\n        /** The unique id of the geometry. */ this.uid = (0, $fTJzX.uid)(\"geometry\");\n        /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */ this._layoutKey = 0;\n        /** the instance count of the geometry to draw */ this.instanceCount = 1;\n        this._bounds = new (0, $dtW0p.Bounds)();\n        this._boundsDirty = true;\n        const { attributes: attributes, indexBuffer: indexBuffer, topology: topology } = options;\n        this.buffers = [];\n        this.attributes = {};\n        if (attributes) for(const i in attributes)this.addAttribute(i, attributes[i]);\n        this.instanceCount = options.instanceCount ?? 1;\n        if (indexBuffer) this.addIndex(indexBuffer);\n        this.topology = topology || \"triangle-list\";\n    }\n    onBufferUpdate() {\n        this._boundsDirty = true;\n        this.emit(\"update\", this);\n    }\n    /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */ getAttribute(id) {\n        return this.attributes[id];\n    }\n    /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */ getIndex() {\n        return this.indexBuffer;\n    }\n    /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */ getBuffer(id) {\n        return this.getAttribute(id).buffer;\n    }\n    /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */ getSize() {\n        for(const i in this.attributes){\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n            return buffer.data.length / (attribute.stride / 4 || attribute.size);\n        }\n        return 0;\n    }\n    /**\n   * Adds an attribute to the geometry.\n   * @param name - The name of the attribute to add.\n   * @param attributeOption - The attribute option to add.\n   */ addAttribute(name, attributeOption) {\n        const attribute = $31912b62f4ce0357$var$ensureIsAttribute(attributeOption);\n        const bufferIndex = this.buffers.indexOf(attribute.buffer);\n        if (bufferIndex === -1) {\n            this.buffers.push(attribute.buffer);\n            attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n            attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n        }\n        this.attributes[name] = attribute;\n    }\n    /**\n   * Adds an index buffer to the geometry.\n   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n   */ addIndex(indexBuffer) {\n        this.indexBuffer = (0, $5TxGW.ensureIsBuffer)(indexBuffer, true);\n        this.buffers.push(this.indexBuffer);\n    }\n    /** Returns the bounds of the geometry. */ get bounds() {\n        if (!this._boundsDirty) return this._bounds;\n        this._boundsDirty = false;\n        return (0, $h12Mt.getGeometryBounds)(this, \"aPosition\", this._bounds);\n    }\n    /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */ destroy(destroyBuffers = false) {\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        if (destroyBuffers) this.buffers.forEach((buffer)=>buffer.destroy());\n        this.attributes = null;\n        this.buffers = null;\n        this.indexBuffer = null;\n        this._bounds = null;\n    }\n}\n\n});\nparcelRegister(\"5TxGW\", function(module, exports) {\n\n$parcel$export(module.exports, \"ensureIsBuffer\", function () { return $9370c4358dc389fa$export$e02adcb3cf335e03; });\n\nvar $3wxNZ = parcelRequire(\"3wxNZ\");\n\nvar $iZU4m = parcelRequire(\"iZU4m\");\n\"use strict\";\nfunction $9370c4358dc389fa$export$e02adcb3cf335e03(buffer, index) {\n    if (!(buffer instanceof (0, $3wxNZ.Buffer))) {\n        let usage = index ? (0, $iZU4m.BufferUsage).INDEX : (0, $iZU4m.BufferUsage).VERTEX;\n        if (buffer instanceof Array) {\n            if (index) {\n                buffer = new Uint32Array(buffer);\n                usage = (0, $iZU4m.BufferUsage).INDEX | (0, $iZU4m.BufferUsage).COPY_DST;\n            } else {\n                buffer = new Float32Array(buffer);\n                usage = (0, $iZU4m.BufferUsage).VERTEX | (0, $iZU4m.BufferUsage).COPY_DST;\n            }\n        }\n        buffer = new (0, $3wxNZ.Buffer)({\n            data: buffer,\n            label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n            usage: usage\n        });\n    }\n    return buffer;\n}\n\n});\n\nparcelRegister(\"h12Mt\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGeometryBounds\", function () { return $df6ac467d48f0069$export$ca8be28ec6402f29; });\n\"use strict\";\nfunction $df6ac467d48f0069$export$ca8be28ec6402f29(geometry, attributeId, bounds) {\n    const attribute = geometry.getAttribute(attributeId);\n    if (!attribute) {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n        return bounds;\n    }\n    const data = attribute.buffer.data;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    const byteSize = data.BYTES_PER_ELEMENT;\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || 8) / byteSize;\n    for(let i = offset; i < data.length; i += stride){\n        const x = data[i];\n        const y = data[i + 1];\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n    }\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n    return bounds;\n}\n\n});\n\n\n\nparcelRegister(\"VBW7g\", function(module, exports) {\n\n$parcel$export(module.exports, \"DefaultShader\", function () { return $55348d9ef4e3c13a$export$5ee16216350ebcbc; });\n\nvar $ir0EQ = parcelRequire(\"ir0EQ\");\n\nvar $1e9Az = parcelRequire(\"1e9Az\");\n\nvar $raSIq = parcelRequire(\"raSIq\");\n\nvar $V3X84 = parcelRequire(\"V3X84\");\n\nvar $7hpxC = parcelRequire(\"7hpxC\");\n\nvar $kmaR2 = parcelRequire(\"kmaR2\");\n\"use strict\";\nclass $55348d9ef4e3c13a$export$5ee16216350ebcbc extends (0, $kmaR2.Shader) {\n    constructor(maxTextures){\n        const glProgram = (0, $ir0EQ.compileHighShaderGlProgram)({\n            name: \"batch\",\n            bits: [\n                (0, $1e9Az.colorBitGl),\n                (0, $raSIq.generateTextureBatchBitGl)(maxTextures),\n                (0, $V3X84.roundPixelsBitGl)\n            ]\n        });\n        const gpuProgram = (0, $ir0EQ.compileHighShaderGpuProgram)({\n            name: \"batch\",\n            bits: [\n                (0, $1e9Az.colorBit),\n                (0, $raSIq.generateTextureBatchBit)(maxTextures),\n                (0, $V3X84.roundPixelsBit)\n            ]\n        });\n        super({\n            glProgram: glProgram,\n            gpuProgram: gpuProgram,\n            resources: {\n                batchSamplers: (0, $7hpxC.getBatchSamplersUniformGroup)(maxTextures)\n            }\n        });\n    }\n}\n\n});\nparcelRegister(\"ir0EQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHighShaderGpuProgram\", function () { return $7760537e44928577$export$af9d352c01aa9018; });\n$parcel$export(module.exports, \"compileHighShaderGlProgram\", function () { return $7760537e44928577$export$477b8252c7ecdf2; });\n\nvar $022Ud = parcelRequire(\"022Ud\");\n\nvar $4WM3f = parcelRequire(\"4WM3f\");\n\nvar $aa9WS = parcelRequire(\"aa9WS\");\n\nvar $lrogc = parcelRequire(\"lrogc\");\n\nvar $hJgms = parcelRequire(\"hJgms\");\n\"use strict\";\nfunction $7760537e44928577$export$af9d352c01aa9018({ bits: bits, name: name }) {\n    const source = (0, $aa9WS.compileHighShader)({\n        template: {\n            fragment: (0, $lrogc.fragmentGPUTemplate),\n            vertex: (0, $lrogc.vertexGPUTemplate)\n        },\n        bits: [\n            (0, $hJgms.globalUniformsBit),\n            ...bits\n        ]\n    });\n    return (0, $4WM3f.GpuProgram).from({\n        name: name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: \"main\"\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: \"main\"\n        }\n    });\n}\nfunction $7760537e44928577$export$477b8252c7ecdf2({ bits: bits, name: name }) {\n    return new (0, $022Ud.GlProgram)({\n        name: name,\n        ...(0, $aa9WS.compileHighShaderGl)({\n            template: {\n                vertex: (0, $lrogc.vertexGlTemplate),\n                fragment: (0, $lrogc.fragmentGlTemplate)\n            },\n            bits: [\n                (0, $hJgms.globalUniformsBitGl),\n                ...bits\n            ]\n        })\n    });\n}\n\n});\nparcelRegister(\"022Ud\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlProgram\", function () { return $b1097531dd0c3de5$export$64881d9ea0a969d7; });\n\nvar $eOVk3 = parcelRequire(\"eOVk3\");\n\nvar $5T1DG = parcelRequire(\"5T1DG\");\n\nvar $1tHpx = parcelRequire(\"1tHpx\");\n\nvar $dGqzH = parcelRequire(\"dGqzH\");\n\nvar $aRhge = parcelRequire(\"aRhge\");\n\nvar $93xFd = parcelRequire(\"93xFd\");\n\nvar $2dc9W = parcelRequire(\"2dc9W\");\n\"use strict\";\nconst $b1097531dd0c3de5$var$processes = {\n    stripVersion: // strips any version headers..\n    $2dc9W.stripVersion,\n    ensurePrecision: // adds precision string if not already present\n    $dGqzH.ensurePrecision,\n    addProgramDefines: // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    $1tHpx.addProgramDefines,\n    setProgramName: // add the program name to the shader\n    $93xFd.setProgramName,\n    insertVersion: // add the version string to the shader header\n    $aRhge.insertVersion\n};\nconst $b1097531dd0c3de5$var$programCache = /* @__PURE__ */ Object.create(null);\nconst $b1097531dd0c3de5$var$_GlProgram = class _GlProgram {\n    /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */ constructor(options){\n        options = {\n            ..._GlProgram.defaultOptions,\n            ...options\n        };\n        const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: \"highp\",\n                maxSupportedFragmentPrecision: (0, $5T1DG.getMaxFragmentPrecision)()\n            },\n            setProgramName: {\n                name: options.name\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n        Object.keys($b1097531dd0c3de5$var$processes).forEach((processKey)=>{\n            const processOptions = preprocessorOptions[processKey];\n            fragment = $b1097531dd0c3de5$var$processes[processKey](fragment, processOptions, true);\n            vertex = $b1097531dd0c3de5$var$processes[processKey](vertex, processOptions, false);\n        });\n        this.fragment = fragment;\n        this.vertex = vertex;\n        this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n        this._key = (0, $eOVk3.createIdFromString)(`${this.vertex}:${this.fragment}`, \"gl-program\");\n    }\n    /** destroys the program */ destroy() {\n        this.fragment = null;\n        this.vertex = null;\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n        this.transformFeedbackVaryings = null;\n    }\n    /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */ static from(options) {\n        const key = `${options.vertex}:${options.fragment}`;\n        if (!$b1097531dd0c3de5$var$programCache[key]) $b1097531dd0c3de5$var$programCache[key] = new _GlProgram(options);\n        return $b1097531dd0c3de5$var$programCache[key];\n    }\n};\n/** The default options used by the program. */ $b1097531dd0c3de5$var$_GlProgram.defaultOptions = {\n    preferredVertexPrecision: \"highp\",\n    preferredFragmentPrecision: \"mediump\"\n};\nlet $b1097531dd0c3de5$export$64881d9ea0a969d7 = $b1097531dd0c3de5$var$_GlProgram;\n\n});\nparcelRegister(\"eOVk3\", function(module, exports) {\n\n$parcel$export(module.exports, \"createIdFromString\", function () { return $835fabfe4cff138c$export$1e452c36dfe36a93; });\n\"use strict\";\nconst $835fabfe4cff138c$var$idCounts = /* @__PURE__ */ Object.create(null);\nconst $835fabfe4cff138c$var$idHash = /* @__PURE__ */ Object.create(null);\nfunction $835fabfe4cff138c$export$1e452c36dfe36a93(value, groupId) {\n    let id = $835fabfe4cff138c$var$idHash[value];\n    if (id === void 0) {\n        if ($835fabfe4cff138c$var$idCounts[groupId] === void 0) $835fabfe4cff138c$var$idCounts[groupId] = 1;\n        $835fabfe4cff138c$var$idHash[value] = id = $835fabfe4cff138c$var$idCounts[groupId]++;\n    }\n    return id;\n}\n\n});\n\nparcelRegister(\"5T1DG\", function(module, exports) {\n\n$parcel$export(module.exports, \"getMaxFragmentPrecision\", function () { return $d5b8e1bbaf57a0cb$export$428c38e64838140; });\n\nvar $cQZoA = parcelRequire(\"cQZoA\");\n\"use strict\";\nlet $d5b8e1bbaf57a0cb$var$maxFragmentPrecision;\nfunction $d5b8e1bbaf57a0cb$export$428c38e64838140() {\n    if (!$d5b8e1bbaf57a0cb$var$maxFragmentPrecision) {\n        $d5b8e1bbaf57a0cb$var$maxFragmentPrecision = \"mediump\";\n        const gl = (0, $cQZoA.getTestContext)();\n        if (gl) {\n            if (gl.getShaderPrecisionFormat) {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n                $d5b8e1bbaf57a0cb$var$maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n            }\n        }\n    }\n    return $d5b8e1bbaf57a0cb$var$maxFragmentPrecision;\n}\n\n});\n\nparcelRegister(\"1tHpx\", function(module, exports) {\n\n$parcel$export(module.exports, \"addProgramDefines\", function () { return $26bc2fd1c7ae4ff2$export$fba00ea8bc676dd1; });\n\"use strict\";\nfunction $26bc2fd1c7ae4ff2$export$fba00ea8bc676dd1(src, isES300, isFragment) {\n    if (isES300) return src;\n    if (isFragment) {\n        src = src.replace(\"out vec4 finalColor;\", \"\");\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\n});\n\nparcelRegister(\"dGqzH\", function(module, exports) {\n\n$parcel$export(module.exports, \"ensurePrecision\", function () { return $71413d144ba7fc37$export$899bdffb1b617f8b; });\n\"use strict\";\nfunction $71413d144ba7fc37$export$899bdffb1b617f8b(src, options, isFragment) {\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n    if (src.substring(0, 9) !== \"precision\") {\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n        if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") precision = \"mediump\";\n        return `precision ${precision} float;\n${src}`;\n    } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") return src.replace(\"precision highp\", \"precision mediump\");\n    return src;\n}\n\n});\n\nparcelRegister(\"aRhge\", function(module, exports) {\n\n$parcel$export(module.exports, \"insertVersion\", function () { return $5fb6a3bda79c7c4d$export$df5409633d2e06a0; });\n\"use strict\";\nfunction $5fb6a3bda79c7c4d$export$df5409633d2e06a0(src, isES300) {\n    if (!isES300) return src;\n    return `#version 300 es\n${src}`;\n}\n\n});\n\nparcelRegister(\"93xFd\", function(module, exports) {\n\n$parcel$export(module.exports, \"setProgramName\", function () { return $630fbc96c5656f65$export$fcd35f5a80d5e29b; });\n\"use strict\";\nconst $630fbc96c5656f65$var$fragmentNameCache = {};\nconst $630fbc96c5656f65$var$VertexNameCache = {};\nfunction $630fbc96c5656f65$export$fcd35f5a80d5e29b(src, { name: name = `pixi-program` }, isFragment = true) {\n    name = name.replace(/\\s+/g, \"-\");\n    name += isFragment ? \"-fragment\" : \"-vertex\";\n    const nameCache = isFragment ? $630fbc96c5656f65$var$fragmentNameCache : $630fbc96c5656f65$var$VertexNameCache;\n    if (nameCache[name]) {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    } else nameCache[name] = 1;\n    if (src.indexOf(\"#define SHADER_NAME\") !== -1) return src;\n    const shaderName = `#define SHADER_NAME ${name}`;\n    return `${shaderName}\n${src}`;\n}\n\n});\n\nparcelRegister(\"2dc9W\", function(module, exports) {\n\n$parcel$export(module.exports, \"stripVersion\", function () { return $0319ae549f9fc051$export$f71406e7a553e9e5; });\n\"use strict\";\nfunction $0319ae549f9fc051$export$f71406e7a553e9e5(src, isES300) {\n    if (!isES300) return src;\n    return src.replace(\"#version 300 es\", \"\");\n}\n\n});\n\n\nparcelRegister(\"4WM3f\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuProgram\", function () { return $45a80282ba06b89e$export$b7a31a3cdd61870; });\n\nvar $eOVk3 = parcelRequire(\"eOVk3\");\n\nvar $6HCQ5 = parcelRequire(\"6HCQ5\");\n\nvar $7Y09y = parcelRequire(\"7Y09y\");\n\nvar $icfjv = parcelRequire(\"icfjv\");\n\nvar $6NVlJ = parcelRequire(\"6NVlJ\");\n\nvar $BD5CG = parcelRequire(\"BD5CG\");\n\"use strict\";\nconst $45a80282ba06b89e$var$programCache = /* @__PURE__ */ Object.create(null);\nclass $45a80282ba06b89e$export$b7a31a3cdd61870 {\n    /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */ constructor(options){\n        /**\n     * @internal\n     * @ignore\n     */ this._layoutKey = 0;\n        /**\n     * @internal\n     * @ignore\n     */ this._attributeLocationsKey = 0;\n        const { fragment: fragment, vertex: vertex, layout: layout, gpuLayout: gpuLayout, name: name } = options;\n        this.name = name;\n        this.fragment = fragment;\n        this.vertex = vertex;\n        if (fragment.source === vertex.source) {\n            const structsAndGroups = (0, $7Y09y.extractStructAndGroups)(fragment.source);\n            this.structsAndGroups = structsAndGroups;\n        } else {\n            const vertexStructsAndGroups = (0, $7Y09y.extractStructAndGroups)(vertex.source);\n            const fragmentStructsAndGroups = (0, $7Y09y.extractStructAndGroups)(fragment.source);\n            this.structsAndGroups = (0, $BD5CG.removeStructAndGroupDuplicates)(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n        this.layout = layout ?? (0, $6NVlJ.generateLayoutHash)(this.structsAndGroups);\n        this.gpuLayout = gpuLayout ?? (0, $icfjv.generateGpuLayoutGroups)(this.structsAndGroups);\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n        this._generateProgramKey();\n    }\n    // TODO maker this pure\n    _generateProgramKey() {\n        const { vertex: vertex, fragment: fragment } = this;\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n        this._layoutKey = (0, $eOVk3.createIdFromString)(bigKey, \"program\");\n    }\n    get attributeData() {\n        this._attributeData ?? (this._attributeData = (0, $6HCQ5.extractAttributesFromGpuProgram)(this.vertex));\n        return this._attributeData;\n    }\n    /** destroys the program */ destroy() {\n        this.gpuLayout = null;\n        this.layout = null;\n        this.structsAndGroups = null;\n        this.fragment = null;\n        this.vertex = null;\n    }\n    /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */ static from(options) {\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n        if (!$45a80282ba06b89e$var$programCache[key]) $45a80282ba06b89e$var$programCache[key] = new $45a80282ba06b89e$export$b7a31a3cdd61870(options);\n        return $45a80282ba06b89e$var$programCache[key];\n    }\n}\n\n});\nparcelRegister(\"6HCQ5\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractAttributesFromGpuProgram\", function () { return $ee782742ab296bf5$export$b0efe5f01c53f69f; });\n\nvar $6Obke = parcelRequire(\"6Obke\");\n\"use strict\";\nconst $ee782742ab296bf5$var$WGSL_TO_VERTEX_TYPES = {\n    f32: \"float32\",\n    \"vec2<f32>\": \"float32x2\",\n    \"vec3<f32>\": \"float32x3\",\n    \"vec4<f32>\": \"float32x4\",\n    vec2f: \"float32x2\",\n    vec3f: \"float32x3\",\n    vec4f: \"float32x4\",\n    i32: \"sint32\",\n    \"vec2<i32>\": \"sint32x2\",\n    \"vec3<i32>\": \"sint32x3\",\n    \"vec4<i32>\": \"sint32x4\",\n    u32: \"uint32\",\n    \"vec2<u32>\": \"uint32x2\",\n    \"vec3<u32>\": \"uint32x3\",\n    \"vec4<u32>\": \"uint32x4\",\n    bool: \"uint32\",\n    \"vec2<bool>\": \"uint32x2\",\n    \"vec3<bool>\": \"uint32x3\",\n    \"vec4<bool>\": \"uint32x4\"\n};\nfunction $ee782742ab296bf5$export$b0efe5f01c53f69f({ source: source, entryPoint: entryPoint }) {\n    const results = {};\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n    if (mainVertStart !== -1) {\n        const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n        if (arrowFunctionStart !== -1) {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n            while((match = inputsRegex.exec(functionArgsSubstring)) !== null){\n                const format = $ee782742ab296bf5$var$WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format: format,\n                    stride: (0, $6Obke.getAttributeInfoFromFormat)(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0\n                };\n            }\n        }\n    }\n    return results;\n}\n\n});\nparcelRegister(\"6Obke\", function(module, exports) {\n\n$parcel$export(module.exports, \"getAttributeInfoFromFormat\", function () { return $17269f0d797fcd62$export$4da509c30cc6be33; });\n\"use strict\";\nconst $17269f0d797fcd62$var$attributeFormatData = {\n    uint8x2: {\n        size: 2,\n        stride: 2,\n        normalised: false\n    },\n    uint8x4: {\n        size: 4,\n        stride: 4,\n        normalised: false\n    },\n    sint8x2: {\n        size: 2,\n        stride: 2,\n        normalised: false\n    },\n    sint8x4: {\n        size: 4,\n        stride: 4,\n        normalised: false\n    },\n    unorm8x2: {\n        size: 2,\n        stride: 2,\n        normalised: true\n    },\n    unorm8x4: {\n        size: 4,\n        stride: 4,\n        normalised: true\n    },\n    snorm8x2: {\n        size: 2,\n        stride: 2,\n        normalised: true\n    },\n    snorm8x4: {\n        size: 4,\n        stride: 4,\n        normalised: true\n    },\n    uint16x2: {\n        size: 2,\n        stride: 4,\n        normalised: false\n    },\n    uint16x4: {\n        size: 4,\n        stride: 8,\n        normalised: false\n    },\n    sint16x2: {\n        size: 2,\n        stride: 4,\n        normalised: false\n    },\n    sint16x4: {\n        size: 4,\n        stride: 8,\n        normalised: false\n    },\n    unorm16x2: {\n        size: 2,\n        stride: 4,\n        normalised: true\n    },\n    unorm16x4: {\n        size: 4,\n        stride: 8,\n        normalised: true\n    },\n    snorm16x2: {\n        size: 2,\n        stride: 4,\n        normalised: true\n    },\n    snorm16x4: {\n        size: 4,\n        stride: 8,\n        normalised: true\n    },\n    float16x2: {\n        size: 2,\n        stride: 4,\n        normalised: false\n    },\n    float16x4: {\n        size: 4,\n        stride: 8,\n        normalised: false\n    },\n    float32: {\n        size: 1,\n        stride: 4,\n        normalised: false\n    },\n    float32x2: {\n        size: 2,\n        stride: 8,\n        normalised: false\n    },\n    float32x3: {\n        size: 3,\n        stride: 12,\n        normalised: false\n    },\n    float32x4: {\n        size: 4,\n        stride: 16,\n        normalised: false\n    },\n    uint32: {\n        size: 1,\n        stride: 4,\n        normalised: false\n    },\n    uint32x2: {\n        size: 2,\n        stride: 8,\n        normalised: false\n    },\n    uint32x3: {\n        size: 3,\n        stride: 12,\n        normalised: false\n    },\n    uint32x4: {\n        size: 4,\n        stride: 16,\n        normalised: false\n    },\n    sint32: {\n        size: 1,\n        stride: 4,\n        normalised: false\n    },\n    sint32x2: {\n        size: 2,\n        stride: 8,\n        normalised: false\n    },\n    sint32x3: {\n        size: 3,\n        stride: 12,\n        normalised: false\n    },\n    sint32x4: {\n        size: 4,\n        stride: 16,\n        normalised: false\n    }\n};\nfunction $17269f0d797fcd62$export$4da509c30cc6be33(format) {\n    return $17269f0d797fcd62$var$attributeFormatData[format] ?? $17269f0d797fcd62$var$attributeFormatData.float32;\n}\n\n});\n\n\nparcelRegister(\"7Y09y\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractStructAndGroups\", function () { return $89b56e8bab7cfe10$export$368e99a200562975; });\n\"use strict\";\nfunction $89b56e8bab7cfe10$export$368e99a200562975(wgsl) {\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n    const groups = wgsl.match(linePattern)?.map((item)=>({\n            group: parseInt(item.match(groupPattern)[1], 10),\n            binding: parseInt(item.match(bindingPattern)[1], 10),\n            name: item.match(namePattern)[2],\n            isUniform: item.match(namePattern)[1] === \"<uniform>\",\n            type: item.match(typePattern)[1]\n        }));\n    if (!groups) return {\n        groups: [],\n        structs: []\n    };\n    const structs = wgsl.match(structPattern)?.map((struct)=>{\n        const name = struct.match(structName)[1];\n        const members = struct.match(structMemberPattern).reduce((acc, member)=>{\n            const [name2, type] = member.split(\":\");\n            acc[name2.trim()] = type.trim();\n            return acc;\n        }, {});\n        if (!members) return null;\n        return {\n            name: name,\n            members: members\n        };\n    }).filter(({ name: name })=>groups.some((group)=>group.type === name)) ?? [];\n    return {\n        groups: groups,\n        structs: structs\n    };\n}\n\n});\n\nparcelRegister(\"icfjv\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateGpuLayoutGroups\", function () { return $afb6646ee191edf9$export$950011c0dc347495; });\n\nvar $8DNdW = parcelRequire(\"8DNdW\");\n\"use strict\";\nfunction $afb6646ee191edf9$export$950011c0dc347495({ groups: groups }) {\n    const layout = [];\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        if (!layout[group.group]) layout[group.group] = [];\n        if (group.isUniform) layout[group.group].push({\n            binding: group.binding,\n            visibility: (0, $8DNdW.ShaderStage).VERTEX | (0, $8DNdW.ShaderStage).FRAGMENT,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        else if (group.type === \"sampler\") layout[group.group].push({\n            binding: group.binding,\n            visibility: (0, $8DNdW.ShaderStage).FRAGMENT,\n            sampler: {\n                type: \"filtering\"\n            }\n        });\n        else if (group.type === \"texture_2d\") layout[group.group].push({\n            binding: group.binding,\n            visibility: (0, $8DNdW.ShaderStage).FRAGMENT,\n            texture: {\n                sampleType: \"float\",\n                viewDimension: \"2d\",\n                multisampled: false\n            }\n        });\n    }\n    return layout;\n}\n\n});\nparcelRegister(\"8DNdW\", function(module, exports) {\n\n$parcel$export(module.exports, \"ShaderStage\", function () { return $5c29b72d1e8b38f6$export$34a0cafc5a97ef31; });\n\"use strict\";\nvar $5c29b72d1e8b38f6$export$34a0cafc5a97ef31 = /* @__PURE__ */ ((ShaderStage2)=>{\n    ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n    ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n    ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n    return ShaderStage2;\n})($5c29b72d1e8b38f6$export$34a0cafc5a97ef31 || {});\n\n});\n\n\nparcelRegister(\"6NVlJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateLayoutHash\", function () { return $f04b8ec34b92ebbe$export$6a0f9650f9d4f875; });\n\"use strict\";\nfunction $f04b8ec34b92ebbe$export$6a0f9650f9d4f875({ groups: groups }) {\n    const layout = [];\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        if (!layout[group.group]) layout[group.group] = {};\n        layout[group.group][group.name] = group.binding;\n    }\n    return layout;\n}\n\n});\n\nparcelRegister(\"BD5CG\", function(module, exports) {\n\n$parcel$export(module.exports, \"removeStructAndGroupDuplicates\", function () { return $36305da6dd616aba$export$5f344e20ddfaa2d6; });\n\"use strict\";\nfunction $36305da6dd616aba$export$5f344e20ddfaa2d6(vertexStructsAndGroups, fragmentStructsAndGroups) {\n    const structNameSet = /* @__PURE__ */ new Set();\n    const dupeGroupKeySet = /* @__PURE__ */ new Set();\n    const structs = [\n        ...vertexStructsAndGroups.structs,\n        ...fragmentStructsAndGroups.structs\n    ].filter((struct)=>{\n        if (structNameSet.has(struct.name)) return false;\n        structNameSet.add(struct.name);\n        return true;\n    });\n    const groups = [\n        ...vertexStructsAndGroups.groups,\n        ...fragmentStructsAndGroups.groups\n    ].filter((group)=>{\n        const key = `${group.name}-${group.binding}`;\n        if (dupeGroupKeySet.has(key)) return false;\n        dupeGroupKeySet.add(key);\n        return true;\n    });\n    return {\n        structs: structs,\n        groups: groups\n    };\n}\n\n});\n\n\nparcelRegister(\"aa9WS\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHighShader\", function () { return $a09ce791f9044ff5$export$86219fd7a1c584d2; });\n$parcel$export(module.exports, \"compileHighShaderGl\", function () { return $a09ce791f9044ff5$export$ff7039b165d48f97; });\n\nvar $bbcL9 = parcelRequire(\"bbcL9\");\n\nvar $aedhe = parcelRequire(\"aedhe\");\n\nvar $90Bnm = parcelRequire(\"90Bnm\");\n\nvar $5iGoe = parcelRequire(\"5iGoe\");\n\nvar $22J0r = parcelRequire(\"22J0r\");\n\"use strict\";\nconst $a09ce791f9044ff5$var$cacheMap = /* @__PURE__ */ Object.create(null);\nconst $a09ce791f9044ff5$var$bitCacheMap = /* @__PURE__ */ new Map();\nlet $a09ce791f9044ff5$var$CACHE_UID = 0;\nfunction $a09ce791f9044ff5$export$86219fd7a1c584d2({ template: template, bits: bits }) {\n    const cacheId = $a09ce791f9044ff5$var$generateCacheId(template, bits);\n    if ($a09ce791f9044ff5$var$cacheMap[cacheId]) return $a09ce791f9044ff5$var$cacheMap[cacheId];\n    const { vertex: vertex, fragment: fragment } = $a09ce791f9044ff5$var$compileInputsAndOutputs(template, bits);\n    $a09ce791f9044ff5$var$cacheMap[cacheId] = $a09ce791f9044ff5$var$compileBits(vertex, fragment, bits);\n    return $a09ce791f9044ff5$var$cacheMap[cacheId];\n}\nfunction $a09ce791f9044ff5$export$ff7039b165d48f97({ template: template, bits: bits }) {\n    const cacheId = $a09ce791f9044ff5$var$generateCacheId(template, bits);\n    if ($a09ce791f9044ff5$var$cacheMap[cacheId]) return $a09ce791f9044ff5$var$cacheMap[cacheId];\n    $a09ce791f9044ff5$var$cacheMap[cacheId] = $a09ce791f9044ff5$var$compileBits(template.vertex, template.fragment, bits);\n    return $a09ce791f9044ff5$var$cacheMap[cacheId];\n}\nfunction $a09ce791f9044ff5$var$compileInputsAndOutputs(template, bits) {\n    const vertexFragments = bits.map((shaderBit)=>shaderBit.vertex).filter((v)=>!!v);\n    const fragmentFragments = bits.map((shaderBit)=>shaderBit.fragment).filter((v)=>!!v);\n    let compiledVertex = (0, $90Bnm.compileInputs)(vertexFragments, template.vertex, true);\n    compiledVertex = (0, $5iGoe.compileOutputs)(vertexFragments, compiledVertex);\n    const compiledFragment = (0, $90Bnm.compileInputs)(fragmentFragments, template.fragment, true);\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment\n    };\n}\nfunction $a09ce791f9044ff5$var$generateCacheId(template, bits) {\n    return bits.map((highFragment)=>{\n        if (!$a09ce791f9044ff5$var$bitCacheMap.has(highFragment)) $a09ce791f9044ff5$var$bitCacheMap.set(highFragment, $a09ce791f9044ff5$var$CACHE_UID++);\n        return $a09ce791f9044ff5$var$bitCacheMap.get(highFragment);\n    }).sort((a, b)=>a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction $a09ce791f9044ff5$var$compileBits(vertex, fragment, bits) {\n    const vertexParts = (0, $aedhe.compileHooks)(vertex);\n    const fragmentParts = (0, $aedhe.compileHooks)(fragment);\n    bits.forEach((shaderBit)=>{\n        (0, $bbcL9.addBits)(shaderBit.vertex, vertexParts, shaderBit.name);\n        (0, $bbcL9.addBits)(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n    return {\n        vertex: (0, $22J0r.injectBits)(vertex, vertexParts),\n        fragment: (0, $22J0r.injectBits)(fragment, fragmentParts)\n    };\n}\n\n});\nparcelRegister(\"bbcL9\", function(module, exports) {\n\n$parcel$export(module.exports, \"addBits\", function () { return $b701e37d650c1a99$export$38c21fb192fe3d9; });\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\"use strict\";\nfunction $b701e37d650c1a99$export$38c21fb192fe3d9(srcParts, parts, name) {\n    if (srcParts) for(const i in srcParts){\n        const id = i.toLocaleLowerCase();\n        const part = parts[id];\n        if (part) {\n            let sanitisedPart = srcParts[i];\n            if (i === \"header\") sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n            if (name) part.push(`//----${name}----//`);\n            part.push(sanitisedPart);\n        } else (0, $c9aw6.warn)(`${i} placement hook does not exist in shader`);\n    }\n}\n\n});\n\nparcelRegister(\"aedhe\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHooks\", function () { return $3eac7173799a5f62$export$17705ba43ca63936; });\n\"use strict\";\nconst $3eac7173799a5f62$export$a564a4c9984eee7d = /\\{\\{(.*?)\\}\\}/g;\nfunction $3eac7173799a5f62$export$17705ba43ca63936(programSrc) {\n    const parts = {};\n    const partMatches = programSrc.match($3eac7173799a5f62$export$a564a4c9984eee7d)?.map((hook)=>hook.replace(/[{()}]/g, \"\")) ?? [];\n    partMatches.forEach((hook)=>{\n        parts[hook] = [];\n    });\n    return parts;\n}\n\n});\n\nparcelRegister(\"90Bnm\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileInputs\", function () { return $a0beb39fbe2ad372$export$aa47df9391ef0455; });\n\"use strict\";\nfunction $a0beb39fbe2ad372$var$extractInputs(fragmentSource, out) {\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n    while((match = regex.exec(fragmentSource)) !== null)out.push(match[1]);\n}\nfunction $a0beb39fbe2ad372$export$aa47df9391ef0455(fragments, template, sort = false) {\n    const results = [];\n    $a0beb39fbe2ad372$var$extractInputs(template, results);\n    fragments.forEach((fragment)=>{\n        if (fragment.header) $a0beb39fbe2ad372$var$extractInputs(fragment.header, results);\n    });\n    const mainInput = results;\n    if (sort) mainInput.sort();\n    const finalString = mainInput.map((inValue, i)=>`       @location(${i}) ${inValue},`).join(\"\\n\");\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n    cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n    return cleanedString;\n}\n\n});\n\nparcelRegister(\"5iGoe\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileOutputs\", function () { return $600c78bd5d8f61e0$export$ae19cc473c7ab18; });\n\"use strict\";\nfunction $600c78bd5d8f61e0$var$extractOutputs(fragmentSource, out) {\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n    while((match = regex.exec(fragmentSource)) !== null)out.push(match[1]);\n}\nfunction $600c78bd5d8f61e0$var$extractVariableName(value) {\n    const regex = /\\b(\\w+)\\s*:/g;\n    const match = regex.exec(value);\n    return match ? match[1] : \"\";\n}\nfunction $600c78bd5d8f61e0$var$stripVariable(value) {\n    const regex = /@.*?\\s+/g;\n    return value.replace(regex, \"\");\n}\nfunction $600c78bd5d8f61e0$export$ae19cc473c7ab18(fragments, template) {\n    const results = [];\n    $600c78bd5d8f61e0$var$extractOutputs(template, results);\n    fragments.forEach((fragment)=>{\n        if (fragment.header) $600c78bd5d8f61e0$var$extractOutputs(fragment.header, results);\n    });\n    let index = 0;\n    const mainStruct = results.sort().map((inValue)=>{\n        if (inValue.indexOf(\"builtin\") > -1) return inValue;\n        return `@location(${index++}) ${inValue}`;\n    }).join(\",\\n\");\n    const mainStart = results.sort().map((inValue)=>`       var ${$600c78bd5d8f61e0$var$stripVariable(inValue)};`).join(\"\\n\");\n    const mainEnd = `return VSOutput(\n            ${results.sort().map((inValue)=>` ${$600c78bd5d8f61e0$var$extractVariableName(inValue)}`).join(\",\\n\")});`;\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n    compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n    compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n    compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n    return compiledCode;\n}\n\n});\n\nparcelRegister(\"22J0r\", function(module, exports) {\n\n$parcel$export(module.exports, \"injectBits\", function () { return $bc3b940d9a709dcf$export$83c47c7340456c75; });\n\"use strict\";\nfunction $bc3b940d9a709dcf$export$83c47c7340456c75(templateSrc, fragmentParts) {\n    let out = templateSrc;\n    for(const i in fragmentParts){\n        const parts = fragmentParts[i];\n        const toInject = parts.join(\"\\n\");\n        if (toInject.length) out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n        else out = out.replace(`{{${i}}}`, \"\");\n    }\n    return out;\n}\n\n});\n\n\nparcelRegister(\"lrogc\", function(module, exports) {\n\n$parcel$export(module.exports, \"vertexGPUTemplate\", function () { return $bed2a13363946350$export$61ecfa8d2718163a; });\n$parcel$export(module.exports, \"fragmentGPUTemplate\", function () { return $bed2a13363946350$export$922d1073ee2ef930; });\n$parcel$export(module.exports, \"vertexGlTemplate\", function () { return $bed2a13363946350$export$99b0f79e15be8ede; });\n$parcel$export(module.exports, \"fragmentGlTemplate\", function () { return $bed2a13363946350$export$3f7784dd6a13ff5a; });\n\"use strict\";\nconst $bed2a13363946350$export$61ecfa8d2718163a = /* wgsl */ `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\nconst $bed2a13363946350$export$922d1073ee2ef930 = /* wgsl */ `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\nconst $bed2a13363946350$export$99b0f79e15be8ede = /* glsl */ `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\nconst $bed2a13363946350$export$3f7784dd6a13ff5a = /* glsl */ `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`;\n\n});\n\nparcelRegister(\"hJgms\", function(module, exports) {\n\n$parcel$export(module.exports, \"globalUniformsBit\", function () { return $5e85aae35546a721$export$435d64b3a14c5a51; });\n$parcel$export(module.exports, \"globalUniformsBitGl\", function () { return $5e85aae35546a721$export$38608853d4735d51; });\n\"use strict\";\nconst $5e85aae35546a721$export$435d64b3a14c5a51 = {\n    name: \"global-uniforms-bit\",\n    vertex: {\n        header: /* wgsl */ `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\nconst $5e85aae35546a721$export$320b7a2ae65b2f3a = {\n    name: \"global-uniforms-ubo-bit\",\n    vertex: {\n        header: /* glsl */ `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\nconst $5e85aae35546a721$export$38608853d4735d51 = {\n    name: \"global-uniforms-bit\",\n    vertex: {\n        header: /* glsl */ `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n};\n\n});\n\n\nparcelRegister(\"1e9Az\", function(module, exports) {\n\n$parcel$export(module.exports, \"colorBit\", function () { return $700ff614ceb8a845$export$a62becfe5fe4ad2; });\n$parcel$export(module.exports, \"colorBitGl\", function () { return $700ff614ceb8a845$export$93189e9821cf4459; });\n\"use strict\";\nconst $700ff614ceb8a845$export$a62becfe5fe4ad2 = {\n    name: \"color-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */ `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\nconst $700ff614ceb8a845$export$93189e9821cf4459 = {\n    name: \"color-bit\",\n    vertex: {\n        header: /* glsl */ `\n            in vec4 aColor;\n        `,\n        main: /* glsl */ `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\n});\n\nparcelRegister(\"raSIq\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateTextureBatchBit\", function () { return $5b427ea70439968f$export$aff2d36945cda647; });\n$parcel$export(module.exports, \"generateTextureBatchBitGl\", function () { return $5b427ea70439968f$export$204e46d9a7a4f835; });\n\"use strict\";\nconst $5b427ea70439968f$var$textureBatchBitGpuCache = {};\nfunction $5b427ea70439968f$var$generateBindingSrc(maxTextures) {\n    const src = [];\n    if (maxTextures === 1) {\n        src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n        src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n    } else {\n        let bindingIndex = 0;\n        for(let i = 0; i < maxTextures; i++){\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n    return src.join(\"\\n\");\n}\nfunction $5b427ea70439968f$var$generateSampleSrc(maxTextures) {\n    const src = [];\n    if (maxTextures === 1) src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n    else {\n        src.push(\"switch vTextureId {\");\n        for(let i = 0; i < maxTextures; i++){\n            if (i === maxTextures - 1) src.push(`  default:{`);\n            else src.push(`  case ${i}:{`);\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n        src.push(`}`);\n    }\n    return src.join(\"\\n\");\n}\nfunction $5b427ea70439968f$export$aff2d36945cda647(maxTextures) {\n    if (!$5b427ea70439968f$var$textureBatchBitGpuCache[maxTextures]) $5b427ea70439968f$var$textureBatchBitGpuCache[maxTextures] = {\n        name: \"texture-batch-bit\",\n        vertex: {\n            header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n            main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n            end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n        },\n        fragment: {\n            header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${$5b427ea70439968f$var$generateBindingSrc(maxTextures)}\n            `,\n            main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${$5b427ea70439968f$var$generateSampleSrc(maxTextures)}\n            `\n        }\n    };\n    return $5b427ea70439968f$var$textureBatchBitGpuCache[maxTextures];\n}\nconst $5b427ea70439968f$var$textureBatchBitGlCache = {};\nfunction $5b427ea70439968f$var$generateSampleGlSrc(maxTextures) {\n    const src = [];\n    for(let i = 0; i < maxTextures; i++){\n        if (i > 0) src.push(\"else\");\n        if (i < maxTextures - 1) src.push(`if(vTextureId < ${i}.5)`);\n        src.push(\"{\");\n        src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push(\"}\");\n    }\n    return src.join(\"\\n\");\n}\nfunction $5b427ea70439968f$export$204e46d9a7a4f835(maxTextures) {\n    if (!$5b427ea70439968f$var$textureBatchBitGlCache[maxTextures]) $5b427ea70439968f$var$textureBatchBitGlCache[maxTextures] = {\n        name: \"texture-batch-bit\",\n        vertex: {\n            header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n            main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n            end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n        },\n        fragment: {\n            header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n            main: `\n\n                ${$5b427ea70439968f$var$generateSampleGlSrc(maxTextures)}\n            `\n        }\n    };\n    return $5b427ea70439968f$var$textureBatchBitGlCache[maxTextures];\n}\n\n});\n\nparcelRegister(\"V3X84\", function(module, exports) {\n\n$parcel$export(module.exports, \"roundPixelsBit\", function () { return $efc830b01ee153af$export$22150169726f7b1; });\n$parcel$export(module.exports, \"roundPixelsBitGl\", function () { return $efc830b01ee153af$export$222909710f39cc5; });\n\"use strict\";\nconst $efc830b01ee153af$export$22150169726f7b1 = {\n    name: \"round-pixels-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\nconst $efc830b01ee153af$export$222909710f39cc5 = {\n    name: \"round-pixels-bit\",\n    vertex: {\n        header: /* glsl */ `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n});\n\nparcelRegister(\"7hpxC\", function(module, exports) {\n\n$parcel$export(module.exports, \"getBatchSamplersUniformGroup\", function () { return $aab0094da40bc4f5$export$5fc8295c6cba6ffe; });\n\nvar $7ZovY = parcelRequire(\"7ZovY\");\n\"use strict\";\nconst $aab0094da40bc4f5$var$batchSamplersUniformGroupHash = {};\nfunction $aab0094da40bc4f5$export$5fc8295c6cba6ffe(maxTextures) {\n    let batchSamplersUniformGroup = $aab0094da40bc4f5$var$batchSamplersUniformGroupHash[maxTextures];\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n    const sampleValues = new Int32Array(maxTextures);\n    for(let i = 0; i < maxTextures; i++)sampleValues[i] = i;\n    batchSamplersUniformGroup = $aab0094da40bc4f5$var$batchSamplersUniformGroupHash[maxTextures] = new (0, $7ZovY.UniformGroup)({\n        uTextures: {\n            value: sampleValues,\n            type: `i32`,\n            size: maxTextures\n        }\n    }, {\n        isStatic: true\n    });\n    return batchSamplersUniformGroup;\n}\n\n});\nparcelRegister(\"7ZovY\", function(module, exports) {\n\n$parcel$export(module.exports, \"UniformGroup\", function () { return $b7a36644826acc4c$export$6601a7a2dcf79bf5; });\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\nvar $eOVk3 = parcelRequire(\"eOVk3\");\n\nvar $eWkxx = parcelRequire(\"eWkxx\");\n\nvar $drtAS = parcelRequire(\"drtAS\");\n\"use strict\";\nconst $b7a36644826acc4c$var$_UniformGroup = class _UniformGroup {\n    /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */ constructor(uniformStructures, options){\n        /** used internally to know if a uniform group was used in the last render pass */ this._touched = 0;\n        /** a unique id for this uniform group used through the renderer */ this.uid = (0, $fTJzX.uid)(\"uniform\");\n        /** a resource type, used to identify how to handle it when its in a bind group / shader resource */ this._resourceType = \"uniformGroup\";\n        /** the resource id used internally by the renderer to build bind group keys */ this._resourceId = (0, $fTJzX.uid)(\"resource\");\n        /** used ito identify if this is a uniform group */ this.isUniformGroup = true;\n        /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */ this._dirtyId = 0;\n        // implementing the interface - UniformGroup are not destroyed\n        this.destroyed = false;\n        options = {\n            ..._UniformGroup.defaultOptions,\n            ...options\n        };\n        this.uniformStructures = uniformStructures;\n        const uniforms = {};\n        for(const i in uniformStructures){\n            const uniformData = uniformStructures[i];\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n            if (!(0, $eWkxx.UNIFORM_TYPES_MAP)[uniformData.type]) throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${(0, $eWkxx.UNIFORM_TYPES_VALUES).join(\", \")}`);\n            uniformData.value ?? (uniformData.value = (0, $drtAS.getDefaultUniformValue)(uniformData.type, uniformData.size));\n            uniforms[i] = uniformData.value;\n        }\n        this.uniforms = uniforms;\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n        this._signature = (0, $eOVk3.createIdFromString)(Object.keys(uniforms).map((i)=>`${i}-${uniformStructures[i].type}`).join(\"-\"), \"uniform-group\");\n    }\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */ update() {\n        this._dirtyId++;\n    }\n};\n/** The default options used by the uniform group. */ $b7a36644826acc4c$var$_UniformGroup.defaultOptions = {\n    /** if true the UniformGroup is handled as an Uniform buffer object. */ ubo: false,\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */ isStatic: false\n};\nlet $b7a36644826acc4c$export$6601a7a2dcf79bf5 = $b7a36644826acc4c$var$_UniformGroup;\n\n});\nparcelRegister(\"eWkxx\", function(module, exports) {\n\n$parcel$export(module.exports, \"UNIFORM_TYPES_VALUES\", function () { return $ac75ba180d87b736$export$94ae83f3c0da5990; });\n$parcel$export(module.exports, \"UNIFORM_TYPES_MAP\", function () { return $ac75ba180d87b736$export$97ddd6675231876e; });\n\"use strict\";\nconst $ac75ba180d87b736$export$94ae83f3c0da5990 = [\n    \"f32\",\n    \"i32\",\n    \"vec2<f32>\",\n    \"vec3<f32>\",\n    \"vec4<f32>\",\n    \"mat2x2<f32>\",\n    \"mat3x3<f32>\",\n    \"mat4x4<f32>\",\n    \"mat3x2<f32>\",\n    \"mat4x2<f32>\",\n    \"mat2x3<f32>\",\n    \"mat4x3<f32>\",\n    \"mat2x4<f32>\",\n    \"mat3x4<f32>\",\n    \"vec2<i32>\",\n    \"vec3<i32>\",\n    \"vec4<i32>\"\n];\nconst $ac75ba180d87b736$export$97ddd6675231876e = $ac75ba180d87b736$export$94ae83f3c0da5990.reduce((acc, type)=>{\n    acc[type] = true;\n    return acc;\n}, {});\n\n});\n\nparcelRegister(\"drtAS\", function(module, exports) {\n\n$parcel$export(module.exports, \"getDefaultUniformValue\", function () { return $3a47707a42582d68$export$7febdb6905805c3d; });\n\"use strict\";\nfunction $3a47707a42582d68$export$7febdb6905805c3d(type, size) {\n    switch(type){\n        case \"f32\":\n            return 0;\n        case \"vec2<f32>\":\n            return new Float32Array(2 * size);\n        case \"vec3<f32>\":\n            return new Float32Array(3 * size);\n        case \"vec4<f32>\":\n            return new Float32Array(4 * size);\n        case \"mat2x2<f32>\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                1\n            ]);\n        case \"mat3x3<f32>\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                1\n            ]);\n        case \"mat4x4<f32>\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ]);\n    }\n    return null;\n}\n\n});\n\n\n\nparcelRegister(\"kmaR2\", function(module, exports) {\n\n$parcel$export(module.exports, \"Shader\", function () { return $e117696f3660e480$export$462bb059fed9d9e5; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $022Ud = parcelRequire(\"022Ud\");\n\nvar $lc03N = parcelRequire(\"lc03N\");\n\nvar $4WM3f = parcelRequire(\"4WM3f\");\n\nvar $28usv = parcelRequire(\"28usv\");\n\nvar $7ZovY = parcelRequire(\"7ZovY\");\n\nvar $fTJzX = parcelRequire(\"fTJzX\");\n\"use strict\";\nclass $e117696f3660e480$export$462bb059fed9d9e5 extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    constructor(options){\n        super();\n        /** A unique identifier for the shader */ this.uid = (0, $fTJzX.uid)(\"shader\");\n        /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */ this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n        this._ownedBindGroups = [];\n        let { gpuProgram: gpuProgram, glProgram: glProgram, groups: groups, resources: resources, compatibleRenderers: compatibleRenderers, groupMap: groupMap } = options;\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n        if (compatibleRenderers === void 0) {\n            compatibleRenderers = 0;\n            if (gpuProgram) compatibleRenderers |= (0, $28usv.RendererType).WEBGPU;\n            if (glProgram) compatibleRenderers |= (0, $28usv.RendererType).WEBGL;\n        }\n        this.compatibleRenderers = compatibleRenderers;\n        const nameHash = {};\n        if (!resources && !groups) resources = {};\n        if (resources && groups) throw new Error(\"[Shader] Cannot have both resources and groups\");\n        else if (!gpuProgram && groups && !groupMap) throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n        else if (!gpuProgram && groups && groupMap) {\n            for(const i in groupMap)for(const j in groupMap[i]){\n                const uniformName = groupMap[i][j];\n                nameHash[uniformName] = {\n                    group: i,\n                    binding: j,\n                    name: uniformName\n                };\n            }\n        } else if (gpuProgram && groups && !groupMap) {\n            const groupData = gpuProgram.structsAndGroups.groups;\n            groupMap = {};\n            groupData.forEach((data)=>{\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n                nameHash[data.name] = data;\n            });\n        } else if (resources) {\n            groups = {};\n            groupMap = {};\n            if (gpuProgram) {\n                const groupData = gpuProgram.structsAndGroups.groups;\n                groupData.forEach((data)=>{\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n                    nameHash[data.name] = data;\n                });\n            }\n            let bindTick = 0;\n            for(const i in resources){\n                if (nameHash[i]) continue;\n                if (!groups[99]) {\n                    groups[99] = new (0, $lc03N.BindGroup)();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                nameHash[i] = {\n                    group: 99,\n                    binding: bindTick,\n                    name: i\n                };\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n                bindTick++;\n            }\n            for(const i in resources){\n                const name = i;\n                let value = resources[i];\n                if (!value.source && !value._resourceType) value = new (0, $7ZovY.UniformGroup)(value);\n                const data = nameHash[name];\n                if (data) {\n                    if (!groups[data.group]) {\n                        groups[data.group] = new (0, $lc03N.BindGroup)();\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n    /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */ addResource(name, groupIndex, bindIndex) {\n        var _a, _b;\n        (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n        (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n        if (!this.groups[groupIndex]) {\n            this.groups[groupIndex] = new (0, $lc03N.BindGroup)();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n    _buildResourceAccessor(groups, nameHash) {\n        const uniformsOut = {};\n        for(const i in nameHash){\n            const data = nameHash[i];\n            Object.defineProperty(uniformsOut, data.name, {\n                get () {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set (value) {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n        return uniformsOut;\n    }\n    /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */ destroy(destroyPrograms = false) {\n        this.emit(\"destroy\", this);\n        if (destroyPrograms) {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n        this.gpuProgram = null;\n        this.glProgram = null;\n        this.removeAllListeners();\n        this._uniformBindMap = null;\n        this._ownedBindGroups.forEach((bindGroup)=>{\n            bindGroup.destroy();\n        });\n        this._ownedBindGroups = null;\n        this.resources = null;\n        this.groups = null;\n    }\n    static from(options) {\n        const { gpu: gpu, gl: gl, ...rest } = options;\n        let gpuProgram;\n        let glProgram;\n        if (gpu) gpuProgram = (0, $4WM3f.GpuProgram).from(gpu);\n        if (gl) glProgram = (0, $022Ud.GlProgram).from(gl);\n        return new $e117696f3660e480$export$462bb059fed9d9e5({\n            gpuProgram: gpuProgram,\n            glProgram: glProgram,\n            ...rest\n        });\n    }\n}\n\n});\nparcelRegister(\"28usv\", function(module, exports) {\n\n$parcel$export(module.exports, \"RendererType\", function () { return $b2ee0ab0ac3d7eb3$export$2ca8315eebe81c3d; });\n\"use strict\";\nvar $b2ee0ab0ac3d7eb3$export$2ca8315eebe81c3d = /* @__PURE__ */ ((RendererType2)=>{\n    RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n    RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n    RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n    return RendererType2;\n})($b2ee0ab0ac3d7eb3$export$2ca8315eebe81c3d || {});\n\n});\n\n\n\n\nparcelRegister(\"7gnh5\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildContextBatches\", function () { return $a080d24481b48164$export$e3c00f31a053d231; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\nvar $bpDQR = parcelRequire(\"bpDQR\");\n\nvar $4bCwI = parcelRequire(\"4bCwI\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $dLv5L = parcelRequire(\"dLv5L\");\n\nvar $8qV09 = parcelRequire(\"8qV09\");\n\nvar $4E0Cg = parcelRequire(\"4E0Cg\");\n\nvar $g2xO2 = parcelRequire(\"g2xO2\");\n\nvar $ijujD = parcelRequire(\"ijujD\");\n\nvar $gUSTb = parcelRequire(\"gUSTb\");\n\nvar $dBiOc = parcelRequire(\"dBiOc\");\n\nvar $7xJUK = parcelRequire(\"7xJUK\");\n\nvar $2l6S5 = parcelRequire(\"2l6S5\");\n\"use strict\";\nconst $a080d24481b48164$export$ab760b0d495e92a1 = {};\n(0, $kFA6i.extensions).handleByMap((0, $kFA6i.ExtensionType).ShapeBuilder, $a080d24481b48164$export$ab760b0d495e92a1);\n(0, $kFA6i.extensions).add((0, $dBiOc.buildRectangle), (0, $gUSTb.buildPolygon), (0, $7xJUK.buildTriangle), (0, $4E0Cg.buildCircle), (0, $4E0Cg.buildEllipse), (0, $4E0Cg.buildRoundedRectangle));\nconst $a080d24481b48164$var$tempRect = new (0, $ec4lc.Rectangle)();\nfunction $a080d24481b48164$export$e3c00f31a053d231(context, gpuContext) {\n    const { geometryData: geometryData, batches: batches } = gpuContext;\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n    for(let i = 0; i < context.instructions.length; i++){\n        const instruction = context.instructions[i];\n        if (instruction.action === \"texture\") $a080d24481b48164$var$addTextureToGeometryData(instruction.data, batches, geometryData);\n        else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n            const isStroke = instruction.action === \"stroke\";\n            const shapePath = instruction.data.path.shapePath;\n            const style = instruction.data.style;\n            const hole = instruction.data.hole;\n            if (isStroke && hole) $a080d24481b48164$var$addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            $a080d24481b48164$var$addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\nfunction $a080d24481b48164$var$addTextureToGeometryData(data, batches, geometryData) {\n    const { vertices: vertices, uvs: uvs, indices: indices } = geometryData;\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = $a080d24481b48164$export$ab760b0d495e92a1.rectangle;\n    const rect = $a080d24481b48164$var$tempRect;\n    const texture = data.image;\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n    const matrix = data.transform;\n    build.build(rect, points);\n    if (matrix) (0, $4bCwI.transformVertices)(points, matrix);\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n    const textureUvs = texture.uvs;\n    uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);\n    const graphicsBatch = (0, $dLv5L.BigPool).get((0, $8qV09.BatchableGraphics));\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n}\nfunction $a080d24481b48164$var$addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n    const { vertices: vertices, uvs: uvs, indices: indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n    shapePath.shapePrimitives.forEach(({ shape: shape, transform: matrix }, i)=>{\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n        const points = [];\n        const build = $a080d24481b48164$export$ab760b0d495e92a1[shape.type];\n        let topology = \"triangle-list\";\n        build.build(shape, points);\n        if (matrix) (0, $4bCwI.transformVertices)(points, matrix);\n        if (!isStroke) {\n            if (hole && lastIndex === i) {\n                if (lastIndex !== 0) console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n                const holeIndices = [];\n                const otherPoints = points.slice();\n                const holeArrays = $a080d24481b48164$var$getHoleArrays(hole.shapePath);\n                holeArrays.forEach((holePoints)=>{\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n                (0, $2l6S5.triangulateWithHoles)(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            } else build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n        } else {\n            const close = shape.closePath ?? true;\n            const lineStyle = style;\n            if (!lineStyle.pixelLine) (0, $g2xO2.buildLine)(points, lineStyle, false, close, vertices, indices);\n            else {\n                (0, $ijujD.buildPixelLine)(points, close, vertices, indices);\n                topology = \"line-list\";\n            }\n        }\n        const uvsOffset = uvs.length / 2;\n        const texture = style.texture;\n        if (texture !== (0, $4YnyE.Texture).WHITE) {\n            const textureMatrix = style.matrix;\n            if (textureMatrix) {\n                if (matrix) textureMatrix.append(matrix.clone().invert());\n                (0, $bpDQR.buildUvs)(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n            }\n        } else (0, $bpDQR.buildSimpleUvs)(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n        const graphicsBatch = (0, $dLv5L.BigPool).get((0, $8qV09.BatchableGraphics));\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        graphicsBatch.topology = topology;\n        batches.push(graphicsBatch);\n    });\n}\nfunction $a080d24481b48164$var$getHoleArrays(shape) {\n    if (!shape) return [];\n    const holePrimitives = shape.shapePrimitives;\n    const holeArrays = [];\n    for(let k = 0; k < holePrimitives.length; k++){\n        const holePrimitive = holePrimitives[k].shape;\n        const holePoints = [];\n        const holeBuilder = $a080d24481b48164$export$ab760b0d495e92a1[holePrimitive.type];\n        holeBuilder.build(holePrimitive, holePoints);\n        holeArrays.push(holePoints);\n    }\n    return holeArrays;\n}\n\n});\nparcelRegister(\"bpDQR\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildUvs\", function () { return $95cacfd53eb3ccd8$export$2027711a0ff70dc2; });\n$parcel$export(module.exports, \"buildSimpleUvs\", function () { return $95cacfd53eb3ccd8$export$580e3d8462b9fe52; });\n\"use strict\";\nfunction $95cacfd53eb3ccd8$export$2027711a0ff70dc2(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n    let index = 0;\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    while(index < size){\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n        uvs[uvsOffset] = a * x + c * y + tx;\n        uvs[uvsOffset + 1] = b * x + d * y + ty;\n        uvsOffset += uvsStride;\n        verticesOffset += verticesStride;\n        index++;\n    }\n}\nfunction $95cacfd53eb3ccd8$export$580e3d8462b9fe52(uvs, uvsOffset, uvsStride, size) {\n    let index = 0;\n    uvsOffset *= uvsStride;\n    while(index < size){\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n        uvsOffset += uvsStride;\n        index++;\n    }\n}\n\n});\n\nparcelRegister(\"4bCwI\", function(module, exports) {\n\n$parcel$export(module.exports, \"transformVertices\", function () { return $19ba6607450189cd$export$cbe36b8a8d6e3d3; });\n\"use strict\";\nfunction $19ba6607450189cd$export$cbe36b8a8d6e3d3(vertices, m, offset, stride, size) {\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n    offset || (offset = 0);\n    stride || (stride = 2);\n    size || (size = vertices.length / stride - offset);\n    let index = offset * stride;\n    for(let i = 0; i < size; i++){\n        const x = vertices[index];\n        const y = vertices[index + 1];\n        vertices[index] = a * x + c * y + tx;\n        vertices[index + 1] = b * x + d * y + ty;\n        index += stride;\n    }\n}\n\n});\n\nparcelRegister(\"8qV09\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableGraphics\", function () { return $ff44f43bf11d19a8$export$91d2a08bbf21546b; });\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $goP77 = parcelRequire(\"goP77\");\n\"use strict\";\nconst $ff44f43bf11d19a8$var$identityMatrix = new (0, $0kbcf.Matrix)();\nclass $ff44f43bf11d19a8$export$91d2a08bbf21546b {\n    constructor(){\n        this.packAsQuad = false;\n        this.batcherName = \"default\";\n        this.topology = \"triangle-list\";\n        this.applyTransform = true;\n        this.roundPixels = 0;\n        this._batcher = null;\n        this._batch = null;\n    }\n    get uvs() {\n        return this.geometryData.uvs;\n    }\n    get positions() {\n        return this.geometryData.vertices;\n    }\n    get indices() {\n        return this.geometryData.indices;\n    }\n    get blendMode() {\n        if (this.applyTransform) return this.renderable.groupBlendMode;\n        return \"normal\";\n    }\n    get color() {\n        const rgb = this.baseColor;\n        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n        const renderable = this.renderable;\n        if (renderable) return (0, $goP77.multiplyHexColors)(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);\n        return bgr + (this.alpha * 255 << 24);\n    }\n    get transform() {\n        return this.renderable?.groupTransform || $ff44f43bf11d19a8$var$identityMatrix;\n    }\n    copyTo(gpuBuffer) {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n        gpuBuffer.attributeOffset = this.attributeOffset;\n        gpuBuffer.attributeSize = this.attributeSize;\n        gpuBuffer.baseColor = this.baseColor;\n        gpuBuffer.alpha = this.alpha;\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n        gpuBuffer.topology = this.topology;\n    }\n    reset() {\n        this.applyTransform = true;\n        this.renderable = null;\n        this.topology = \"triangle-list\";\n    }\n}\n\n});\n\nparcelRegister(\"4E0Cg\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildCircle\", function () { return $97ec315115ac3792$export$a3541b2d8ecbfcf2; });\n$parcel$export(module.exports, \"buildEllipse\", function () { return $97ec315115ac3792$export$d35b00c6ec9534ca; });\n$parcel$export(module.exports, \"buildRoundedRectangle\", function () { return $97ec315115ac3792$export$4b54fce47d2ae7f4; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nconst $97ec315115ac3792$export$a3541b2d8ecbfcf2 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).ShapeBuilder,\n        name: \"circle\"\n    },\n    build (shape, points) {\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n        if (shape.type === \"circle\") {\n            const circle = shape;\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        } else if (shape.type === \"ellipse\") {\n            const ellipse = shape;\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        } else {\n            const roundedRect = shape;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) return points;\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n        if (m === 0) return points;\n        if (n === 0) {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n            return points;\n        }\n        let j1 = 0;\n        let j2 = n * 4 + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n        if (dy) {\n            const y22 = y - y0;\n            points[j3++] = x2;\n            points[j3++] = y22;\n            points[--j4] = y22;\n            points[--j4] = x1;\n        }\n        for(let i = 1; i < n; i++){\n            const a = Math.PI / 2 * (i / n);\n            const x02 = dx + Math.cos(a) * rx;\n            const y02 = dy + Math.sin(a) * ry;\n            const x12 = x + x02;\n            const x22 = x - x02;\n            const y12 = y + y02;\n            const y22 = y - y02;\n            points[j1++] = x12;\n            points[j1++] = y12;\n            points[--j2] = y12;\n            points[--j2] = x22;\n            points[j3++] = x22;\n            points[j3++] = y22;\n            points[--j4] = y22;\n            points[--j4] = x12;\n        }\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n        if (dx) {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        if (points.length === 0) return;\n        let centerX = 0;\n        let centerY = 0;\n        for(let i = 0; i < points.length; i += 2){\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= points.length / 2;\n        centerY /= points.length / 2;\n        let count = verticesOffset;\n        vertices[count * verticesStride] = centerX;\n        vertices[count * verticesStride + 1] = centerY;\n        const centerIndex = count++;\n        for(let i = 0; i < points.length; i += 2){\n            vertices[count * verticesStride] = points[i];\n            vertices[count * verticesStride + 1] = points[i + 1];\n            if (i > 0) {\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n};\nconst $97ec315115ac3792$export$d35b00c6ec9534ca = {\n    ...$97ec315115ac3792$export$a3541b2d8ecbfcf2,\n    extension: {\n        ...$97ec315115ac3792$export$a3541b2d8ecbfcf2.extension,\n        name: \"ellipse\"\n    }\n};\nconst $97ec315115ac3792$export$4b54fce47d2ae7f4 = {\n    ...$97ec315115ac3792$export$a3541b2d8ecbfcf2,\n    extension: {\n        ...$97ec315115ac3792$export$a3541b2d8ecbfcf2.extension,\n        name: \"roundedRectangle\"\n    }\n};\n\n});\n\nparcelRegister(\"g2xO2\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildLine\", function () { return $c90f5af949c3c3c8$export$45986ccf08e93b0b; });\n\nvar $hbjPo = parcelRequire(\"hbjPo\");\n\nvar $8XZU4 = parcelRequire(\"8XZU4\");\n\nvar $49rEx = parcelRequire(\"49rEx\");\n\"use strict\";\nfunction $c90f5af949c3c3c8$var$square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n    const ix = x - nx * innerWeight;\n    const iy = y - ny * innerWeight;\n    const ox = x + nx * outerWeight;\n    const oy = y + ny * outerWeight;\n    let exx;\n    let eyy;\n    if (clockwise) {\n        exx = ny;\n        eyy = -nx;\n    } else {\n        exx = -ny;\n        eyy = nx;\n    }\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n    return 2;\n}\nfunction $c90f5af949c3c3c8$var$round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n    if (clockwise && angle0 < angle1) angle0 += Math.PI * 2;\n    else if (!clockwise && angle0 > angle1) angle1 += Math.PI * 2;\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n    startAngle += angleInc;\n    if (clockwise) {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){\n            verts.push(cx, cy);\n            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n        }\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    } else {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){\n            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n            verts.push(cx, cy);\n        }\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n    return segCount * 2;\n}\nfunction $c90f5af949c3c3c8$export$45986ccf08e93b0b(points, lineStyle, flipAlignment, closed, vertices, indices) {\n    const eps = (0, $8XZU4.closePointEps);\n    if (points.length === 0) return;\n    const style = lineStyle;\n    let alignment = style.alignment;\n    if (lineStyle.alignment !== 0.5) {\n        let orientation = (0, $49rEx.getOrientationOfPoints)(points);\n        if (flipAlignment) orientation *= -1;\n        alignment = (alignment - 0.5) * orientation + 0.5;\n    }\n    const firstPoint = new (0, $hbjPo.Point)(points[0], points[1]);\n    const lastPoint = new (0, $hbjPo.Point)(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n    if (closedShape) {\n        points = points.slice();\n        if (closedPath) {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n    const verts = vertices;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n    let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    const ratio = alignment;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n    if (!closedShape) {\n        if (style.cap === \"round\") indexCount += $c90f5af949c3c3c8$var$round(x0 - perpX * (innerWeight - outerWeight) * 0.5, y0 - perpY * (innerWeight - outerWeight) * 0.5, x0 - perpX * innerWeight, y0 - perpY * innerWeight, x0 + perpX * outerWeight, y0 + perpY * outerWeight, verts, true) + 2;\n        else if (style.cap === \"square\") indexCount += $c90f5af949c3c3c8$var$square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n    verts.push(x0 - perpX * innerWeight, y0 - perpY * innerWeight);\n    verts.push(x0 + perpX * outerWeight, y0 + perpY * outerWeight);\n    for(let i = 1; i < length - 1; ++i){\n        x0 = points[(i - 1) * 2];\n        y0 = points[(i - 1) * 2 + 1];\n        x1 = points[i * 2];\n        y1 = points[i * 2 + 1];\n        x2 = points[(i + 1) * 2];\n        y2 = points[(i + 1) * 2 + 1];\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n        dist = Math.sqrt(perpX * perpX + perpY * perpY);\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n        dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n        const dot = dx0 * dx1 + dy0 * dy1;\n        const cross = dy0 * dx1 - dy1 * dx0;\n        const clockwise = cross < 0;\n        if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n            if (dot >= 0) {\n                if (style.join === \"round\") indexCount += $c90f5af949c3c3c8$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n                else indexCount += 2;\n                verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);\n                verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n            }\n            continue;\n        }\n        const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n        const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n        const px = (dx0 * c2 - dx1 * c1) / cross;\n        const py = (dy1 * c1 - dy0 * c2) / cross;\n        const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n        const imx = x1 + (px - x1) * innerWeight;\n        const imy = y1 + (py - y1) * innerWeight;\n        const omx = x1 - (px - x1) * outerWeight;\n        const omy = y1 - (py - y1) * outerWeight;\n        const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n        if (insideMiterOk) {\n            if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n                if (clockwise) {\n                    verts.push(imx, imy);\n                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n                    verts.push(imx, imy);\n                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n                } else {\n                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n                    verts.push(omx, omy);\n                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n                    verts.push(omx, omy);\n                }\n                indexCount += 2;\n            } else if (style.join === \"round\") {\n                if (clockwise) {\n                    verts.push(imx, imy);\n                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n                    indexCount += $c90f5af949c3c3c8$var$round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n                    verts.push(imx, imy);\n                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n                } else {\n                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n                    verts.push(omx, omy);\n                    indexCount += $c90f5af949c3c3c8$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n                    verts.push(omx, omy);\n                }\n            } else {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        } else {\n            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n            if (style.join === \"round\") {\n                if (clockwise) indexCount += $c90f5af949c3c3c8$var$round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n                else indexCount += $c90f5af949c3c3c8$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n            } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n                if (clockwise) {\n                    verts.push(omx, omy);\n                    verts.push(omx, omy);\n                } else {\n                    verts.push(imx, imy);\n                    verts.push(imx, imy);\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n            indexCount += 2;\n        }\n    }\n    x0 = points[(length - 2) * 2];\n    y0 = points[(length - 2) * 2 + 1];\n    x1 = points[(length - 1) * 2];\n    y1 = points[(length - 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n    if (!closedShape) {\n        if (style.cap === \"round\") indexCount += $c90f5af949c3c3c8$var$round(x1 - perpX * (innerWeight - outerWeight) * 0.5, y1 - perpY * (innerWeight - outerWeight) * 0.5, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 + perpX * outerWeight, y1 + perpY * outerWeight, verts, false) + 2;\n        else if (style.cap === \"square\") indexCount += $c90f5af949c3c3c8$var$square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n    const eps2 = (0, $8XZU4.curveEps) * (0, $8XZU4.curveEps);\n    for(let i = indexStart; i < indexCount + indexStart - 2; ++i){\n        x0 = verts[i * 2];\n        y0 = verts[i * 2 + 1];\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[(i + 1) * 2 + 1];\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[(i + 2) * 2 + 1];\n        if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) continue;\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n});\nparcelRegister(\"8XZU4\", function(module, exports) {\n\n$parcel$export(module.exports, \"closePointEps\", function () { return $cee639fae63999ed$export$7159a7c43f12984; });\n$parcel$export(module.exports, \"curveEps\", function () { return $cee639fae63999ed$export$51a946149243709; });\n\"use strict\";\nconst $cee639fae63999ed$export$7159a7c43f12984 = 1e-4;\nconst $cee639fae63999ed$export$51a946149243709 = 1e-4;\n\n});\n\nparcelRegister(\"49rEx\", function(module, exports) {\n\n$parcel$export(module.exports, \"getOrientationOfPoints\", function () { return $bb7bdc23d7522b8b$export$38856eae80d480e1; });\n\"use strict\";\nfunction $bb7bdc23d7522b8b$export$38856eae80d480e1(points) {\n    const m = points.length;\n    if (m < 6) return 1;\n    let area = 0;\n    for(let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2){\n        const x2 = points[i];\n        const y2 = points[i + 1];\n        area += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n    }\n    if (area < 0) return -1;\n    return 1;\n}\n\n});\n\n\nparcelRegister(\"ijujD\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildPixelLine\", function () { return $f4df5f0a8f32dff9$export$44c058937667e9f0; });\n\nvar $8XZU4 = parcelRequire(\"8XZU4\");\n\"use strict\";\nfunction $f4df5f0a8f32dff9$export$44c058937667e9f0(points, closed, vertices, indices) {\n    const eps = (0, $8XZU4.closePointEps);\n    if (points.length === 0) return;\n    const fx = points[0];\n    const fy = points[1];\n    const lx = points[points.length - 2];\n    const ly = points[points.length - 1];\n    const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;\n    const verts = vertices;\n    const length = points.length / 2;\n    const indexStart = verts.length / 2;\n    for(let i = 0; i < length; i++){\n        verts.push(points[i * 2]);\n        verts.push(points[i * 2 + 1]);\n    }\n    for(let i = 0; i < length - 1; i++)indices.push(indexStart + i, indexStart + i + 1);\n    if (closePath) indices.push(indexStart + length - 1, indexStart);\n}\n\n});\n\nparcelRegister(\"gUSTb\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildPolygon\", function () { return $f448119daf614740$export$4c2d12f7b210f357; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $2l6S5 = parcelRequire(\"2l6S5\");\n\"use strict\";\nconst $f448119daf614740$var$emptyArray = [];\nconst $f448119daf614740$export$4c2d12f7b210f357 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).ShapeBuilder,\n        name: \"polygon\"\n    },\n    build (shape, points) {\n        for(let i = 0; i < shape.points.length; i++)points[i] = shape.points[i];\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        (0, $2l6S5.triangulateWithHoles)(points, $f448119daf614740$var$emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    }\n};\n\n});\nparcelRegister(\"2l6S5\", function(module, exports) {\n\n$parcel$export(module.exports, \"triangulateWithHoles\", function () { return $a990f8e145b4ff90$export$5a241bf9c2c3d94b; });\n\nvar $fPquT = parcelRequire(\"fPquT\");\n\"use strict\";\nfunction $a990f8e145b4ff90$export$5a241bf9c2c3d94b(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    const triangles = (0, (/*@__PURE__*/$parcel$interopDefault($fPquT)))(points, holes, 2);\n    if (!triangles) return;\n    for(let i = 0; i < triangles.length; i += 3){\n        indices[indicesOffset++] = triangles[i] + verticesOffset;\n        indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n        indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n    }\n    let index = verticesOffset * verticesStride;\n    for(let i = 0; i < points.length; i += 2){\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n        index += verticesStride;\n    }\n}\n\n});\nparcelRegister(\"fPquT\", function(module, exports) {\n'use strict';\nmodule.exports = $b8602c4416cfa89b$var$earcut;\nmodule.exports.default = $b8602c4416cfa89b$var$earcut;\nfunction $b8602c4416cfa89b$var$earcut(data, holeIndices, dim) {\n    dim = dim || 2;\n    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = $b8602c4416cfa89b$var$linkedList(data, 0, outerLen, dim, true), triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    var minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = $b8602c4416cfa89b$var$eliminateHoles(data, holeIndices, outerNode, dim);\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n        for(var i = dim; i < outerLen; i += dim){\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    $b8602c4416cfa89b$var$earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n}\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction $b8602c4416cfa89b$var$linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n    if (clockwise === $b8602c4416cfa89b$var$signedArea(data, start, end, dim) > 0) for(i = start; i < end; i += dim)last = $b8602c4416cfa89b$var$insertNode(i, data[i], data[i + 1], last);\n    else for(i = end - dim; i >= start; i -= dim)last = $b8602c4416cfa89b$var$insertNode(i, data[i], data[i + 1], last);\n    if (last && $b8602c4416cfa89b$var$equals(last, last.next)) {\n        $b8602c4416cfa89b$var$removeNode(last);\n        last = last.next;\n    }\n    return last;\n}\n// eliminate colinear or duplicate points\nfunction $b8602c4416cfa89b$var$filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n    var p = start, again;\n    do {\n        again = false;\n        if (!p.steiner && ($b8602c4416cfa89b$var$equals(p, p.next) || $b8602c4416cfa89b$var$area(p.prev, p, p.next) === 0)) {\n            $b8602c4416cfa89b$var$removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n        } else p = p.next;\n    }while (again || p !== end);\n    return end;\n}\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction $b8602c4416cfa89b$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) $b8602c4416cfa89b$var$indexCurve(ear, minX, minY, invSize);\n    var stop = ear, prev, next;\n    // iterate through ears, slicing them one by one\n    while(ear.prev !== ear.next){\n        prev = ear.prev;\n        next = ear.next;\n        if (invSize ? $b8602c4416cfa89b$var$isEarHashed(ear, minX, minY, invSize) : $b8602c4416cfa89b$var$isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n            $b8602c4416cfa89b$var$removeNode(ear);\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n            continue;\n        }\n        ear = next;\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) $b8602c4416cfa89b$var$earcutLinked($b8602c4416cfa89b$var$filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n            else if (pass === 1) {\n                ear = $b8602c4416cfa89b$var$cureLocalIntersections($b8602c4416cfa89b$var$filterPoints(ear), triangles, dim);\n                $b8602c4416cfa89b$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) $b8602c4416cfa89b$var$splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            break;\n        }\n    }\n}\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction $b8602c4416cfa89b$var$isEar(ear) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if ($b8602c4416cfa89b$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    var p = c.next;\n    while(p !== a){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && $b8602c4416cfa89b$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $b8602c4416cfa89b$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n    return true;\n}\nfunction $b8602c4416cfa89b$var$isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if ($b8602c4416cfa89b$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    // z-order range for the current triangle bbox;\n    var minZ = $b8602c4416cfa89b$var$zOrder(x0, y0, minX, minY, invSize), maxZ = $b8602c4416cfa89b$var$zOrder(x1, y1, minX, minY, invSize);\n    var p = ear.prevZ, n = ear.nextZ;\n    // look for points inside the triangle in both directions\n    while(p && p.z >= minZ && n && n.z <= maxZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && $b8602c4416cfa89b$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $b8602c4416cfa89b$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && $b8602c4416cfa89b$var$pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && $b8602c4416cfa89b$var$area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    // look for remaining points in decreasing z-order\n    while(p && p.z >= minZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && $b8602c4416cfa89b$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $b8602c4416cfa89b$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n    // look for remaining points in increasing z-order\n    while(n && n.z <= maxZ){\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && $b8602c4416cfa89b$var$pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && $b8602c4416cfa89b$var$area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    return true;\n}\n// go through all polygon nodes and cure small local self-intersections\nfunction $b8602c4416cfa89b$var$cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev, b = p.next.next;\n        if (!$b8602c4416cfa89b$var$equals(a, b) && $b8602c4416cfa89b$var$intersects(a, p, p.next, b) && $b8602c4416cfa89b$var$locallyInside(a, b) && $b8602c4416cfa89b$var$locallyInside(b, a)) {\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n            // remove two nodes involved\n            $b8602c4416cfa89b$var$removeNode(p);\n            $b8602c4416cfa89b$var$removeNode(p.next);\n            p = start = b;\n        }\n        p = p.next;\n    }while (p !== start);\n    return $b8602c4416cfa89b$var$filterPoints(p);\n}\n// try splitting polygon into two and triangulate them independently\nfunction $b8602c4416cfa89b$var$splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while(b !== a.prev){\n            if (a.i !== b.i && $b8602c4416cfa89b$var$isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = $b8602c4416cfa89b$var$splitPolygon(a, b);\n                // filter colinear points around the cuts\n                a = $b8602c4416cfa89b$var$filterPoints(a, a.next);\n                c = $b8602c4416cfa89b$var$filterPoints(c, c.next);\n                // run earcut on each half\n                $b8602c4416cfa89b$var$earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                $b8602c4416cfa89b$var$earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    }while (a !== start);\n}\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction $b8602c4416cfa89b$var$eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [], i, len, start, end, list;\n    for(i = 0, len = holeIndices.length; i < len; i++){\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = $b8602c4416cfa89b$var$linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push($b8602c4416cfa89b$var$getLeftmost(list));\n    }\n    queue.sort($b8602c4416cfa89b$var$compareX);\n    // process holes from left to right\n    for(i = 0; i < queue.length; i++)outerNode = $b8602c4416cfa89b$var$eliminateHole(queue[i], outerNode);\n    return outerNode;\n}\nfunction $b8602c4416cfa89b$var$compareX(a, b) {\n    return a.x - b.x;\n}\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction $b8602c4416cfa89b$var$eliminateHole(hole, outerNode) {\n    var bridge = $b8602c4416cfa89b$var$findHoleBridge(hole, outerNode);\n    if (!bridge) return outerNode;\n    var bridgeReverse = $b8602c4416cfa89b$var$splitPolygon(bridge, hole);\n    // filter collinear points around the cuts\n    $b8602c4416cfa89b$var$filterPoints(bridgeReverse, bridgeReverse.next);\n    return $b8602c4416cfa89b$var$filterPoints(bridge, bridge.next);\n}\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction $b8602c4416cfa89b$var$findHoleBridge(hole, outerNode) {\n    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    }while (p !== outerNode);\n    if (!m) return null;\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;\n    p = m;\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x && $b8602c4416cfa89b$var$pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n            if ($b8602c4416cfa89b$var$locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && $b8602c4416cfa89b$var$sectorContainsSector(m, p)))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n        p = p.next;\n    }while (p !== stop);\n    return m;\n}\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction $b8602c4416cfa89b$var$sectorContainsSector(m, p) {\n    return $b8602c4416cfa89b$var$area(m.prev, m, p.prev) < 0 && $b8602c4416cfa89b$var$area(p.next, m, m.next) < 0;\n}\n// interlink polygon nodes in z-order\nfunction $b8602c4416cfa89b$var$indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = $b8602c4416cfa89b$var$zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    }while (p !== start);\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n    $b8602c4416cfa89b$var$sortLinked(p);\n}\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction $b8602c4416cfa89b$var$sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n        while(p){\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for(i = 0; i < inSize; i++){\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n            while(pSize > 0 || qSize > 0 && q){\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n                if (tail) tail.nextZ = e;\n                else list = e;\n                e.prevZ = tail;\n                tail = e;\n            }\n            p = q;\n        }\n        tail.nextZ = null;\n        inSize *= 2;\n    }while (numMerges > 1);\n    return list;\n}\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction $b8602c4416cfa89b$var$zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n    x = (x | x << 8) & 0x00FF00FF;\n    x = (x | x << 4) & 0x0F0F0F0F;\n    x = (x | x << 2) & 0x33333333;\n    x = (x | x << 1) & 0x55555555;\n    y = (y | y << 8) & 0x00FF00FF;\n    y = (y | y << 4) & 0x0F0F0F0F;\n    y = (y | y << 2) & 0x33333333;\n    y = (y | y << 1) & 0x55555555;\n    return x | y << 1;\n}\n// find the leftmost node of a polygon ring\nfunction $b8602c4416cfa89b$var$getLeftmost(start) {\n    var p = start, leftmost = start;\n    do {\n        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n        p = p.next;\n    }while (p !== start);\n    return leftmost;\n}\n// check if a point lies within a convex triangle\nfunction $b8602c4416cfa89b$var$pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction $b8602c4416cfa89b$var$isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !$b8602c4416cfa89b$var$intersectsPolygon(a, b) && // dones't intersect other edges\n    ($b8602c4416cfa89b$var$locallyInside(a, b) && $b8602c4416cfa89b$var$locallyInside(b, a) && $b8602c4416cfa89b$var$middleInside(a, b) && // locally visible\n    ($b8602c4416cfa89b$var$area(a.prev, a, b.prev) || $b8602c4416cfa89b$var$area(a, b.prev, b)) || // does not create opposite-facing sectors\n    $b8602c4416cfa89b$var$equals(a, b) && $b8602c4416cfa89b$var$area(a.prev, a, a.next) > 0 && $b8602c4416cfa89b$var$area(b.prev, b, b.next) > 0); // special zero-length case\n}\n// signed area of a triangle\nfunction $b8602c4416cfa89b$var$area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n// check if two points are equal\nfunction $b8602c4416cfa89b$var$equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n// check if two segments intersect\nfunction $b8602c4416cfa89b$var$intersects(p1, q1, p2, q2) {\n    var o1 = $b8602c4416cfa89b$var$sign($b8602c4416cfa89b$var$area(p1, q1, p2));\n    var o2 = $b8602c4416cfa89b$var$sign($b8602c4416cfa89b$var$area(p1, q1, q2));\n    var o3 = $b8602c4416cfa89b$var$sign($b8602c4416cfa89b$var$area(p2, q2, p1));\n    var o4 = $b8602c4416cfa89b$var$sign($b8602c4416cfa89b$var$area(p2, q2, q1));\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n    if (o1 === 0 && $b8602c4416cfa89b$var$onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && $b8602c4416cfa89b$var$onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && $b8602c4416cfa89b$var$onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && $b8602c4416cfa89b$var$onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n    return false;\n}\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction $b8602c4416cfa89b$var$onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction $b8602c4416cfa89b$var$sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n// check if a polygon diagonal intersects any polygon segments\nfunction $b8602c4416cfa89b$var$intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && $b8602c4416cfa89b$var$intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    }while (p !== a);\n    return false;\n}\n// check if a polygon diagonal is locally inside the polygon\nfunction $b8602c4416cfa89b$var$locallyInside(a, b) {\n    return $b8602c4416cfa89b$var$area(a.prev, a, a.next) < 0 ? $b8602c4416cfa89b$var$area(a, b, a.next) >= 0 && $b8602c4416cfa89b$var$area(a, a.prev, b) >= 0 : $b8602c4416cfa89b$var$area(a, b, a.prev) < 0 || $b8602c4416cfa89b$var$area(a, a.next, b) < 0;\n}\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction $b8602c4416cfa89b$var$middleInside(a, b) {\n    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\n    do {\n        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n        p = p.next;\n    }while (p !== a);\n    return inside;\n}\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction $b8602c4416cfa89b$var$splitPolygon(a, b) {\n    var a2 = new $b8602c4416cfa89b$var$Node(a.i, a.x, a.y), b2 = new $b8602c4416cfa89b$var$Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\n    a.next = b;\n    b.prev = a;\n    a2.next = an;\n    an.prev = a2;\n    b2.next = a2;\n    a2.prev = b2;\n    bp.next = b2;\n    b2.prev = bp;\n    return b2;\n}\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction $b8602c4416cfa89b$var$insertNode(i, x, y, last) {\n    var p = new $b8602c4416cfa89b$var$Node(i, x, y);\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\nfunction $b8602c4416cfa89b$var$removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction $b8602c4416cfa89b$var$Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n    // z-order curve value\n    this.z = 0;\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\n$b8602c4416cfa89b$var$earcut.deviation = function(data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    var polygonArea = Math.abs($b8602c4416cfa89b$var$signedArea(data, 0, outerLen, dim));\n    if (hasHoles) for(var i = 0, len = holeIndices.length; i < len; i++){\n        var start = holeIndices[i] * dim;\n        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        polygonArea -= Math.abs($b8602c4416cfa89b$var$signedArea(data, start, end, dim));\n    }\n    var trianglesArea = 0;\n    for(i = 0; i < triangles.length; i += 3){\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\nfunction $b8602c4416cfa89b$var$signedArea(data, start, end, dim) {\n    var sum = 0;\n    for(var i = start, j = end - dim; i < end; i += dim){\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\n$b8602c4416cfa89b$var$earcut.flatten = function(data) {\n    var dim = data[0][0].length, result = {\n        vertices: [],\n        holes: [],\n        dimensions: dim\n    }, holeIndex = 0;\n    for(var i = 0; i < data.length; i++){\n        for(var j = 0; j < data[i].length; j++)for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n});\n\n\n\nparcelRegister(\"dBiOc\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildRectangle\", function () { return $36305308a01a4676$export$cbe813d11f2192b2; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nconst $36305308a01a4676$export$cbe813d11f2192b2 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).ShapeBuilder,\n        name: \"rectangle\"\n    },\n    build (shape, points) {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n        if (!(width >= 0 && height >= 0)) return points;\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        let count = 0;\n        verticesOffset *= verticesStride;\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n        count += verticesStride;\n        const verticesIndex = verticesOffset / verticesStride;\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    }\n};\n\n});\n\nparcelRegister(\"7xJUK\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildTriangle\", function () { return $08a3d6b4d84ddeca$export$8eb75cb9f614d270; });\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nconst $08a3d6b4d84ddeca$export$8eb75cb9f614d270 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).ShapeBuilder,\n        name: \"triangle\"\n    },\n    build (shape, points) {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        let count = 0;\n        verticesOffset *= verticesStride;\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n        const verticesIndex = verticesOffset / verticesStride;\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    }\n};\n\n});\n\n\n\n\nparcelRegister(\"7VTKT\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildAdaptiveQuadratic\", function () { return $7659ce92f0cf3dda$export$d53ce9debfe7a6c2; });\n\nvar $inK6t = parcelRequire(\"inK6t\");\n\"use strict\";\nconst $7659ce92f0cf3dda$var$RECURSION_LIMIT = 8;\nconst $7659ce92f0cf3dda$var$FLT_EPSILON = 11920929e-14;\nconst $7659ce92f0cf3dda$var$PATH_DISTANCE_EPSILON = 1;\nconst $7659ce92f0cf3dda$var$curveAngleToleranceEpsilon = 0.01;\nconst $7659ce92f0cf3dda$var$mAngleTolerance = 0;\nfunction $7659ce92f0cf3dda$export$d53ce9debfe7a6c2(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n    const scale = 1;\n    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? (0, $inK6t.GraphicsContextSystem).defaultOptions.bezierSmoothness));\n    let distanceTolerance = ($7659ce92f0cf3dda$var$PATH_DISTANCE_EPSILON - smoothing) / scale;\n    distanceTolerance *= distanceTolerance;\n    $7659ce92f0cf3dda$var$begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n    return points;\n}\nfunction $7659ce92f0cf3dda$var$begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n    $7659ce92f0cf3dda$var$recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n    points.push(eX, eY);\n}\nfunction $7659ce92f0cf3dda$var$recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n    if (level > $7659ce92f0cf3dda$var$RECURSION_LIMIT) return;\n    const pi = Math.PI;\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n    if (d > $7659ce92f0cf3dda$var$FLT_EPSILON) {\n        if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n            if ($7659ce92f0cf3dda$var$mAngleTolerance < $7659ce92f0cf3dda$var$curveAngleToleranceEpsilon) {\n                points.push(x123, y123);\n                return;\n            }\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n            if (da >= pi) da = 2 * pi - da;\n            if (da < $7659ce92f0cf3dda$var$mAngleTolerance) {\n                points.push(x123, y123);\n                return;\n            }\n        }\n    } else {\n        dx = x123 - (x1 + x3) / 2;\n        dy = y123 - (y1 + y3) / 2;\n        if (dx * dx + dy * dy <= distanceTolerance) {\n            points.push(x123, y123);\n            return;\n        }\n    }\n    $7659ce92f0cf3dda$var$recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    $7659ce92f0cf3dda$var$recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n});\n\nparcelRegister(\"9HsoA\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArc\", function () { return $14262346713351f6$export$ed8eebdc6998f0f6; });\n\"use strict\";\nfunction $14262346713351f6$export$ed8eebdc6998f0f6(points, x, y, radius, start, end, clockwise, steps) {\n    let dist = Math.abs(start - end);\n    if (!clockwise && start > end) dist = 2 * Math.PI - dist;\n    else if (clockwise && end > start) dist = 2 * Math.PI - dist;\n    steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));\n    steps = Math.max(steps, 3);\n    let f = dist / steps;\n    let t = start;\n    f *= clockwise ? -1 : 1;\n    for(let i = 0; i < steps + 1; i++){\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n        const nx = x + cs * radius;\n        const ny = y + sn * radius;\n        points.push(nx, ny);\n        t += f;\n    }\n}\n\n});\n\nparcelRegister(\"iiH2h\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArcTo\", function () { return $326462c7d762b226$export$d46b7933b415e02f; });\n\nvar $9HsoA = parcelRequire(\"9HsoA\");\n\"use strict\";\nfunction $326462c7d762b226$export$d46b7933b415e02f(points, x1, y1, x2, y2, radius) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1e-8 || radius === 0) {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) points.push(x1, y1);\n        return;\n    }\n    const dd = a1 * a1 + b1 * b1;\n    const cc = a2 * a2 + b2 * b2;\n    const tt = a1 * a2 + b1 * b2;\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = k1 * b2 + k2 * b1;\n    const cy = k1 * a2 + k2 * a1;\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n    (0, $9HsoA.buildArc)(points, cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n}\n\n});\n\nparcelRegister(\"t0jfs\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArcToSvg\", function () { return $6a3337fbe0a64811$export$71ccaa6dca53075e; });\n\nvar $dVeJc = parcelRequire(\"dVeJc\");\n\"use strict\";\nconst $6a3337fbe0a64811$var$TAU = Math.PI * 2;\nconst $6a3337fbe0a64811$var$out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\nconst $6a3337fbe0a64811$var$mapToEllipse = ({ x: x, y: y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2)=>{\n    x *= rx;\n    y *= ry;\n    const xp = cosPhi * x - sinPhi * y;\n    const yp = sinPhi * x + cosPhi * y;\n    out2.x = xp + centerX;\n    out2.y = yp + centerY;\n    return out2;\n};\nfunction $6a3337fbe0a64811$var$approxUnitArc(ang1, ang2) {\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n    return [\n        {\n            x: x1 - y1 * a,\n            y: y1 + x1 * a\n        },\n        {\n            x: x2 + y2 * a,\n            y: y2 - x2 * a\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\nconst $6a3337fbe0a64811$var$vectorAngle = (ux, uy, vx, vy)=>{\n    const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n    let dot = ux * vx + uy * vy;\n    if (dot > 1) dot = 1;\n    if (dot < -1) dot = -1;\n    return sign * Math.acos(dot);\n};\nconst $6a3337fbe0a64811$var$getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2)=>{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n    let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n    if (radicant < 0) radicant = 0;\n    radicant /= rxSq * pypSq + rySq * pxpSq;\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n    const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n    const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n    const ang1 = $6a3337fbe0a64811$var$vectorAngle(1, 0, vx1, vy1);\n    let ang2 = $6a3337fbe0a64811$var$vectorAngle(vx1, vy1, vx2, vy2);\n    if (sweepFlag === 0 && ang2 > 0) ang2 -= $6a3337fbe0a64811$var$TAU;\n    if (sweepFlag === 1 && ang2 < 0) ang2 += $6a3337fbe0a64811$var$TAU;\n    out2.centerX = centerX;\n    out2.centerY = centerY;\n    out2.ang1 = ang1;\n    out2.ang2 = ang2;\n};\nfunction $6a3337fbe0a64811$export$71ccaa6dca53075e(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n    if (rx === 0 || ry === 0) return;\n    const sinPhi = Math.sin(xAxisRotation * $6a3337fbe0a64811$var$TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * $6a3337fbe0a64811$var$TAU / 360);\n    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n    if (pxp === 0 && pyp === 0) return;\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n    if (lambda > 1) {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n    $6a3337fbe0a64811$var$getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, $6a3337fbe0a64811$var$out);\n    let { ang1: ang1, ang2: ang2 } = $6a3337fbe0a64811$var$out;\n    const { centerX: centerX, centerY: centerY } = $6a3337fbe0a64811$var$out;\n    let ratio = Math.abs(ang2) / ($6a3337fbe0a64811$var$TAU / 4);\n    if (Math.abs(1 - ratio) < 1e-7) ratio = 1;\n    const segments = Math.max(Math.ceil(ratio), 1);\n    ang2 /= segments;\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n    const outCurvePoint = {\n        x: 0,\n        y: 0\n    };\n    for(let i = 0; i < segments; i++){\n        const curve = $6a3337fbe0a64811$var$approxUnitArc(ang1, ang2);\n        const { x: x1, y: y1 } = $6a3337fbe0a64811$var$mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = $6a3337fbe0a64811$var$mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x, y: y } = $6a3337fbe0a64811$var$mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        (0, $dVeJc.buildAdaptiveBezier)(points, lastX, lastY, x1, y1, x2, y2, x, y);\n        lastX = x;\n        lastY = y;\n        ang1 += ang2;\n    }\n}\n\n});\n\nparcelRegister(\"97zsF\", function(module, exports) {\n\n$parcel$export(module.exports, \"roundedShapeArc\", function () { return $0af85e9981f3b299$export$ae1f43bc280f09be; });\n$parcel$export(module.exports, \"roundedShapeQuadraticCurve\", function () { return $0af85e9981f3b299$export$cf503f371c53af9e; });\n\"use strict\";\nfunction $0af85e9981f3b299$export$ae1f43bc280f09be(g, points, radius) {\n    const vecFrom = (p, pp)=>{\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt(x * x + y * y);\n        const nx = x / len;\n        const ny = y / len;\n        return {\n            len: len,\n            nx: nx,\n            ny: ny\n        };\n    };\n    const sharpCorner = (i, p)=>{\n        if (i === 0) g.moveTo(p.x, p.y);\n        else g.lineTo(p.x, p.y);\n    };\n    let p1 = points[points.length - 1];\n    for(let i = 0; i < points.length; i++){\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n        if (pRadius <= 0) {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n        if (v1.len < 1e-4 || v2.len < 1e-4) {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n        let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n        let radDirection = 1;\n        let drawDirection = false;\n        if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n            if (angle < 0) angle = Math.PI + angle;\n            else {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        } else if (angle > 0) {\n            radDirection = -1;\n            drawDirection = true;\n        }\n        const halfAngle = angle / 2;\n        let cRadius;\n        let lenOut = Math.abs(Math.cos(halfAngle) * pRadius / Math.sin(halfAngle));\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n        } else cRadius = pRadius;\n        const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n        const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n        const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n        const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n        if (i === 0) g.moveTo(cX + Math.cos(startAngle) * cRadius, cY + Math.sin(startAngle) * cRadius);\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n        p1 = p2;\n    }\n}\nfunction $0af85e9981f3b299$export$cf503f371c53af9e(g, points, radius, smoothness) {\n    const distance = (p1, p2)=>Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n    const pointLerp = (p1, p2, t)=>({\n            x: p1.x + (p2.x - p1.x) * t,\n            y: p1.y + (p2.y - p1.y) * t\n        });\n    const numPoints = points.length;\n    for(let i = 0; i < numPoints; i++){\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n        if (pRadius <= 0) {\n            if (i === 0) g.moveTo(thisPoint.x, thisPoint.y);\n            else g.lineTo(thisPoint.x, thisPoint.y);\n            continue;\n        }\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n        if (lastEdgeLength < 1e-4) start = thisPoint;\n        else {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n            start = pointLerp(thisPoint, lastPoint, lastOffsetDistance / lastEdgeLength);\n        }\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n        if (nextEdgeLength < 1e-4) end = thisPoint;\n        else {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n            end = pointLerp(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);\n        }\n        if (i === 0) g.moveTo(start.x, start.y);\n        else g.lineTo(start.x, start.y);\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n\n});\n\n\n\nparcelRegister(\"aplex\", function(module, exports) {\n\n$parcel$export(module.exports, \"SVGParser\", function () { return $c2c8874c335d60c2$export$2cc2aaca18109aab; });\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $d32rq = parcelRequire(\"d32rq\");\n\"use strict\";\nfunction $c2c8874c335d60c2$export$2cc2aaca18109aab(svg, graphicsContext) {\n    if (typeof svg === \"string\") {\n        const div = document.createElement(\"div\");\n        div.innerHTML = svg.trim();\n        svg = div.querySelector(\"svg\");\n    }\n    const session = {\n        context: graphicsContext,\n        path: new (0, $d32rq.GraphicsPath)()\n    };\n    $c2c8874c335d60c2$var$renderChildren(svg, session, null, null);\n    return graphicsContext;\n}\nfunction $c2c8874c335d60c2$var$renderChildren(svg, session, fillStyle, strokeStyle) {\n    const children = svg.children;\n    const { fillStyle: f1, strokeStyle: s1 } = $c2c8874c335d60c2$var$parseStyle(svg);\n    if (f1 && fillStyle) fillStyle = {\n        ...fillStyle,\n        ...f1\n    };\n    else if (f1) fillStyle = f1;\n    if (s1 && strokeStyle) strokeStyle = {\n        ...strokeStyle,\n        ...s1\n    };\n    else if (s1) strokeStyle = s1;\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n    switch(svg.nodeName.toLowerCase()){\n        case \"path\":\n            d = svg.getAttribute(\"d\");\n            graphicsPath = new (0, $d32rq.GraphicsPath)(d);\n            session.context.path(graphicsPath);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"circle\":\n            cx = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"cx\", 0);\n            cy = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"cy\", 0);\n            r = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"r\", 0);\n            session.context.ellipse(cx, cy, r, r);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"rect\":\n            x = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"x\", 0);\n            y = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"y\", 0);\n            width = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"width\", 0);\n            height = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"height\", 0);\n            rx = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"rx\", 0);\n            ry = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"ry\", 0);\n            if (rx || ry) session.context.roundRect(x, y, width, height, rx || ry);\n            else session.context.rect(x, y, width, height);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"ellipse\":\n            cx = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"cx\", 0);\n            cy = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"cy\", 0);\n            rx = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"rx\", 0);\n            ry = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"ry\", 0);\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"line\":\n            x1 = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"x1\", 0);\n            y1 = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"y1\", 0);\n            x2 = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"x2\", 0);\n            y2 = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"y2\", 0);\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"polygon\":\n            pointsString = svg.getAttribute(\"points\");\n            points = pointsString.match(/\\d+/g).map((n)=>parseInt(n, 10));\n            session.context.poly(points, true);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"polyline\":\n            pointsString = svg.getAttribute(\"points\");\n            points = pointsString.match(/\\d+/g).map((n)=>parseInt(n, 10));\n            session.context.poly(points, false);\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"g\":\n        case \"svg\":\n            break;\n        default:\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n    }\n    for(let i = 0; i < children.length; i++)$c2c8874c335d60c2$var$renderChildren(children[i], session, fillStyle, strokeStyle);\n}\nfunction $c2c8874c335d60c2$var$parseFloatAttribute(svg, id, defaultValue) {\n    const value = svg.getAttribute(id);\n    return value ? Number(value) : defaultValue;\n}\nfunction $c2c8874c335d60c2$var$parseStyle(svg) {\n    const style = svg.getAttribute(\"style\");\n    const strokeStyle = {};\n    const fillStyle = {};\n    let useFill = false;\n    let useStroke = false;\n    if (style) {\n        const styleParts = style.split(\";\");\n        for(let i = 0; i < styleParts.length; i++){\n            const stylePart = styleParts[i];\n            const [key, value] = stylePart.split(\":\");\n            switch(key){\n                case \"stroke\":\n                    if (value !== \"none\") {\n                        strokeStyle.color = (0, $hFslp.Color).shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n                    break;\n                case \"stroke-width\":\n                    strokeStyle.width = Number(value);\n                    break;\n                case \"fill\":\n                    if (value !== \"none\") {\n                        useFill = true;\n                        fillStyle.color = (0, $hFslp.Color).shared.setValue(value).toNumber();\n                    }\n                    break;\n                case \"fill-opacity\":\n                    fillStyle.alpha = Number(value);\n                    break;\n                case \"stroke-opacity\":\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case \"opacity\":\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    } else {\n        const stroke = svg.getAttribute(\"stroke\");\n        if (stroke && stroke !== \"none\") {\n            useStroke = true;\n            strokeStyle.color = (0, $hFslp.Color).shared.setValue(stroke).toNumber();\n            strokeStyle.width = $c2c8874c335d60c2$var$parseFloatAttribute(svg, \"stroke-width\", 1);\n        }\n        const fill = svg.getAttribute(\"fill\");\n        if (fill && fill !== \"none\") {\n            useFill = true;\n            fillStyle.color = (0, $hFslp.Color).shared.setValue(fill).toNumber();\n        }\n    }\n    return {\n        strokeStyle: useStroke ? strokeStyle : null,\n        fillStyle: useFill ? fillStyle : null\n    };\n}\n\n});\n\nparcelRegister(\"jzyMN\", function(module, exports) {\n\n$parcel$export(module.exports, \"toFillStyle\", function () { return $bc8ed156a4cf9235$export$b254764c5530994a; });\n$parcel$export(module.exports, \"toStrokeStyle\", function () { return $bc8ed156a4cf9235$export$64975ed44b74a62b; });\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $faWAK = parcelRequire(\"faWAK\");\n\nvar $iKeQS = parcelRequire(\"iKeQS\");\n\"use strict\";\nfunction $bc8ed156a4cf9235$var$isColorLike(value) {\n    return (0, $hFslp.Color).isColorLike(value);\n}\nfunction $bc8ed156a4cf9235$var$isFillPattern(value) {\n    return value instanceof (0, $iKeQS.FillPattern);\n}\nfunction $bc8ed156a4cf9235$var$isFillGradient(value) {\n    return value instanceof (0, $faWAK.FillGradient);\n}\nfunction $bc8ed156a4cf9235$var$handleColorLike(fill, value, defaultStyle) {\n    const temp = (0, $hFslp.Color).shared.setValue(value ?? 0);\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = (0, $4YnyE.Texture).WHITE;\n    return {\n        ...defaultStyle,\n        ...fill\n    };\n}\nfunction $bc8ed156a4cf9235$var$handleFillPattern(fill, value, defaultStyle) {\n    fill.fill = value;\n    fill.color = 16777215;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n    return {\n        ...defaultStyle,\n        ...fill\n    };\n}\nfunction $bc8ed156a4cf9235$var$handleFillGradient(fill, value, defaultStyle) {\n    value.buildLinearGradient();\n    fill.fill = value;\n    fill.color = 16777215;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n    return {\n        ...defaultStyle,\n        ...fill\n    };\n}\nfunction $bc8ed156a4cf9235$var$handleFillObject(value, defaultStyle) {\n    const style = {\n        ...defaultStyle,\n        ...value\n    };\n    if (style.texture) {\n        if (style.texture !== (0, $4YnyE.Texture).WHITE) {\n            const m = style.matrix?.clone().invert() || new (0, $0kbcf.Matrix)();\n            m.translate(style.texture.frame.x, style.texture.frame.y);\n            m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n            style.matrix = m;\n        }\n        const sourceStyle = style.texture.source.style;\n        if (sourceStyle.addressMode === \"clamp-to-edge\") {\n            sourceStyle.addressMode = \"repeat\";\n            sourceStyle.update();\n        }\n    }\n    const color = (0, $hFslp.Color).shared.setValue(style.color);\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null;\n    return style;\n}\nfunction $bc8ed156a4cf9235$export$b254764c5530994a(value, defaultStyle) {\n    if (value === void 0 || value === null) return null;\n    const fill = {};\n    const objectStyle = value;\n    if ($bc8ed156a4cf9235$var$isColorLike(value)) return $bc8ed156a4cf9235$var$handleColorLike(fill, value, defaultStyle);\n    else if ($bc8ed156a4cf9235$var$isFillPattern(value)) return $bc8ed156a4cf9235$var$handleFillPattern(fill, value, defaultStyle);\n    else if ($bc8ed156a4cf9235$var$isFillGradient(value)) return $bc8ed156a4cf9235$var$handleFillGradient(fill, value, defaultStyle);\n    else if (objectStyle.fill && $bc8ed156a4cf9235$var$isFillPattern(objectStyle.fill)) return $bc8ed156a4cf9235$var$handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    else if (objectStyle.fill && $bc8ed156a4cf9235$var$isFillGradient(objectStyle.fill)) return $bc8ed156a4cf9235$var$handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    return $bc8ed156a4cf9235$var$handleFillObject(objectStyle, defaultStyle);\n}\nfunction $bc8ed156a4cf9235$export$64975ed44b74a62b(value, defaultStyle) {\n    const { width: width, alignment: alignment, miterLimit: miterLimit, cap: cap, join: join, pixelLine: pixelLine, ...rest } = defaultStyle;\n    const fill = $bc8ed156a4cf9235$export$b254764c5530994a(value, rest);\n    if (!fill) return null;\n    return {\n        width: width,\n        alignment: alignment,\n        miterLimit: miterLimit,\n        cap: cap,\n        join: join,\n        pixelLine: pixelLine,\n        ...fill\n    };\n}\n\n});\n\n\nparcelRegister(\"7oI6r\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateTextStyleKey\", function () { return $358ccb3cd87ceb9c$export$8a3681e2b47964bb; });\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\"use strict\";\nconst $358ccb3cd87ceb9c$var$valuesToIterateForKeys = [\n    \"align\",\n    \"breakWords\",\n    \"cssOverrides\",\n    \"fontVariant\",\n    \"fontWeight\",\n    \"leading\",\n    \"letterSpacing\",\n    \"lineHeight\",\n    \"padding\",\n    \"textBaseline\",\n    \"trim\",\n    \"whiteSpace\",\n    \"wordWrap\",\n    \"wordWrapWidth\",\n    \"fontFamily\",\n    \"fontStyle\",\n    \"fontSize\"\n];\nfunction $358ccb3cd87ceb9c$export$8a3681e2b47964bb(style) {\n    const key = [];\n    let index = 0;\n    for(let i = 0; i < $358ccb3cd87ceb9c$var$valuesToIterateForKeys.length; i++){\n        const prop = `_${$358ccb3cd87ceb9c$var$valuesToIterateForKeys[i]}`;\n        key[index++] = style[prop];\n    }\n    index = $358ccb3cd87ceb9c$var$addFillStyleKey(style._fill, key, index);\n    index = $358ccb3cd87ceb9c$var$addStokeStyleKey(style._stroke, key, index);\n    index = $358ccb3cd87ceb9c$var$addDropShadowKey(style.dropShadow, key, index);\n    return key.join(\"-\");\n}\nfunction $358ccb3cd87ceb9c$var$addFillStyleKey(fillStyle, key, index) {\n    if (!fillStyle) return index;\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = fillStyle.fill?.styleKey;\n    return index;\n}\nfunction $358ccb3cd87ceb9c$var$addStokeStyleKey(strokeStyle, key, index) {\n    if (!strokeStyle) return index;\n    index = $358ccb3cd87ceb9c$var$addFillStyleKey(strokeStyle, key, index);\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n    return index;\n}\nfunction $358ccb3cd87ceb9c$var$addDropShadowKey(dropShadow, key, index) {\n    if (!dropShadow) return index;\n    key[index++] = dropShadow.alpha;\n    key[index++] = dropShadow.angle;\n    key[index++] = dropShadow.blur;\n    key[index++] = dropShadow.distance;\n    key[index++] = (0, $hFslp.Color).shared.setValue(dropShadow.color).toNumber();\n    return index;\n}\n\n});\n\n\nparcelRegister(\"1Fy2M\", function(module, exports) {\n\n$parcel$export(module.exports, \"DynamicBitmapFont\", function () { return $63e2c593b9d26d3b$export$bce21273d0a2e6c7; });\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\nvar $02IUF = parcelRequire(\"02IUF\");\n\nvar $hRHFw = parcelRequire(\"hRHFw\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $dzZFt = parcelRequire(\"dzZFt\");\n\nvar $hjHBC = parcelRequire(\"hjHBC\");\n\nvar $clKJs = parcelRequire(\"clKJs\");\n\nvar $2oqF9 = parcelRequire(\"2oqF9\");\n\nvar $4vQUT = parcelRequire(\"4vQUT\");\n\nvar $8VyWJ = parcelRequire(\"8VyWJ\");\n\"use strict\";\nconst $63e2c593b9d26d3b$var$_DynamicBitmapFont = class _DynamicBitmapFont extends (0, $4vQUT.AbstractBitmapFont) {\n    /**\n   * @param options - The options for the dynamic bitmap font.\n   */ constructor(options){\n        super();\n        /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */ this.resolution = 1;\n        /** The pages of the font. */ this.pages = [];\n        this._padding = 0;\n        this._measureCache = /* @__PURE__ */ Object.create(null);\n        this._currentChars = [];\n        this._currentX = 0;\n        this._currentY = 0;\n        this._currentPageIndex = -1;\n        this._skipKerning = false;\n        const dynamicOptions = {\n            ..._DynamicBitmapFont.defaultOptions,\n            ...options\n        };\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n        const style = dynamicOptions.style.clone();\n        if (dynamicOptions.overrideFill) {\n            style._fill.color = 16777215;\n            style._fill.alpha = 1;\n            style._fill.texture = (0, $4YnyE.Texture).WHITE;\n            style._fill.fill = null;\n        }\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n        const requestedFontSize = style.fontSize;\n        style.fontSize = this.baseMeasurementFontSize;\n        const font = (0, $hjHBC.fontStringFromTextStyle)(style);\n        if (dynamicOptions.overrideSize) {\n            if (style._stroke) style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n        } else style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n        this.fontMetrics = (0, $dzZFt.CanvasTextMetrics).measureFont(font);\n        this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n    ensureCharacters(chars) {\n        const charList = (0, $8VyWJ.resolveCharacters)(chars).filter((char)=>!this._currentChars.includes(char)).filter((char, index, self)=>self.indexOf(char) === index);\n        if (!charList.length) return;\n        this._currentChars = [\n            ...this._currentChars,\n            ...charList\n        ];\n        let pageData;\n        if (this._currentPageIndex === -1) pageData = this._nextPage();\n        else pageData = this.pages[this._currentPageIndex];\n        let { canvas: canvas, context: context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n        const style = this._style;\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n        for(let i = 0; i < charList.length; i++){\n            const char = charList[i];\n            const metrics = (0, $dzZFt.CanvasTextMetrics).measureText(char, style, canvas, false);\n            metrics.lineHeight = metrics.height;\n            const width = metrics.width * fontScale;\n            const textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n            const height = metrics.height * fontScale;\n            const paddedWidth = textureGlyphWidth + padding * 2;\n            const paddedHeight = height + padding * 2;\n            skipTexture = false;\n            if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n            }\n            if (currentX + paddedWidth > maxTextureWidth) {\n                currentY += maxCharHeight;\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n                if (currentY + maxCharHeight > maxTextureHeight) {\n                    textureSource.update();\n                    const pageData2 = this._nextPage();\n                    canvas = pageData2.canvasAndContext.canvas;\n                    context = pageData2.canvasAndContext.context;\n                    textureSource = pageData2.texture.source;\n                    currentY = 0;\n                }\n            }\n            const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance: xAdvance,\n                kerning: {}\n            };\n            if (skipTexture) {\n                this._drawGlyph(context, metrics, currentX + padding, currentY + padding, fontScale, style);\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n                const frame = new (0, $ec4lc.Rectangle)(currentX / px * textureSource.width, currentY / py * textureSource.height, paddedWidth / px * textureSource.width, paddedHeight / py * textureSource.height);\n                this.chars[char].texture = new (0, $4YnyE.Texture)({\n                    source: textureSource,\n                    frame: frame\n                });\n                currentX += Math.ceil(paddedWidth);\n            }\n        }\n        textureSource.update();\n        this._currentX = currentX;\n        this._currentY = currentY;\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n    /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */ get pageTextures() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n        return this.pages;\n    }\n    _applyKerning(newChars, context) {\n        const measureCache = this._measureCache;\n        for(let i = 0; i < newChars.length; i++){\n            const first = newChars[i];\n            for(let j = 0; j < this._currentChars.length; j++){\n                const second = this._currentChars[j];\n                let c1 = measureCache[first];\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n                let c2 = measureCache[second];\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n                if (amount) this.chars[first].kerning[second] = amount;\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n                if (amount) this.chars[second].kerning[first] = amount;\n            }\n        }\n    }\n    _nextPage() {\n        this._currentPageIndex++;\n        const textureResolution = this.resolution;\n        const canvasAndContext = (0, $02IUF.CanvasPool).getOptimalCanvasAndContext(this._textureSize, this._textureSize, textureResolution);\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new (0, $4YnyE.Texture)({\n            source: new (0, $hRHFw.ImageSource)({\n                resource: canvasAndContext.canvas,\n                resolution: resolution,\n                alphaMode: \"premultiply-alpha-on-upload\",\n                autoGenerateMipmaps: this._mipmap\n            })\n        });\n        const pageData = {\n            canvasAndContext: canvasAndContext,\n            texture: texture\n        };\n        this.pages[this._currentPageIndex] = pageData;\n        return pageData;\n    }\n    // canvas style!\n    _setupContext(context, style, resolution) {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = (0, $hjHBC.fontStringFromTextStyle)(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n        if (stroke) {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n            context.strokeStyle = (0, $clKJs.getCanvasFillStyle)(stroke, context);\n        }\n        if (style._fill) context.fillStyle = (0, $clKJs.getCanvasFillStyle)(style._fill, context);\n        if (style.dropShadow) {\n            const shadowOptions = style.dropShadow;\n            const rgb = (0, $hFslp.Color).shared.setValue(shadowOptions.color).toArray();\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        } else {\n            context.shadowColor = \"black\";\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n    _drawGlyph(context, metrics, x, y, fontScale, style) {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n        const tx = x + strokeThickness / 2;\n        const ty = y - strokeThickness / 2;\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n        if (style.stroke && strokeThickness) context.strokeText(char, tx, ty + lineHeight - descent);\n        if (style._fill) context.fillText(char, tx, ty + lineHeight - descent);\n    }\n    destroy() {\n        super.destroy();\n        for(let i = 0; i < this.pages.length; i++){\n            const { canvasAndContext: canvasAndContext, texture: texture } = this.pages[i];\n            (0, $02IUF.CanvasPool).returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n        this.pages = null;\n    }\n};\n$63e2c593b9d26d3b$var$_DynamicBitmapFont.defaultOptions = {\n    textureSize: 512,\n    style: new (0, $2oqF9.TextStyle)(),\n    mipmap: true\n};\nlet $63e2c593b9d26d3b$export$bce21273d0a2e6c7 = $63e2c593b9d26d3b$var$_DynamicBitmapFont;\n\n});\nparcelRegister(\"02IUF\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasPool\", function () { return $aab25ca12e1b7da5$export$e56d0a06781accc9; });\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $7qPGY = parcelRequire(\"7qPGY\");\n\"use strict\";\nclass $aab25ca12e1b7da5$export$62d9f0b8aada09d7 {\n    constructor(canvasOptions){\n        this._canvasPool = /* @__PURE__ */ Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n    /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */ _createCanvasAndContext(pixelWidth, pixelHeight) {\n        const canvas = (0, $d0V4H.DOMAdapter).get().createCanvas();\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n        const context = canvas.getContext(\"2d\");\n        return {\n            canvas: canvas,\n            context: context\n        };\n    }\n    /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */ getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n        minWidth = Math.ceil(minWidth * resolution - 1e-6);\n        minHeight = Math.ceil(minHeight * resolution - 1e-6);\n        minWidth = (0, $7qPGY.nextPow2)(minWidth);\n        minHeight = (0, $7qPGY.nextPow2)(minHeight);\n        const key = (minWidth << 17) + (minHeight << 1);\n        if (!this._canvasPool[key]) this._canvasPool[key] = [];\n        let canvasAndContext = this._canvasPool[key].pop();\n        if (!canvasAndContext) canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        return canvasAndContext;\n    }\n    /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */ returnCanvasAndContext(canvasAndContext) {\n        const canvas = canvasAndContext.canvas;\n        const { width: width, height: height } = canvas;\n        const key = (width << 17) + (height << 1);\n        canvasAndContext.context.clearRect(0, 0, width, height);\n        this._canvasPool[key].push(canvasAndContext);\n    }\n    clear() {\n        this._canvasPool = {};\n    }\n}\nconst $aab25ca12e1b7da5$export$e56d0a06781accc9 = new $aab25ca12e1b7da5$export$62d9f0b8aada09d7();\n\n});\n\nparcelRegister(\"dzZFt\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextMetrics\", function () { return $f9c250956f0e8c12$export$b12f6bdc825d944f; });\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $hjHBC = parcelRequire(\"hjHBC\");\n\"use strict\";\nconst $f9c250956f0e8c12$var$contextSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true\n};\nconst $f9c250956f0e8c12$var$_CanvasTextMetrics = class _CanvasTextMetrics {\n    /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */ static get experimentalLetterSpacingSupported() {\n        let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n        if (result !== void 0) {\n            const proto = (0, $d0V4H.DOMAdapter).get().getCanvasRenderingContext2D().prototype;\n            result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n        }\n        return result;\n    }\n    /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */ constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties){\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n    /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */ static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n        const textKey = `${text}:${style.styleKey}`;\n        if (_CanvasTextMetrics._measurementCache[textKey]) return _CanvasTextMetrics._measurementCache[textKey];\n        const font = (0, $hjHBC.fontStringFromTextStyle)(style);\n        const fontProperties = _CanvasTextMetrics.measureFont(font);\n        if (fontProperties.fontSize === 0) {\n            fontProperties.fontSize = style.fontSize;\n            fontProperties.ascent = style.fontSize;\n        }\n        const context = _CanvasTextMetrics.__context;\n        context.font = font;\n        const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array(lines.length);\n        let maxLineWidth = 0;\n        for(let i = 0; i < lines.length; i++){\n            const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n        const strokeWidth = style._stroke?.width || 0;\n        let width = maxLineWidth + strokeWidth;\n        if (style.dropShadow) width += style.dropShadow.distance;\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n        if (style.dropShadow) height += style.dropShadow.distance;\n        const measurements = new _CanvasTextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);\n        return measurements;\n    }\n    static _measureText(text, letterSpacing, context) {\n        let useExperimentalLetterSpacing = false;\n        if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n            if (_CanvasTextMetrics.experimentalLetterSpacing) {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            } else {\n                context.letterSpacing = \"0px\";\n                context.textLetterSpacing = \"0px\";\n            }\n        }\n        const metrics = context.measureText(text);\n        let metricWidth = metrics.width;\n        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n        if (metricWidth > 0) {\n            if (useExperimentalLetterSpacing) {\n                metricWidth -= letterSpacing;\n                boundsWidth -= letterSpacing;\n            } else {\n                const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n                metricWidth += val;\n                boundsWidth += val;\n            }\n        }\n        return Math.max(metricWidth, boundsWidth);\n    }\n    /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */ static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n        const context = canvas.getContext(\"2d\", $f9c250956f0e8c12$var$contextSettings);\n        let width = 0;\n        let line = \"\";\n        let lines = \"\";\n        const cache = /* @__PURE__ */ Object.create(null);\n        const { letterSpacing: letterSpacing, whiteSpace: whiteSpace } = style;\n        const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n        let canPrependSpaces = !collapseSpaces;\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n        const tokens = _CanvasTextMetrics._tokenize(text);\n        for(let i = 0; i < tokens.length; i++){\n            let token = tokens[i];\n            if (_CanvasTextMetrics._isNewline(token)) {\n                if (!collapseNewlines) {\n                    lines += _CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = \"\";\n                    width = 0;\n                    continue;\n                }\n                token = \" \";\n            }\n            if (collapseSpaces) {\n                const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n                if (currIsBreakingSpace && lastIsBreakingSpace) continue;\n            }\n            const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n            if (tokenWidth > wordWrapWidth) {\n                if (line !== \"\") {\n                    lines += _CanvasTextMetrics._addLine(line);\n                    line = \"\";\n                    width = 0;\n                }\n                if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n                    const characters = _CanvasTextMetrics.wordWrapSplit(token);\n                    for(let j = 0; j < characters.length; j++){\n                        let char = characters[j];\n                        let lastChar = char;\n                        let k = 1;\n                        while(characters[j + k]){\n                            const nextChar = characters[j + k];\n                            if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) char += nextChar;\n                            else break;\n                            lastChar = nextChar;\n                            k++;\n                        }\n                        j += k - 1;\n                        const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n                        if (characterWidth + width > wordWrapWidth) {\n                            lines += _CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = \"\";\n                            width = 0;\n                        }\n                        line += char;\n                        width += characterWidth;\n                    }\n                } else {\n                    if (line.length > 0) {\n                        lines += _CanvasTextMetrics._addLine(line);\n                        line = \"\";\n                        width = 0;\n                    }\n                    const isLastToken = i === tokens.length - 1;\n                    lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = \"\";\n                    width = 0;\n                }\n            } else {\n                if (tokenWidth + width > wordWrapWidth) {\n                    canPrependSpaces = false;\n                    lines += _CanvasTextMetrics._addLine(line);\n                    line = \"\";\n                    width = 0;\n                }\n                if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n                    line += token;\n                    width += tokenWidth;\n                }\n            }\n        }\n        lines += _CanvasTextMetrics._addLine(line, false);\n        return lines;\n    }\n    /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */ static _addLine(line, newLine = true) {\n        line = _CanvasTextMetrics._trimRight(line);\n        line = newLine ? `${line}\n` : line;\n        return line;\n    }\n    /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */ static _getFromCache(key, letterSpacing, cache, context) {\n        let width = cache[key];\n        if (typeof width !== \"number\") {\n            width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n        return width;\n    }\n    /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */ static _collapseSpaces(whiteSpace) {\n        return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n    }\n    /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */ static _collapseNewlines(whiteSpace) {\n        return whiteSpace === \"normal\";\n    }\n    /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */ static _trimRight(text) {\n        if (typeof text !== \"string\") return \"\";\n        for(let i = text.length - 1; i >= 0; i--){\n            const char = text[i];\n            if (!_CanvasTextMetrics.isBreakingSpace(char)) break;\n            text = text.slice(0, -1);\n        }\n        return text;\n    }\n    /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */ static _isNewline(char) {\n        if (typeof char !== \"string\") return false;\n        return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n    /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */ static isBreakingSpace(char, _nextChar) {\n        if (typeof char !== \"string\") return false;\n        return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n    /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */ static _tokenize(text) {\n        const tokens = [];\n        let token = \"\";\n        if (typeof text !== \"string\") return tokens;\n        for(let i = 0; i < text.length; i++){\n            const char = text[i];\n            const nextChar = text[i + 1];\n            if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n                if (token !== \"\") {\n                    tokens.push(token);\n                    token = \"\";\n                }\n                tokens.push(char);\n                continue;\n            }\n            token += char;\n        }\n        if (token !== \"\") tokens.push(token);\n        return tokens;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */ static canBreakWords(_token, breakWords) {\n        return breakWords;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */ static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n        return true;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */ static wordWrapSplit(token) {\n        return _CanvasTextMetrics.graphemeSegmenter(token);\n    }\n    /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */ static measureFont(font) {\n        if (_CanvasTextMetrics._fonts[font]) return _CanvasTextMetrics._fonts[font];\n        const context = _CanvasTextMetrics._context;\n        context.font = font;\n        const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n        _CanvasTextMetrics._fonts[font] = properties;\n        return properties;\n    }\n    /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */ static clearMetrics(font = \"\") {\n        if (font) delete _CanvasTextMetrics._fonts[font];\n        else _CanvasTextMetrics._fonts = {};\n    }\n    /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */ static get _canvas() {\n        if (!_CanvasTextMetrics.__canvas) {\n            let canvas;\n            try {\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext(\"2d\", $f9c250956f0e8c12$var$contextSettings);\n                if (context?.measureText) {\n                    _CanvasTextMetrics.__canvas = c;\n                    return c;\n                }\n                canvas = (0, $d0V4H.DOMAdapter).get().createCanvas();\n            } catch (_cx) {\n                canvas = (0, $d0V4H.DOMAdapter).get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            _CanvasTextMetrics.__canvas = canvas;\n        }\n        return _CanvasTextMetrics.__canvas;\n    }\n    /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */ static get _context() {\n        if (!_CanvasTextMetrics.__context) _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", $f9c250956f0e8c12$var$contextSettings);\n        return _CanvasTextMetrics.__context;\n    }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */ $f9c250956f0e8c12$var$_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */ $f9c250956f0e8c12$var$_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */ $f9c250956f0e8c12$var$_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */ $f9c250956f0e8c12$var$_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */ $f9c250956f0e8c12$var$_CanvasTextMetrics.graphemeSegmenter = (()=>{\n    if (typeof Intl?.Segmenter === \"function\") {\n        const segmenter = new Intl.Segmenter();\n        return (s)=>[\n                ...segmenter.segment(s)\n            ].map((x)=>x.segment);\n    }\n    return (s)=>[\n            ...s\n        ];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */ $f9c250956f0e8c12$var$_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */ $f9c250956f0e8c12$var$_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */ $f9c250956f0e8c12$var$_CanvasTextMetrics._newlines = [\n    10,\n    // line feed\n    13\n];\n/** Cache of breaking spaces. */ $f9c250956f0e8c12$var$_CanvasTextMetrics._breakingSpaces = [\n    9,\n    // character tabulation\n    32,\n    // space\n    8192,\n    // en quad\n    8193,\n    // em quad\n    8194,\n    // en space\n    8195,\n    // em space\n    8196,\n    // three-per-em space\n    8197,\n    // four-per-em space\n    8198,\n    // six-per-em space\n    8200,\n    // punctuation space\n    8201,\n    // thin space\n    8202,\n    // hair space\n    8287,\n    // medium mathematical space\n    12288\n];\n$f9c250956f0e8c12$var$_CanvasTextMetrics._measurementCache = {};\nlet $f9c250956f0e8c12$export$b12f6bdc825d944f = $f9c250956f0e8c12$var$_CanvasTextMetrics;\n\n});\nparcelRegister(\"hjHBC\", function(module, exports) {\n\n$parcel$export(module.exports, \"fontStringFromTextStyle\", function () { return $d6b4d0f570937df8$export$b7b5edb82ac3fc66; });\n\"use strict\";\nconst $d6b4d0f570937df8$var$genericFontFamilies = [\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\"\n];\nfunction $d6b4d0f570937df8$export$b7b5edb82ac3fc66(style) {\n    const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n    let fontFamilies = style.fontFamily;\n    if (!Array.isArray(style.fontFamily)) fontFamilies = style.fontFamily.split(\",\");\n    for(let i = fontFamilies.length - 1; i >= 0; i--){\n        let fontFamily = fontFamilies[i].trim();\n        if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !$d6b4d0f570937df8$var$genericFontFamilies.includes(fontFamily)) fontFamily = `\"${fontFamily}\"`;\n        fontFamilies[i] = fontFamily;\n    }\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\n});\n\n\nparcelRegister(\"clKJs\", function(module, exports) {\n\n$parcel$export(module.exports, \"getCanvasFillStyle\", function () { return $a1ab4fe444eeacdc$export$c31af9427fa8602b; });\n\nvar $hFslp = parcelRequire(\"hFslp\");\n\nvar $0kbcf = parcelRequire(\"0kbcf\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $faWAK = parcelRequire(\"faWAK\");\n\nvar $iKeQS = parcelRequire(\"iKeQS\");\n\"use strict\";\nfunction $a1ab4fe444eeacdc$export$c31af9427fa8602b(fillStyle, context) {\n    if (fillStyle.texture === (0, $4YnyE.Texture).WHITE && !fillStyle.fill) return (0, $hFslp.Color).shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n    else if (!fillStyle.fill) {\n        const pattern = context.createPattern(fillStyle.texture.source.resource, \"repeat\");\n        const tempMatrix = fillStyle.matrix.copyTo((0, $0kbcf.Matrix).shared);\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n        return pattern;\n    } else if (fillStyle.fill instanceof (0, $iKeQS.FillPattern)) {\n        const fillPattern = fillStyle.fill;\n        const pattern = context.createPattern(fillPattern.texture.source.resource, \"repeat\");\n        const tempMatrix = fillPattern.transform.copyTo((0, $0kbcf.Matrix).shared);\n        tempMatrix.scale(fillPattern.texture.frame.width, fillPattern.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n        return pattern;\n    } else if (fillStyle.fill instanceof (0, $faWAK.FillGradient)) {\n        const fillGradient = fillStyle.fill;\n        if (fillGradient.type === \"linear\") {\n            const gradient = context.createLinearGradient(fillGradient.x0, fillGradient.y0, fillGradient.x1, fillGradient.y1);\n            fillGradient.gradientStops.forEach((stop)=>{\n                gradient.addColorStop(stop.offset, (0, $hFslp.Color).shared.setValue(stop.color).toHex());\n            });\n            return gradient;\n        }\n    }\n    (0, $c9aw6.warn)(\"FillStyle not recognised\", fillStyle);\n    return \"red\";\n}\n\n});\n\nparcelRegister(\"4vQUT\", function(module, exports) {\n\n$parcel$export(module.exports, \"AbstractBitmapFont\", function () { return $74858068d5eabacd$export$70779aee6e4c1309; });\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\"use strict\";\nclass $74858068d5eabacd$export$70779aee6e4c1309 extends (0, (/*@__PURE__*/$parcel$interopDefault($6p5EE))) {\n    constructor(){\n        super(...arguments);\n        /** The map of characters by character code. */ this.chars = /* @__PURE__ */ Object.create(null);\n        /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */ this.lineHeight = 0;\n        /**\n     * The name of the font face\n     * @type {string}\n     */ this.fontFamily = \"\";\n        /** The metrics of the font face. */ this.fontMetrics = {\n            fontSize: 0,\n            ascent: 0,\n            descent: 0\n        };\n        /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */ this.baseLineOffset = 0;\n        /** The range and type of the distance field for this font. */ this.distanceField = {\n            type: \"none\",\n            range: 0\n        };\n        /** The map of base page textures (i.e., sheets of glyphs). */ this.pages = [];\n        /** should the fill for this font be applied as a tint to the text. */ this.applyFillAsTint = true;\n        /** The size of the font face in pixels. */ this.baseMeasurementFontSize = 100;\n        this.baseRenderedFontSize = 100;\n    }\n    /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */ get font() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.\");\n        return this.fontFamily;\n    }\n    /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */ get pageTextures() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n        return this.pages;\n    }\n    /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */ get size() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.\");\n        return this.fontMetrics.fontSize;\n    }\n    /**\n   * The kind of distance field for this font or \"none\".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */ get distanceFieldRange() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.\");\n        return this.distanceField.range;\n    }\n    /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */ get distanceFieldType() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.\");\n        return this.distanceField.type;\n    }\n    destroy(destroyTextures = false) {\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        for(const i in this.chars)this.chars[i].texture?.destroy();\n        this.chars = null;\n        if (destroyTextures) {\n            this.pages.forEach((page)=>page.texture.destroy(true));\n            this.pages = null;\n        }\n    }\n}\n\n});\n\nparcelRegister(\"8VyWJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"resolveCharacters\", function () { return $7c5532b9fd92ef8a$export$221291e5031b03d8; });\n\"use strict\";\nfunction $7c5532b9fd92ef8a$export$221291e5031b03d8(chars) {\n    if (chars === \"\") return [];\n    if (typeof chars === \"string\") chars = [\n        chars\n    ];\n    const result = [];\n    for(let i = 0, j = chars.length; i < j; i++){\n        const item = chars[i];\n        if (Array.isArray(item)) {\n            if (item.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            if (item[0].length === 0 || item[1].length === 0) throw new Error(\"[BitmapFont]: Invalid character delimiter.\");\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n            if (endCode < startCode) throw new Error(\"[BitmapFont]: Invalid character range.\");\n            for(let i2 = startCode, j2 = endCode; i2 <= j2; i2++)result.push(String.fromCharCode(i2));\n        } else result.push(...Array.from(item));\n    }\n    if (result.length === 0) throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n    return result;\n}\n\n});\n\n\nparcelRegister(\"c57nt\", function(module, exports) {\n\n$parcel$export(module.exports, \"getBitmapTextLayout\", function () { return $c196de50aab0a4f4$export$beeb37b3e20d3ee4; });\n\"use strict\";\nfunction $c196de50aab0a4f4$export$beeb37b3e20d3ee4(chars, style, font, trimEnd) {\n    const layoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [\n            {\n                width: 0,\n                charPositions: [],\n                spaceWidth: 0,\n                spacesIndex: [],\n                chars: []\n            }\n        ]\n    };\n    layoutData.offsetY = font.baseLineOffset;\n    let currentLine = layoutData.lines[0];\n    let previousChar = null;\n    let firstWord = true;\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0,\n        // use index to not modify the array as we use it a lot!\n        positions: [],\n        chars: []\n    };\n    const nextWord = (word)=>{\n        const start = currentLine.width;\n        for(let j = 0; j < currentWord.index; j++){\n            const position = word.positions[j];\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n        currentLine.width += word.width;\n        firstWord = false;\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n    };\n    const nextLine = ()=>{\n        let index = currentLine.chars.length - 1;\n        if (trimEnd) {\n            let lastChar = currentLine.chars[index];\n            while(lastChar === \" \"){\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: []\n        };\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n    for(let i = 0; i < chars.length + 1; i++){\n        let char;\n        const isEnd = i === chars.length;\n        if (!isEnd) char = chars[i];\n        const charData = font.chars[char] || font.chars[\" \"];\n        const isSpace = /(?:\\s)/.test(char);\n        const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n        if (isWordBreak) {\n            const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n            if (addWordToNextLine) {\n                nextLine();\n                nextWord(currentWord);\n                if (!isEnd) currentLine.charPositions.push(0);\n            } else {\n                currentWord.start = currentLine.width;\n                nextWord(currentWord);\n                if (!isEnd) currentLine.charPositions.push(0);\n            }\n            if (char === \"\\r\" || char === \"\\n\") {\n                if (currentLine.width !== 0) nextLine();\n            } else if (!isEnd) {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n                currentLine.width += spaceWidth;\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n            }\n        } else {\n            const kerning = charData.kerning[previousChar] || 0;\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n            currentWord.width += nextCharWidth;\n        }\n        previousChar = char;\n    }\n    nextLine();\n    if (style.align === \"center\") $c196de50aab0a4f4$var$alignCenter(layoutData);\n    else if (style.align === \"right\") $c196de50aab0a4f4$var$alignRight(layoutData);\n    else if (style.align === \"justify\") $c196de50aab0a4f4$var$alignJustify(layoutData);\n    return layoutData;\n}\nfunction $c196de50aab0a4f4$var$alignCenter(measurementData) {\n    for(let i = 0; i < measurementData.lines.length; i++){\n        const line = measurementData.lines[i];\n        const offset = measurementData.width / 2 - line.width / 2;\n        for(let j = 0; j < line.charPositions.length; j++)line.charPositions[j] += offset;\n    }\n}\nfunction $c196de50aab0a4f4$var$alignRight(measurementData) {\n    for(let i = 0; i < measurementData.lines.length; i++){\n        const line = measurementData.lines[i];\n        const offset = measurementData.width - line.width;\n        for(let j = 0; j < line.charPositions.length; j++)line.charPositions[j] += offset;\n    }\n}\nfunction $c196de50aab0a4f4$var$alignJustify(measurementData) {\n    const width = measurementData.width;\n    for(let i = 0; i < measurementData.lines.length; i++){\n        const line = measurementData.lines[i];\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n        let offset = 0;\n        const totalSpaces = line.spacesIndex.length;\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n        const spaceWidth = newSpaceWidth;\n        for(let j = 0; j < line.charPositions.length; j++){\n            if (j === spaceIndex) {\n                spaceIndex = line.spacesIndex[indy++];\n                offset += spaceWidth;\n            }\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\n});\n\n\nparcelRegister(\"3binI\", function(module, exports) {\n\n$parcel$export(module.exports, \"Graphics\", function () { return $fa8815e339f41f96$export$29d3e417456abdad; });\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $4ndcs = parcelRequire(\"4ndcs\");\n\nvar $lfe2w = parcelRequire(\"lfe2w\");\n\"use strict\";\nclass $fa8815e339f41f96$export$29d3e417456abdad extends (0, $4ndcs.ViewContainer) {\n    /**\n   * @param options - Options for the Graphics.\n   */ constructor(options){\n        if (options instanceof (0, $lfe2w.GraphicsContext)) options = {\n            context: options\n        };\n        const { context: context, roundPixels: roundPixels, ...rest } = options || {};\n        super({\n            label: \"Graphics\",\n            ...rest\n        });\n        this.renderPipeId = \"graphics\";\n        if (!context) this._context = this._ownedContext = new (0, $lfe2w.GraphicsContext)();\n        else this._context = context;\n        this._context.on(\"update\", this.onViewUpdate, this);\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n    set context(context) {\n        if (context === this._context) return;\n        this._context.off(\"update\", this.onViewUpdate, this);\n        this._context = context;\n        this._context.on(\"update\", this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n    get context() {\n        return this._context;\n    }\n    /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        return this._context.bounds;\n    }\n    /**\n   * Graphics objects do not need to update their bounds as the context handles this.\n   * @private\n   */ updateBounds() {}\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        return this._context.containsPoint(point);\n    }\n    /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */ destroy(options) {\n        if (this._ownedContext && !options) this._ownedContext.destroy(options);\n        else if (options === true || options?.context === true) this._context.destroy(options);\n        this._ownedContext = null;\n        this._context = null;\n        super.destroy(options);\n    }\n    _callContextMethod(method, args) {\n        this.context[method](...args);\n        return this;\n    }\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setFillStyle(...args) {\n        return this._callContextMethod(\"setFillStyle\", args);\n    }\n    /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setStrokeStyle(...args) {\n        return this._callContextMethod(\"setStrokeStyle\", args);\n    }\n    fill(...args) {\n        return this._callContextMethod(\"fill\", args);\n    }\n    /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ stroke(...args) {\n        return this._callContextMethod(\"stroke\", args);\n    }\n    texture(...args) {\n        return this._callContextMethod(\"texture\", args);\n    }\n    /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ beginPath() {\n        return this._callContextMethod(\"beginPath\", []);\n    }\n    /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */ cut() {\n        return this._callContextMethod(\"cut\", []);\n    }\n    arc(...args) {\n        return this._callContextMethod(\"arc\", args);\n    }\n    arcTo(...args) {\n        return this._callContextMethod(\"arcTo\", args);\n    }\n    arcToSvg(...args) {\n        return this._callContextMethod(\"arcToSvg\", args);\n    }\n    bezierCurveTo(...args) {\n        return this._callContextMethod(\"bezierCurveTo\", args);\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        return this._callContextMethod(\"closePath\", []);\n    }\n    ellipse(...args) {\n        return this._callContextMethod(\"ellipse\", args);\n    }\n    circle(...args) {\n        return this._callContextMethod(\"circle\", args);\n    }\n    path(...args) {\n        return this._callContextMethod(\"path\", args);\n    }\n    lineTo(...args) {\n        return this._callContextMethod(\"lineTo\", args);\n    }\n    moveTo(...args) {\n        return this._callContextMethod(\"moveTo\", args);\n    }\n    quadraticCurveTo(...args) {\n        return this._callContextMethod(\"quadraticCurveTo\", args);\n    }\n    rect(...args) {\n        return this._callContextMethod(\"rect\", args);\n    }\n    roundRect(...args) {\n        return this._callContextMethod(\"roundRect\", args);\n    }\n    poly(...args) {\n        return this._callContextMethod(\"poly\", args);\n    }\n    regularPoly(...args) {\n        return this._callContextMethod(\"regularPoly\", args);\n    }\n    roundPoly(...args) {\n        return this._callContextMethod(\"roundPoly\", args);\n    }\n    roundShape(...args) {\n        return this._callContextMethod(\"roundShape\", args);\n    }\n    filletRect(...args) {\n        return this._callContextMethod(\"filletRect\", args);\n    }\n    chamferRect(...args) {\n        return this._callContextMethod(\"chamferRect\", args);\n    }\n    star(...args) {\n        return this._callContextMethod(\"star\", args);\n    }\n    svg(...args) {\n        return this._callContextMethod(\"svg\", args);\n    }\n    restore(...args) {\n        return this._callContextMethod(\"restore\", args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */ save() {\n        return this._callContextMethod(\"save\", []);\n    }\n    /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */ getTransform() {\n        return this.context.getTransform();\n    }\n    /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ resetTransform() {\n        return this._callContextMethod(\"resetTransform\", []);\n    }\n    rotateTransform(...args) {\n        return this._callContextMethod(\"rotate\", args);\n    }\n    scaleTransform(...args) {\n        return this._callContextMethod(\"scale\", args);\n    }\n    setTransform(...args) {\n        return this._callContextMethod(\"setTransform\", args);\n    }\n    transform(...args) {\n        return this._callContextMethod(\"transform\", args);\n    }\n    translateTransform(...args) {\n        return this._callContextMethod(\"translate\", args);\n    }\n    /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ clear() {\n        return this._callContextMethod(\"clear\", []);\n    }\n    /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */ get fillStyle() {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value) {\n        this._context.fillStyle = value;\n    }\n    /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */ get strokeStyle() {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value) {\n        this._context.strokeStyle = value;\n    }\n    /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */ clone(deep = false) {\n        if (deep) return new $fa8815e339f41f96$export$29d3e417456abdad(this._context.clone());\n        this._ownedContext = null;\n        const clone = new $fa8815e339f41f96$export$29d3e417456abdad(this._context);\n        return clone;\n    }\n    // -------- v7 deprecations ---------\n    /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */ lineStyle(width, color, alpha) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n        const strokeStyle = {};\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n        this.context.strokeStyle = strokeStyle;\n        return this;\n    }\n    /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */ beginFill(color, alpha) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n        const fillStyle = {};\n        if (color !== void 0) fillStyle.color = color;\n        if (alpha !== void 0) fillStyle.alpha = alpha;\n        this.context.fillStyle = fillStyle;\n        return this;\n    }\n    /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */ endFill() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n        if (strokeStyle.width !== (0, $lfe2w.GraphicsContext).defaultStrokeStyle.width || strokeStyle.color !== (0, $lfe2w.GraphicsContext).defaultStrokeStyle.color || strokeStyle.alpha !== (0, $lfe2w.GraphicsContext).defaultStrokeStyle.alpha) this.context.stroke();\n        return this;\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */ drawCircle(...args) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Graphics#drawCircle has been renamed to Graphics#circle\");\n        return this._callContextMethod(\"circle\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */ drawEllipse(...args) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n        return this._callContextMethod(\"ellipse\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */ drawPolygon(...args) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n        return this._callContextMethod(\"poly\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */ drawRect(...args) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Graphics#drawRect has been renamed to Graphics#rect\");\n        return this._callContextMethod(\"rect\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */ drawRoundedRect(...args) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n        return this._callContextMethod(\"roundRect\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */ drawStar(...args) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Graphics#drawStar has been renamed to Graphics#star\");\n        return this._callContextMethod(\"star\", args);\n    }\n}\n\n});\n\nvar $d72c5d5293dce407$exports = {};\n\n(parcelRequire(\"kyEFX\")).register(new URL(\"\", import.meta.url).toString(), JSON.parse(\"[\\\"5ZPII\\\",\\\"index.28167d82.js\\\",\\\"5nC1g\\\",\\\"browserAll.bfad46de.js\\\",\\\"d1bSR\\\",\\\"browserAll.7aacd795.js\\\",\\\"8rxSw\\\",\\\"webworkerAll.2a53aaf8.js\\\",\\\"fqXAI\\\",\\\"WebGPURenderer.f42d4328.js\\\",\\\"gyKa4\\\",\\\"WebGPURenderer.421fc519.js\\\",\\\"dgumL\\\",\\\"WebGLRenderer.6e2650a7.js\\\"]\"));\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\n\nconst $46e9c21fe5524152$export$a6aad6334ef58a1c = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).Environment,\n        name: \"browser\",\n        priority: -1\n    },\n    test: ()=>true,\n    load: async ()=>{\n        await (parcelRequire(\"87946\"));\n    }\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\n\nconst $aac24c264e299d39$export$ee43dd1acddf6cf8 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).Environment,\n        name: \"webworker\",\n        priority: 0\n    },\n    test: ()=>typeof self !== \"undefined\" && self.WorkerGlobalScope !== void 0,\n    load: async ()=>{\n        await (parcelRequire(\"lvdPr\"));\n    }\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\nparcelRequire(\"6PbjS\");\nparcelRequire(\"cqGna\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $bk2f9 = parcelRequire(\"bk2f9\");\n\"use strict\";\nlet $6aefe7eac43bec6d$var$_isWebGLSupported;\nfunction $6aefe7eac43bec6d$export$83dc396b76015322(failIfMajorPerformanceCaveat) {\n    if ($6aefe7eac43bec6d$var$_isWebGLSupported !== void 0) return $6aefe7eac43bec6d$var$_isWebGLSupported;\n    $6aefe7eac43bec6d$var$_isWebGLSupported = (()=>{\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? (0, $bk2f9.AbstractRenderer).defaultOptions.failIfMajorPerformanceCaveat\n        };\n        try {\n            if (!(0, $d0V4H.DOMAdapter).get().getWebGLRenderingContext()) return false;\n            const canvas = (0, $d0V4H.DOMAdapter).get().createCanvas();\n            let gl = canvas.getContext(\"webgl\", contextOptions);\n            const success = !!gl?.getContextAttributes()?.stencil;\n            if (gl) {\n                const loseContext = gl.getExtension(\"WEBGL_lose_context\");\n                if (loseContext) loseContext.loseContext();\n            }\n            gl = null;\n            return success;\n        } catch (_e) {\n            return false;\n        }\n    })();\n    return $6aefe7eac43bec6d$var$_isWebGLSupported;\n}\n\n\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\"use strict\";\nlet $2fd62251d0455c2b$var$_isWebGPUSupported;\nasync function $2fd62251d0455c2b$export$216169f30082c873(options = {}) {\n    if ($2fd62251d0455c2b$var$_isWebGPUSupported !== void 0) return $2fd62251d0455c2b$var$_isWebGPUSupported;\n    $2fd62251d0455c2b$var$_isWebGPUSupported = await (async ()=>{\n        const gpu = (0, $d0V4H.DOMAdapter).get().getNavigator().gpu;\n        if (!gpu) return false;\n        try {\n            const adapter = await gpu.requestAdapter(options);\n            await adapter.requestDevice();\n            return true;\n        } catch (_e) {\n            return false;\n        }\n    })();\n    return $2fd62251d0455c2b$var$_isWebGPUSupported;\n}\n\n\n\nvar $bk2f9 = parcelRequire(\"bk2f9\");\n\"use strict\";\nconst $07d6276735060a75$var$renderPriority = [\n    \"webgl\",\n    \"webgpu\",\n    \"canvas\"\n];\n\n\nasync function $07d6276735060a75$export$3583b92ab8150eb6(options) {\n    let preferredOrder = [];\n    if (options.preference) {\n        preferredOrder.push(options.preference);\n        $07d6276735060a75$var$renderPriority.forEach((item)=>{\n            if (item !== options.preference) preferredOrder.push(item);\n        });\n    } else preferredOrder = $07d6276735060a75$var$renderPriority.slice();\n    let RendererClass;\n    let finalOptions = {};\n    for(let i = 0; i < preferredOrder.length; i++){\n        const rendererType = preferredOrder[i];\n        if (rendererType === \"webgpu\" && await (0, $2fd62251d0455c2b$export$216169f30082c873)()) {\n            const { WebGPURenderer: WebGPURenderer } = await (parcelRequire(\"6BhUg\"));\n            RendererClass = WebGPURenderer;\n            finalOptions = {\n                ...options,\n                ...options.webgpu\n            };\n            break;\n        } else if (rendererType === \"webgl\" && (0, $6aefe7eac43bec6d$export$83dc396b76015322)(options.failIfMajorPerformanceCaveat ?? (0, $bk2f9.AbstractRenderer).defaultOptions.failIfMajorPerformanceCaveat)) {\n            const { WebGLRenderer: WebGLRenderer } = await (parcelRequire(\"8qkEh\"));\n            RendererClass = WebGLRenderer;\n            finalOptions = {\n                ...options,\n                ...options.webgl\n            };\n            break;\n        } else if (rendererType === \"canvas\") {\n            finalOptions = {\n                ...options\n            };\n            throw new Error(\"CanvasRenderer is not yet implemented\");\n        }\n    }\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n    if (!RendererClass) throw new Error(\"No available renderer for the current environment\");\n    const renderer = new RendererClass();\n    await renderer.init(finalOptions);\n    return renderer;\n}\n\n\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\n\nvar $d6zIN = parcelRequire(\"d6zIN\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\"use strict\";\nconst $70be694526cfb04e$var$_Application = class _Application {\n    /** @ignore */ constructor(...args){\n        /** The root display container that's rendered. */ this.stage = new (0, $gRXu9.Container)();\n        if (args[0] !== void 0) (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Application constructor options are deprecated, please use Application.init() instead.\");\n    }\n    /**\n   * @param options - The optional application and renderer parameters.\n   */ async init(options) {\n        options = {\n            ...options\n        };\n        this.renderer = await (0, $07d6276735060a75$export$3583b92ab8150eb6)(options);\n        _Application._plugins.forEach((plugin)=>{\n            plugin.init.call(this, options);\n        });\n    }\n    /** Render the current stage. */ render() {\n        this.renderer.render({\n            container: this.stage\n        });\n    }\n    /**\n   * Reference to the renderer's canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */ get canvas() {\n        return this.renderer.canvas;\n    }\n    /**\n   * Reference to the renderer's canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */ get view() {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), \"Application.view is deprecated, please use Application.canvas instead.\");\n        return this.renderer.canvas;\n    }\n    /**\n   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */ get screen() {\n        return this.renderer.screen;\n    }\n    /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */ destroy(rendererDestroyOptions = false, options = false) {\n        const plugins = _Application._plugins.slice(0);\n        plugins.reverse();\n        plugins.forEach((plugin)=>{\n            plugin.destroy.call(this);\n        });\n        this.stage.destroy(options);\n        this.stage = null;\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */ $70be694526cfb04e$var$_Application._plugins = [];\nlet $70be694526cfb04e$export$16975c34e60e1e61 = $70be694526cfb04e$var$_Application;\n(0, $kFA6i.extensions).handleByList((0, $kFA6i.ExtensionType).Application, $70be694526cfb04e$export$16975c34e60e1e61._plugins);\n(0, $kFA6i.extensions).add((0, $d6zIN.ApplicationInitHook));\n\n\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $4Gouu = parcelRequire(\"4Gouu\");\n\nvar $abXd6 = parcelRequire(\"abXd6\");\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $gOHW1 = parcelRequire(\"gOHW1\");\n\nvar $ec4lc = parcelRequire(\"ec4lc\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $4vQUT = parcelRequire(\"4vQUT\");\n\nvar $lQbVo = parcelRequire(\"lQbVo\");\n\"use strict\";\nclass $608bb1638a6e0695$export$17957a09927cadc7 extends (0, $4vQUT.AbstractBitmapFont) {\n    constructor(options, url){\n        super();\n        const { textures: textures, data: data } = options;\n        Object.keys(data.pages).forEach((key)=>{\n            const pageData = data.pages[parseInt(key, 10)];\n            const texture = textures[pageData.id];\n            this.pages.push({\n                texture: texture\n            });\n        });\n        Object.keys(data.chars).forEach((key)=>{\n            const charData = data.chars[key];\n            const { frame: textureFrame, source: textureSource } = textures[charData.page];\n            const frameReal = new (0, $ec4lc.Rectangle)(charData.x + textureFrame.x, charData.y + textureFrame.y, charData.width, charData.height);\n            const texture = new (0, $4YnyE.Texture)({\n                source: textureSource,\n                frame: frameReal\n            });\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture: texture\n            };\n        });\n        this.baseRenderedFontSize = data.fontSize;\n        this.baseMeasurementFontSize = data.fontSize;\n        this.fontMetrics = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize\n        };\n        this.baseLineOffset = data.baseLineOffset;\n        this.lineHeight = data.lineHeight;\n        this.fontFamily = data.fontFamily;\n        this.distanceField = data.distanceField ?? {\n            type: \"none\",\n            range: 0\n        };\n        this.url = url;\n    }\n    /** Destroys the BitmapFont object. */ destroy() {\n        super.destroy();\n        for(let i = 0; i < this.pages.length; i++){\n            const { texture: texture } = this.pages[i];\n            texture.destroy(true);\n        }\n        this.pages = null;\n    }\n    /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from 'pixi.js';\n   *\n   * BitmapFont.install('TitleFont', {\n   *     fontFamily: 'Arial',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: 'purple',\n   * });\n   *\n   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n   */ static install(options) {\n        (0, $lQbVo.BitmapFontManager).install(options);\n    }\n    /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */ static uninstall(name) {\n        (0, $lQbVo.BitmapFontManager).uninstall(name);\n    }\n}\n\n\n\"use strict\";\nconst $cc969505651ddcf2$export$4c1815a0944ccac0 = {\n    test (data) {\n        return typeof data === \"string\" && data.startsWith(\"info face=\");\n    },\n    parse (txt) {\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: []\n        };\n        for(const i in items){\n            const name = items[i].match(/^[a-z]+/gm)[0];\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n            const itemData = {};\n            for(const i2 in attributeList){\n                const split = attributeList[i2].split(\"=\");\n                const key = split[0];\n                const strValue = split[1].replace(/\"/gm, \"\");\n                const floatValue = parseFloat(strValue);\n                const value = isNaN(floatValue) ? strValue : floatValue;\n                itemData[key] = value;\n            }\n            rawData[name].push(itemData);\n        }\n        const font = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: \"\",\n            distanceField: null,\n            baseLineOffset: 0\n        };\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n        if (distanceField) font.distanceField = {\n            range: parseInt(distanceField.distanceRange, 10),\n            type: distanceField.fieldType\n        };\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n        const page = rawData.page;\n        for(let i = 0; i < page.length; i++)font.pages.push({\n            id: parseInt(page[i].id, 10) || 0,\n            file: page[i].file\n        });\n        const map = {};\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n        const char = rawData.char;\n        for(let i = 0; i < char.length; i++){\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n            if (letter === \"space\") letter = \" \";\n            map[id] = letter;\n            font.chars[letter] = {\n                id: id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {}\n            };\n        }\n        const kerning = rawData.kerning || [];\n        for(let i = 0; i < kerning.length; i++){\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n        return font;\n    }\n};\n\n\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\"use strict\";\nconst $63c6e7573b16fe40$export$7a7adbcafc5cf8e3 = {\n    test (data) {\n        const xml = data;\n        return typeof xml !== \"string\" && \"getElementsByTagName\" in xml && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n    },\n    parse (xml) {\n        const data = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: \"\",\n            distanceField: null,\n            baseLineOffset: 0\n        };\n        const info = xml.getElementsByTagName(\"info\")[0];\n        const common = xml.getElementsByTagName(\"common\")[0];\n        const distanceField = xml.getElementsByTagName(\"distanceField\")[0];\n        if (distanceField) data.distanceField = {\n            type: distanceField.getAttribute(\"fieldType\"),\n            range: parseInt(distanceField.getAttribute(\"distanceRange\"), 10)\n        };\n        const page = xml.getElementsByTagName(\"page\");\n        const char = xml.getElementsByTagName(\"char\");\n        const kerning = xml.getElementsByTagName(\"kerning\");\n        data.fontSize = parseInt(info.getAttribute(\"size\"), 10);\n        data.fontFamily = info.getAttribute(\"face\");\n        data.lineHeight = parseInt(common.getAttribute(\"lineHeight\"), 10);\n        for(let i = 0; i < page.length; i++)data.pages.push({\n            id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n            file: page[i].getAttribute(\"file\")\n        });\n        const map = {};\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute(\"base\"), 10);\n        for(let i = 0; i < char.length; i++){\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute(\"id\"), 10);\n            let letter = charNode.getAttribute(\"letter\") ?? charNode.getAttribute(\"char\") ?? String.fromCharCode(id);\n            if (letter === \"space\") letter = \" \";\n            map[id] = letter;\n            data.chars[letter] = {\n                id: id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute(\"page\"), 10) || 0,\n                x: parseInt(charNode.getAttribute(\"x\"), 10),\n                y: parseInt(charNode.getAttribute(\"y\"), 10),\n                width: parseInt(charNode.getAttribute(\"width\"), 10),\n                height: parseInt(charNode.getAttribute(\"height\"), 10),\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute(\"xoffset\"), 10),\n                yOffset: parseInt(charNode.getAttribute(\"yoffset\"), 10),\n                // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute(\"xadvance\"), 10),\n                kerning: {}\n            };\n        }\n        for(let i = 0; i < kerning.length; i++){\n            const first = parseInt(kerning[i].getAttribute(\"first\"), 10);\n            const second = parseInt(kerning[i].getAttribute(\"second\"), 10);\n            const amount = parseInt(kerning[i].getAttribute(\"amount\"), 10);\n            data.chars[map[second]].kerning[map[first]] = amount;\n        }\n        return data;\n    }\n};\n\n\n\"use strict\";\nconst $d01f5a28b28b471d$export$bfc0a19e2e2cc16 = {\n    test (data) {\n        if (typeof data === \"string\" && data.includes(\"<font>\")) return (0, $63c6e7573b16fe40$export$7a7adbcafc5cf8e3).test((0, $d0V4H.DOMAdapter).get().parseXML(data));\n        return false;\n    },\n    parse (data) {\n        return (0, $63c6e7573b16fe40$export$7a7adbcafc5cf8e3).parse((0, $d0V4H.DOMAdapter).get().parseXML(data));\n    }\n};\n\n\n\"use strict\";\nconst $3a63b46ae10c80ec$var$validExtensions = [\n    \".xml\",\n    \".fnt\"\n];\nconst $3a63b46ae10c80ec$export$778a313228f06f6c = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).CacheParser,\n        name: \"cacheBitmapFont\"\n    },\n    test: (asset)=>asset instanceof (0, $608bb1638a6e0695$export$17957a09927cadc7),\n    getCacheableAssets (keys, asset) {\n        const out = {};\n        keys.forEach((key)=>{\n            out[key] = asset;\n            out[`${key}-bitmap`] = asset;\n        });\n        out[`${asset.fontFamily}-bitmap`] = asset;\n        return out;\n    }\n};\nconst $3a63b46ae10c80ec$export$402edee29ac8bed4 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).LoadParser,\n        priority: (0, $4Gouu.LoaderParserPriority).Normal\n    },\n    name: \"loadBitmapFont\",\n    test (url) {\n        return $3a63b46ae10c80ec$var$validExtensions.includes((0, $gOHW1.path).extname(url).toLowerCase());\n    },\n    async testParse (data) {\n        return (0, $cc969505651ddcf2$export$4c1815a0944ccac0).test(data) || (0, $d01f5a28b28b471d$export$bfc0a19e2e2cc16).test(data);\n    },\n    async parse (asset, data, loader) {\n        const bitmapFontData = (0, $cc969505651ddcf2$export$4c1815a0944ccac0).test(asset) ? (0, $cc969505651ddcf2$export$4c1815a0944ccac0).parse(asset) : (0, $d01f5a28b28b471d$export$bfc0a19e2e2cc16).parse(asset);\n        const { src: src } = data;\n        const { pages: pages } = bitmapFontData;\n        const textureUrls = [];\n        const textureOptions = bitmapFontData.distanceField ? {\n            scaleMode: \"linear\",\n            alphaMode: \"premultiply-alpha-on-upload\",\n            autoGenerateMipmaps: false,\n            resolution: 1\n        } : {};\n        for(let i = 0; i < pages.length; ++i){\n            const pageFile = pages[i].file;\n            let imagePath = (0, $gOHW1.path).join((0, $gOHW1.path).dirname(src), pageFile);\n            imagePath = (0, $abXd6.copySearchParams)(imagePath, src);\n            textureUrls.push({\n                src: imagePath,\n                data: textureOptions\n            });\n        }\n        const loadedTextures = await loader.load(textureUrls);\n        const textures = textureUrls.map((url)=>loadedTextures[url.src]);\n        const bitmapFont = new (0, $608bb1638a6e0695$export$17957a09927cadc7)({\n            data: bitmapFontData,\n            textures: textures\n        }, src);\n        return bitmapFont;\n    },\n    async load (url, _options) {\n        const response = await (0, $d0V4H.DOMAdapter).get().fetch(url);\n        return await response.text();\n    },\n    async unload (bitmapFont, _resolvedAsset, loader) {\n        await Promise.all(bitmapFont.pages.map((page)=>loader.unload(page.texture.source._sourceOrigin)));\n        bitmapFont.destroy();\n    }\n};\n\n\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\"use strict\";\nclass $ad1b17b1723c6966$export$1949379a83b843d5 {\n    /**\n   * @param loader\n   * @param verbose - should the loader log to the console\n   */ constructor(loader, verbose = false){\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n    /**\n   * Adds an array of assets to load.\n   * @param assetUrls - assets to load\n   */ add(assetUrls) {\n        assetUrls.forEach((a)=>{\n            this._assetList.push(a);\n        });\n        if (this.verbose) console.log(\"[BackgroundLoader] assets: \", this._assetList);\n        if (this._isActive && !this._isLoading) this._next();\n    }\n    /**\n   * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n   *\n   * The max assets it will try to load at one time will be 4.\n   */ async _next() {\n        if (this._assetList.length && this._isActive) {\n            this._isLoading = true;\n            const toLoad = [];\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n            for(let i = 0; i < toLoadAmount; i++)toLoad.push(this._assetList.pop());\n            await this._loader.load(toLoad);\n            this._isLoading = false;\n            this._next();\n        }\n    }\n    /**\n   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n   * @returns whether the class is active\n   */ get active() {\n        return this._isActive;\n    }\n    set active(value) {\n        if (this._isActive === value) return;\n        this._isActive = value;\n        if (value && !this._isLoading) this._next();\n    }\n}\n\n\n\nvar $6n8as = parcelRequire(\"6n8as\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\"use strict\";\nconst $bf4d6dd69eb87956$export$407b4625a915919d = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).CacheParser,\n        name: \"cacheTextureArray\"\n    },\n    test: (asset)=>Array.isArray(asset) && asset.every((t)=>t instanceof (0, $4YnyE.Texture)),\n    getCacheableAssets: (keys, asset)=>{\n        const out = {};\n        keys.forEach((key)=>{\n            asset.forEach((item, i)=>{\n                out[key + (i === 0 ? \"\" : i + 1)] = item;\n            });\n        });\n        return out;\n    }\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nasync function $7230094aaee53210$export$7c459e568e7cea2c(imageData) {\n    if (\"Image\" in globalThis) return new Promise((resolve)=>{\n        const image = new Image();\n        image.onload = ()=>{\n            resolve(true);\n        };\n        image.onerror = ()=>{\n            resolve(false);\n        };\n        image.src = imageData;\n    });\n    if (\"createImageBitmap\" in globalThis && \"fetch\" in globalThis) {\n        try {\n            const blob = await (await fetch(imageData)).blob();\n            await createImageBitmap(blob);\n        } catch (_e) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n\n\n\"use strict\";\nconst $e4069250bf4ed59b$export$a60d2d4a3c570783 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).DetectionParser,\n        priority: 1\n    },\n    test: async ()=>(0, $7230094aaee53210$export$7c459e568e7cea2c)(// eslint-disable-next-line max-len\n        \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=\"),\n    add: async (formats)=>[\n            ...formats,\n            \"avif\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"avif\")\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nconst $4703260a04e3ad03$var$imageFormats = [\n    \"png\",\n    \"jpg\",\n    \"jpeg\"\n];\nconst $4703260a04e3ad03$export$b106d7c2de3b4d89 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).DetectionParser,\n        priority: -1\n    },\n    test: ()=>Promise.resolve(true),\n    add: async (formats)=>[\n            ...formats,\n            ...$4703260a04e3ad03$var$imageFormats\n        ],\n    remove: async (formats)=>formats.filter((f)=>!$4703260a04e3ad03$var$imageFormats.includes(f))\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nconst $af36fa8e7d058b2d$var$inWorker = \"WorkerGlobalScope\" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;\nfunction $af36fa8e7d058b2d$export$7a571c147b03abb1(mimeType) {\n    if ($af36fa8e7d058b2d$var$inWorker) return false;\n    const video = document.createElement(\"video\");\n    return video.canPlayType(mimeType) !== \"\";\n}\n\n\n\"use strict\";\nconst $e23ff61575e7ef80$export$7726d83fee274e25 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).DetectionParser,\n        priority: 0\n    },\n    test: async ()=>(0, $af36fa8e7d058b2d$export$7a571c147b03abb1)(\"video/mp4\"),\n    add: async (formats)=>[\n            ...formats,\n            \"mp4\",\n            \"m4v\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"mp4\" && f !== \"m4v\")\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\n\"use strict\";\nconst $90a31412308a1b55$export$5a1da481121f806a = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).DetectionParser,\n        priority: 0\n    },\n    test: async ()=>(0, $af36fa8e7d058b2d$export$7a571c147b03abb1)(\"video/ogg\"),\n    add: async (formats)=>[\n            ...formats,\n            \"ogv\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"ogv\")\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\n\"use strict\";\nconst $8d16b6a6892fe269$export$a041d698a1896657 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).DetectionParser,\n        priority: 0\n    },\n    test: async ()=>(0, $af36fa8e7d058b2d$export$7a571c147b03abb1)(\"video/webm\"),\n    add: async (formats)=>[\n            ...formats,\n            \"webm\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"webm\")\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\n\"use strict\";\nconst $3a1b830066a7e872$export$d19529a9ed9823d4 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).DetectionParser,\n        priority: 0\n    },\n    test: async ()=>(0, $7230094aaee53210$export$7c459e568e7cea2c)(\"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=\"),\n    add: async (formats)=>[\n            ...formats,\n            \"webp\"\n        ],\n    remove: async (formats)=>formats.filter((f)=>f !== \"webp\")\n};\n\n\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $gOHW1 = parcelRequire(\"gOHW1\");\n\nvar $anknw = parcelRequire(\"anknw\");\n\nvar $bBvqO = parcelRequire(\"bBvqO\");\n\"use strict\";\nclass $ff34eee7c47ead35$export$3b0d6d7590275603 {\n    constructor(){\n        this._parsers = [];\n        this._parsersValidated = false;\n        /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */ this.parsers = new Proxy(this._parsers, {\n            set: (target, key, value)=>{\n                this._parsersValidated = false;\n                target[key] = value;\n                return true;\n            }\n        });\n        /** Cache loading promises that ae currently active */ this.promiseCache = {};\n    }\n    /** function used for testing */ reset() {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n    /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */ _getLoadPromiseAndParser(url, data) {\n        const result = {\n            promise: null,\n            parser: null\n        };\n        result.promise = (async ()=>{\n            let asset = null;\n            let parser = null;\n            if (data.loadParser) {\n                parser = this._parserHash[data.loadParser];\n                if (!parser) (0, $c9aw6.warn)(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n            }\n            if (!parser) {\n                for(let i = 0; i < this.parsers.length; i++){\n                    const parserX = this.parsers[i];\n                    if (parserX.load && parserX.test?.(url, data, this)) {\n                        parser = parserX;\n                        break;\n                    }\n                }\n                if (!parser) {\n                    (0, $c9aw6.warn)(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    return null;\n                }\n            }\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n            for(let i = 0; i < this.parsers.length; i++){\n                const parser2 = this.parsers[i];\n                if (parser2.parse) {\n                    if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n                        asset = await parser2.parse(asset, data, this) || asset;\n                        result.parser = parser2;\n                    }\n                }\n            }\n            return asset;\n        })();\n        return result;\n    }\n    async load(assetsToLoadIn, onProgress) {\n        if (!this._parsersValidated) this._validateParsers();\n        let count = 0;\n        const assets = {};\n        const singleAsset = (0, $bBvqO.isSingleItem)(assetsToLoadIn);\n        const assetsToLoad = (0, $anknw.convertToList)(assetsToLoadIn, (item)=>({\n                alias: [\n                    item\n                ],\n                src: item,\n                data: {}\n            }));\n        const total = assetsToLoad.length;\n        const promises = assetsToLoad.map(async (asset)=>{\n            const url = (0, $gOHW1.path).toAbsolute(asset.src);\n            if (!assets[asset.src]) try {\n                if (!this.promiseCache[url]) this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                assets[asset.src] = await this.promiseCache[url].promise;\n                if (onProgress) onProgress(++count / total);\n            } catch (e) {\n                delete this.promiseCache[url];\n                delete assets[asset.src];\n                throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n            }\n        });\n        await Promise.all(promises);\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n    /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load('cool.png');\n   *\n   * await Loader.unload('cool.png');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */ async unload(assetsToUnloadIn) {\n        const assetsToUnload = (0, $anknw.convertToList)(assetsToUnloadIn, (item)=>({\n                alias: [\n                    item\n                ],\n                src: item\n            }));\n        const promises = assetsToUnload.map(async (asset)=>{\n            const url = (0, $gOHW1.path).toAbsolute(asset.src);\n            const loadPromise = this.promiseCache[url];\n            if (loadPromise) {\n                const loadedAsset = await loadPromise.promise;\n                delete this.promiseCache[url];\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n        await Promise.all(promises);\n    }\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */ _validateParsers() {\n        this._parsersValidated = true;\n        this._parserHash = this._parsers.filter((parser)=>parser.name).reduce((hash, parser)=>{\n            if (!parser.name) (0, $c9aw6.warn)(`[Assets] loadParser should have a name`);\n            else if (hash[parser.name]) (0, $c9aw6.warn)(`[Assets] loadParser name conflict \"${parser.name}\"`);\n            return {\n                ...hash,\n                [parser.name]: parser\n            };\n        }, {});\n    }\n}\n\n\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\"use strict\";\nfunction $de3f53883a0bbf0f$export$7ff8b059fb914323(url, mimes) {\n    if (Array.isArray(mimes)) {\n        for (const mime of mimes){\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n        return false;\n    }\n    return url.startsWith(`data:${mimes}`);\n}\n\n\n\nvar $gOHW1 = parcelRequire(\"gOHW1\");\n\"use strict\";\nfunction $3ee4ccd3e32414b6$export$fd0180357b95b812(url, extension) {\n    const tempURL = url.split(\"?\")[0];\n    const ext = (0, $gOHW1.path).extname(tempURL).toLowerCase();\n    if (Array.isArray(extension)) return extension.includes(ext);\n    return ext === extension;\n}\n\n\n\nvar $4Gouu = parcelRequire(\"4Gouu\");\n\"use strict\";\nconst $74c666bcc10ff43e$var$validJSONExtension = \".json\";\nconst $74c666bcc10ff43e$var$validJSONMIME = \"application/json\";\nconst $74c666bcc10ff43e$export$e7c8553478f3aac7 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).LoadParser,\n        priority: (0, $4Gouu.LoaderParserPriority).Low\n    },\n    name: \"loadJson\",\n    test (url) {\n        return (0, $de3f53883a0bbf0f$export$7ff8b059fb914323)(url, $74c666bcc10ff43e$var$validJSONMIME) || (0, $3ee4ccd3e32414b6$export$fd0180357b95b812)(url, $74c666bcc10ff43e$var$validJSONExtension);\n    },\n    async load (url) {\n        const response = await (0, $d0V4H.DOMAdapter).get().fetch(url);\n        const json = await response.json();\n        return json;\n    }\n};\n\n\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\n\n\nvar $4Gouu = parcelRequire(\"4Gouu\");\n\"use strict\";\nconst $87210ffa948e76ea$var$validTXTExtension = \".txt\";\nconst $87210ffa948e76ea$var$validTXTMIME = \"text/plain\";\nconst $87210ffa948e76ea$export$3835b7ee6dbebde8 = {\n    name: \"loadTxt\",\n    extension: {\n        type: (0, $kFA6i.ExtensionType).LoadParser,\n        priority: (0, $4Gouu.LoaderParserPriority).Low,\n        name: \"loadTxt\"\n    },\n    test (url) {\n        return (0, $de3f53883a0bbf0f$export$7ff8b059fb914323)(url, $87210ffa948e76ea$var$validTXTMIME) || (0, $3ee4ccd3e32414b6$export$fd0180357b95b812)(url, $87210ffa948e76ea$var$validTXTExtension);\n    },\n    async load (url) {\n        const response = await (0, $d0V4H.DOMAdapter).get().fetch(url);\n        const txt = await response.text();\n        return txt;\n    }\n};\n\n\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $gOHW1 = parcelRequire(\"gOHW1\");\n\nvar $6n8as = parcelRequire(\"6n8as\");\n\n\n\nvar $4Gouu = parcelRequire(\"4Gouu\");\n\"use strict\";\nconst $99a8f3f35449bcfa$var$validWeights = [\n    \"normal\",\n    \"bold\",\n    \"100\",\n    \"200\",\n    \"300\",\n    \"400\",\n    \"500\",\n    \"600\",\n    \"700\",\n    \"800\",\n    \"900\"\n];\nconst $99a8f3f35449bcfa$var$validFontExtensions = [\n    \".ttf\",\n    \".otf\",\n    \".woff\",\n    \".woff2\"\n];\nconst $99a8f3f35449bcfa$var$validFontMIMEs = [\n    \"font/ttf\",\n    \"font/otf\",\n    \"font/woff\",\n    \"font/woff2\"\n];\nconst $99a8f3f35449bcfa$var$CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction $99a8f3f35449bcfa$export$c461ca8f39d93d9b(url) {\n    const ext = (0, $gOHW1.path).extname(url);\n    const name = (0, $gOHW1.path).basename(url, ext);\n    const nameWithSpaces = name.replace(/(-|_)/g, \" \");\n    const nameTokens = nameWithSpaces.toLowerCase().split(\" \").map((word)=>word.charAt(0).toUpperCase() + word.slice(1));\n    let valid = nameTokens.length > 0;\n    for (const token of nameTokens)if (!token.match($99a8f3f35449bcfa$var$CSS_IDENT_TOKEN_REGEX)) {\n        valid = false;\n        break;\n    }\n    let fontFamilyName = nameTokens.join(\" \");\n    if (!valid) fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, \"\\\\$&\")}\"`;\n    return fontFamilyName;\n}\nconst $99a8f3f35449bcfa$var$validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\nfunction $99a8f3f35449bcfa$var$encodeURIWhenNeeded(uri) {\n    if ($99a8f3f35449bcfa$var$validURICharactersRegex.test(uri)) return uri;\n    return encodeURI(uri);\n}\nconst $99a8f3f35449bcfa$export$129ed93ad26b0298 = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).LoadParser,\n        priority: (0, $4Gouu.LoaderParserPriority).Low\n    },\n    name: \"loadWebFont\",\n    test (url) {\n        return (0, $de3f53883a0bbf0f$export$7ff8b059fb914323)(url, $99a8f3f35449bcfa$var$validFontMIMEs) || (0, $3ee4ccd3e32414b6$export$fd0180357b95b812)(url, $99a8f3f35449bcfa$var$validFontExtensions);\n    },\n    async load (url, options) {\n        const fonts = (0, $d0V4H.DOMAdapter).get().getFontFaceSet();\n        if (fonts) {\n            const fontFaces = [];\n            const name = options.data?.family ?? $99a8f3f35449bcfa$export$c461ca8f39d93d9b(url);\n            const weights = options.data?.weights?.filter((weight)=>$99a8f3f35449bcfa$var$validWeights.includes(weight)) ?? [\n                \"normal\"\n            ];\n            const data = options.data ?? {};\n            for(let i = 0; i < weights.length; i++){\n                const weight = weights[i];\n                const font = new FontFace(name, `url(${$99a8f3f35449bcfa$var$encodeURIWhenNeeded(url)})`, {\n                    ...data,\n                    weight: weight\n                });\n                await font.load();\n                fonts.add(font);\n                fontFaces.push(font);\n            }\n            (0, $6n8as.Cache).set(`${name}-and-url`, {\n                url: url,\n                fontFaces: fontFaces\n            });\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n        (0, $c9aw6.warn)(\"[loadWebFont] FontFace API is not supported. Skipping loading font\");\n        return null;\n    },\n    unload (font) {\n        (Array.isArray(font) ? font : [\n            font\n        ]).forEach((t)=>{\n            (0, $6n8as.Cache).remove(`${t.family}-and-url`);\n            (0, $d0V4H.DOMAdapter).get().getFontFaceSet().delete(t);\n        });\n    }\n};\n\n\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $hRHFw = parcelRequire(\"hRHFw\");\n\nvar $lfe2w = parcelRequire(\"lfe2w\");\n\nvar $em7uH = parcelRequire(\"em7uH\");\n\"use strict\";\nfunction $2db229c57d4198d2$export$8695ab2f322d2637(url, defaultValue = 1) {\n    const resolution = (0, $em7uH.Resolver).RETINA_PREFIX?.exec(url);\n    if (resolution) return parseFloat(resolution[1]);\n    return defaultValue;\n}\n\n\n\n\n\nvar $4Gouu = parcelRequire(\"4Gouu\");\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\nvar $c9aw6 = parcelRequire(\"c9aw6\");\n\nvar $6n8as = parcelRequire(\"6n8as\");\n\"use strict\";\nfunction $131715eb1eeb8d1a$export$37b981a8c575f415(source, loader, url) {\n    source.label = url;\n    source._sourceOrigin = url;\n    const texture = new (0, $4YnyE.Texture)({\n        source: source,\n        label: url\n    });\n    const unload = ()=>{\n        delete loader.promiseCache[url];\n        if ((0, $6n8as.Cache).has(url)) (0, $6n8as.Cache).remove(url);\n    };\n    texture.source.once(\"destroy\", ()=>{\n        if (loader.promiseCache[url]) {\n            (0, $c9aw6.warn)(\"[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.\");\n            unload();\n        }\n    });\n    texture.once(\"destroy\", ()=>{\n        if (!source.destroyed) {\n            (0, $c9aw6.warn)(\"[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.\");\n            unload();\n        }\n    });\n    return texture;\n}\n\n\n\"use strict\";\nconst $5122d03721d5b815$var$validSVGExtension = \".svg\";\nconst $5122d03721d5b815$var$validSVGMIME = \"image/svg+xml\";\nconst $5122d03721d5b815$export$b6a2e78b63791dfa = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).LoadParser,\n        priority: (0, $4Gouu.LoaderParserPriority).Low,\n        name: \"loadSVG\"\n    },\n    name: \"loadSVG\",\n    config: {\n        crossOrigin: \"anonymous\",\n        parseAsGraphicsContext: false\n    },\n    test (url) {\n        return (0, $de3f53883a0bbf0f$export$7ff8b059fb914323)(url, $5122d03721d5b815$var$validSVGMIME) || (0, $3ee4ccd3e32414b6$export$fd0180357b95b812)(url, $5122d03721d5b815$var$validSVGExtension);\n    },\n    async load (url, asset, loader) {\n        if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) return $5122d03721d5b815$var$loadAsGraphics(url);\n        return $5122d03721d5b815$var$loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n    unload (asset) {\n        asset.destroy(true);\n    }\n};\nasync function $5122d03721d5b815$var$loadAsTexture(url, asset, loader, crossOrigin) {\n    const response = await (0, $d0V4H.DOMAdapter).get().fetch(url);\n    const blob = await response.blob();\n    const blobUrl = URL.createObjectURL(blob);\n    const image = new Image();\n    image.src = blobUrl;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n    URL.revokeObjectURL(blobUrl);\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    const resolution = asset.data?.resolution || (0, $2db229c57d4198d2$export$8695ab2f322d2637)(url);\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n    canvas.width = width * resolution;\n    canvas.height = height * resolution;\n    context.drawImage(image, 0, 0, width * resolution, height * resolution);\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};\n    const base = new (0, $hRHFw.ImageSource)({\n        resource: canvas,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        resolution: resolution,\n        ...rest\n    });\n    return (0, $131715eb1eeb8d1a$export$37b981a8c575f415)(base, loader, url);\n}\nasync function $5122d03721d5b815$var$loadAsGraphics(url) {\n    const response = await (0, $d0V4H.DOMAdapter).get().fetch(url);\n    const svgSource = await response.text();\n    const context = new (0, $lfe2w.GraphicsContext)();\n    context.svg(svgSource);\n    return context;\n}\n\n\n\nvar $d0V4H = parcelRequire(\"d0V4H\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $hRHFw = parcelRequire(\"hRHFw\");\n\n\n\nconst $65f3f1a8dbdc7d8d$var$WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const WHITE_PNG = \\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\\"function\\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (_e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n\";\nlet $65f3f1a8dbdc7d8d$var$WORKER_URL = null;\nclass $65f3f1a8dbdc7d8d$export$2e2bcd8739ae039 {\n    constructor(){\n        if (!$65f3f1a8dbdc7d8d$var$WORKER_URL) $65f3f1a8dbdc7d8d$var$WORKER_URL = URL.createObjectURL(new Blob([\n            $65f3f1a8dbdc7d8d$var$WORKER_CODE\n        ], {\n            type: 'application/javascript'\n        }));\n        this.worker = new Worker($65f3f1a8dbdc7d8d$var$WORKER_URL);\n    }\n}\n$65f3f1a8dbdc7d8d$export$2e2bcd8739ae039.revokeObjectURL = function revokeObjectURL() {\n    if ($65f3f1a8dbdc7d8d$var$WORKER_URL) {\n        URL.revokeObjectURL($65f3f1a8dbdc7d8d$var$WORKER_URL);\n        $65f3f1a8dbdc7d8d$var$WORKER_URL = null;\n    }\n};\n\n\nconst $4bbe6d132e00c6a2$var$WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    async function loadImageBitmap(url, alphaMode) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      return alphaMode === \\\"premultiplied-alpha\\\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \\\"none\\\" }) : createImageBitmap(imageBlob);\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n\";\nlet $4bbe6d132e00c6a2$var$WORKER_URL = null;\nclass $4bbe6d132e00c6a2$export$2e2bcd8739ae039 {\n    constructor(){\n        if (!$4bbe6d132e00c6a2$var$WORKER_URL) $4bbe6d132e00c6a2$var$WORKER_URL = URL.createObjectURL(new Blob([\n            $4bbe6d132e00c6a2$var$WORKER_CODE\n        ], {\n            type: 'application/javascript'\n        }));\n        this.worker = new Worker($4bbe6d132e00c6a2$var$WORKER_URL);\n    }\n}\n$4bbe6d132e00c6a2$export$2e2bcd8739ae039.revokeObjectURL = function revokeObjectURL() {\n    if ($4bbe6d132e00c6a2$var$WORKER_URL) {\n        URL.revokeObjectURL($4bbe6d132e00c6a2$var$WORKER_URL);\n        $4bbe6d132e00c6a2$var$WORKER_URL = null;\n    }\n};\n\n\n\"use strict\";\nlet $87b21a3c09db871d$var$UUID = 0;\nlet $87b21a3c09db871d$var$MAX_WORKERS;\nclass $87b21a3c09db871d$var$WorkerManagerClass {\n    constructor(){\n        this._initialized = false;\n        this._createdWorkers = 0;\n        this._workerPool = [];\n        this._queue = [];\n        this._resolveHash = {};\n    }\n    isImageBitmapSupported() {\n        if (this._isImageBitmapSupported !== void 0) return this._isImageBitmapSupported;\n        this._isImageBitmapSupported = new Promise((resolve)=>{\n            const { worker: worker } = new (0, $65f3f1a8dbdc7d8d$export$2e2bcd8739ae039)();\n            worker.addEventListener(\"message\", (event)=>{\n                worker.terminate();\n                (0, $65f3f1a8dbdc7d8d$export$2e2bcd8739ae039).revokeObjectURL();\n                resolve(event.data);\n            });\n        });\n        return this._isImageBitmapSupported;\n    }\n    loadImageBitmap(src, asset) {\n        return this._run(\"loadImageBitmap\", [\n            src,\n            asset?.data?.alphaMode\n        ]);\n    }\n    async _initWorkers() {\n        if (this._initialized) return;\n        this._initialized = true;\n    }\n    _getWorker() {\n        if ($87b21a3c09db871d$var$MAX_WORKERS === void 0) $87b21a3c09db871d$var$MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        let worker = this._workerPool.pop();\n        if (!worker && this._createdWorkers < $87b21a3c09db871d$var$MAX_WORKERS) {\n            this._createdWorkers++;\n            worker = new (0, $4bbe6d132e00c6a2$export$2e2bcd8739ae039)().worker;\n            worker.addEventListener(\"message\", (event)=>{\n                this._complete(event.data);\n                this._returnWorker(event.target);\n                this._next();\n            });\n        }\n        return worker;\n    }\n    _returnWorker(worker) {\n        this._workerPool.push(worker);\n    }\n    _complete(data) {\n        if (data.error !== void 0) this._resolveHash[data.uuid].reject(data.error);\n        else this._resolveHash[data.uuid].resolve(data.data);\n        this._resolveHash[data.uuid] = null;\n    }\n    async _run(id, args) {\n        await this._initWorkers();\n        const promise = new Promise((resolve, reject)=>{\n            this._queue.push({\n                id: id,\n                arguments: args,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n        this._next();\n        return promise;\n    }\n    _next() {\n        if (!this._queue.length) return;\n        const worker = this._getWorker();\n        if (!worker) return;\n        const toDo = this._queue.pop();\n        const id = toDo.id;\n        this._resolveHash[$87b21a3c09db871d$var$UUID] = {\n            resolve: toDo.resolve,\n            reject: toDo.reject\n        };\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: $87b21a3c09db871d$var$UUID++,\n            id: id\n        });\n    }\n}\nconst $87b21a3c09db871d$export$bcff6015853c67ce = new $87b21a3c09db871d$var$WorkerManagerClass();\n\n\n\nvar $4Gouu = parcelRequire(\"4Gouu\");\n\n\"use strict\";\nconst $659928910a21979a$var$validImageExtensions = [\n    \".jpeg\",\n    \".jpg\",\n    \".png\",\n    \".webp\",\n    \".avif\"\n];\nconst $659928910a21979a$var$validImageMIMEs = [\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/webp\",\n    \"image/avif\"\n];\nasync function $659928910a21979a$export$c614e6247302006d(url, asset) {\n    const response = await (0, $d0V4H.DOMAdapter).get().fetch(url);\n    if (!response.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n    const imageBlob = await response.blob();\n    return asset?.data?.alphaMode === \"premultiplied-alpha\" ? createImageBitmap(imageBlob, {\n        premultiplyAlpha: \"none\"\n    }) : createImageBitmap(imageBlob);\n}\nconst $659928910a21979a$export$897b113ee8307cd0 = {\n    name: \"loadTextures\",\n    extension: {\n        type: (0, $kFA6i.ExtensionType).LoadParser,\n        priority: (0, $4Gouu.LoaderParserPriority).High,\n        name: \"loadTextures\"\n    },\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: \"anonymous\"\n    },\n    test (url) {\n        return (0, $de3f53883a0bbf0f$export$7ff8b059fb914323)(url, $659928910a21979a$var$validImageMIMEs) || (0, $3ee4ccd3e32414b6$export$fd0180357b95b812)(url, $659928910a21979a$var$validImageExtensions);\n    },\n    async load (url, asset, loader) {\n        let src = null;\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n            if (this.config.preferWorkers && await (0, $87b21a3c09db871d$export$bcff6015853c67ce).isImageBitmapSupported()) src = await (0, $87b21a3c09db871d$export$bcff6015853c67ce).loadImageBitmap(url, asset);\n            else src = await $659928910a21979a$export$c614e6247302006d(url, asset);\n        } else src = await new Promise((resolve, reject)=>{\n            src = new Image();\n            src.crossOrigin = this.config.crossOrigin;\n            src.src = url;\n            if (src.complete) resolve(src);\n            else {\n                src.onload = ()=>{\n                    resolve(src);\n                };\n                src.onerror = reject;\n            }\n        });\n        const base = new (0, $hRHFw.ImageSource)({\n            resource: src,\n            alphaMode: \"premultiply-alpha-on-upload\",\n            resolution: asset.data?.resolution || (0, $2db229c57d4198d2$export$8695ab2f322d2637)(url),\n            ...asset.data\n        });\n        return (0, $131715eb1eeb8d1a$export$37b981a8c575f415)(base, loader, url);\n    },\n    unload (texture) {\n        texture.destroy(true);\n    }\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $9QDRe = parcelRequire(\"9QDRe\");\n\nvar $jQhdF = parcelRequire(\"jQhdF\");\n\n\n\n\n\"use strict\";\nconst $cfb1b656613615e1$var$validVideoExtensions = [\n    \".mp4\",\n    \".m4v\",\n    \".webm\",\n    \".ogg\",\n    \".ogv\",\n    \".h264\",\n    \".avi\",\n    \".mov\"\n];\nconst $cfb1b656613615e1$var$validVideoMIMEs = $cfb1b656613615e1$var$validVideoExtensions.map((ext)=>`video/${ext.substring(1)}`);\nfunction $cfb1b656613615e1$export$c47cb7c63271266e(element, url, crossorigin) {\n    if (crossorigin === void 0 && !url.startsWith(\"data:\")) element.crossOrigin = $cfb1b656613615e1$export$292083da55c5b406(url);\n    else if (crossorigin !== false) element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n}\nfunction $cfb1b656613615e1$export$856bfbe81968ff62(element) {\n    return new Promise((resolve, reject)=>{\n        element.addEventListener(\"canplaythrough\", loaded);\n        element.addEventListener(\"error\", error);\n        element.load();\n        function loaded() {\n            cleanup();\n            resolve();\n        }\n        function error(err) {\n            cleanup();\n            reject(err);\n        }\n        function cleanup() {\n            element.removeEventListener(\"canplaythrough\", loaded);\n            element.removeEventListener(\"error\", error);\n        }\n    });\n}\nfunction $cfb1b656613615e1$export$292083da55c5b406(url, loc = globalThis.location) {\n    if (url.startsWith(\"data:\")) return \"\";\n    loc || (loc = globalThis.location);\n    const parsedUrl = new URL(url, document.baseURI);\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) return \"anonymous\";\n    return \"\";\n}\nconst $cfb1b656613615e1$export$68fa0976ba667d63 = {\n    name: \"loadVideo\",\n    extension: {\n        type: (0, $kFA6i.ExtensionType).LoadParser,\n        name: \"loadVideo\"\n    },\n    test (url) {\n        const isValidDataUrl = (0, $de3f53883a0bbf0f$export$7ff8b059fb914323)(url, $cfb1b656613615e1$var$validVideoMIMEs);\n        const isValidExtension = (0, $3ee4ccd3e32414b6$export$fd0180357b95b812)(url, $cfb1b656613615e1$var$validVideoExtensions);\n        return isValidDataUrl || isValidExtension;\n    },\n    async load (url, asset, loader) {\n        const options = {\n            ...(0, $9QDRe.VideoSource).defaultOptions,\n            resolution: asset.data?.resolution || (0, $2db229c57d4198d2$export$8695ab2f322d2637)(url),\n            alphaMode: asset.data?.alphaMode || await (0, $jQhdF.detectVideoAlphaMode)(),\n            ...asset.data\n        };\n        const videoElement = document.createElement(\"video\");\n        const attributeMap = {\n            preload: options.autoLoad !== false ? \"auto\" : void 0,\n            \"webkit-playsinline\": options.playsinline !== false ? \"\" : void 0,\n            playsinline: options.playsinline !== false ? \"\" : void 0,\n            muted: options.muted === true ? \"\" : void 0,\n            loop: options.loop === true ? \"\" : void 0,\n            autoplay: options.autoPlay !== false ? \"\" : void 0\n        };\n        Object.keys(attributeMap).forEach((key)=>{\n            const value = attributeMap[key];\n            if (value !== void 0) videoElement.setAttribute(key, value);\n        });\n        if (options.muted === true) videoElement.muted = true;\n        $cfb1b656613615e1$export$c47cb7c63271266e(videoElement, url, options.crossorigin);\n        const sourceElement = document.createElement(\"source\");\n        let mime;\n        if (url.startsWith(\"data:\")) mime = url.slice(5, url.indexOf(\";\"));\n        else if (!url.startsWith(\"blob:\")) {\n            const ext = url.split(\"?\")[0].slice(url.lastIndexOf(\".\") + 1).toLowerCase();\n            mime = (0, $9QDRe.VideoSource).MIME_TYPES[ext] || `video/${ext}`;\n        }\n        sourceElement.src = url;\n        if (mime) sourceElement.type = mime;\n        return new Promise((resolve)=>{\n            const onCanPlay = async ()=>{\n                const base = new (0, $9QDRe.VideoSource)({\n                    ...options,\n                    resource: videoElement\n                });\n                videoElement.removeEventListener(\"canplay\", onCanPlay);\n                if (asset.data.preload) await $cfb1b656613615e1$export$856bfbe81968ff62(videoElement);\n                resolve((0, $131715eb1eeb8d1a$export$37b981a8c575f415)(base, loader, url));\n            };\n            videoElement.addEventListener(\"canplay\", onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n    unload (texture) {\n        texture.destroy(true);\n    }\n};\n\n\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\nvar $em7uH = parcelRequire(\"em7uH\");\n\nvar $kFA6i = parcelRequire(\"kFA6i\");\n\n\nvar $em7uH = parcelRequire(\"em7uH\");\n\"use strict\";\nconst $919dd6816e91d631$export$cc356fa83de02bea = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).ResolveParser,\n        name: \"resolveTexture\"\n    },\n    test: (0, $659928910a21979a$export$897b113ee8307cd0).test,\n    parse: (value)=>({\n            resolution: parseFloat((0, $em7uH.Resolver).RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n            format: value.split(\".\").pop(),\n            src: value\n        })\n};\n\n\n\"use strict\";\nconst $b994a900f223e232$export$2b5cca0b89cb089c = {\n    extension: {\n        type: (0, $kFA6i.ExtensionType).ResolveParser,\n        priority: -2,\n        name: \"resolveJson\"\n    },\n    test: (value)=>(0, $em7uH.Resolver).RETINA_PREFIX.test(value) && value.endsWith(\".json\"),\n    parse: (0, $919dd6816e91d631$export$cc356fa83de02bea).parse\n};\n\n\n\n\nvar $em7uH = parcelRequire(\"em7uH\");\n\nvar $anknw = parcelRequire(\"anknw\");\n\nvar $bBvqO = parcelRequire(\"bBvqO\");\n\"use strict\";\nclass $237b9dbd6c58e9b4$export$137d4dd907afac85 {\n    constructor(){\n        this._detections = [];\n        this._initialized = false;\n        this.resolver = new (0, $em7uH.Resolver)();\n        this.loader = new (0, $ff34eee7c47ead35$export$3b0d6d7590275603)();\n        this.cache = (0, $6n8as.Cache);\n        this._backgroundLoader = new (0, $ad1b17b1723c6966$export$1949379a83b843d5)(this.loader);\n        this._backgroundLoader.active = true;\n        this.reset();\n    }\n    /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */ async init(options = {}) {\n        if (this._initialized) {\n            (0, $c9aw6.warn)(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n            return;\n        }\n        this._initialized = true;\n        if (options.defaultSearchParams) this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        if (options.basePath) this.resolver.basePath = options.basePath;\n        if (options.bundleIdentifier) this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        if (options.manifest) {\n            let manifest = options.manifest;\n            if (typeof manifest === \"string\") manifest = await this.load(manifest);\n            this.resolver.addManifest(manifest);\n        }\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = typeof resolutionPref === \"number\" ? [\n            resolutionPref\n        ] : resolutionPref;\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution: resolution\n            }\n        });\n        if (options.preferences) this.setPreferences(options.preferences);\n    }\n    /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Simple\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n   * const bunny = await Assets.load('bunnyBooBoo');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n   *\n   * const bunny = await Assets.load('burger');\n   * const bunny2 = await Assets.load('chicken');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny.{png,webp}',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});\n   *\n   * Assets.add({\n   *     alias: 'bunnyBooBoo',\n   *     src: [\n   *         'bunny.png',\n   *         'bunny.webp',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */ add(assets) {\n        this.resolver.add(assets);\n    }\n    async load(urls, onProgress) {\n        if (!this._initialized) await this.init();\n        const singleAsset = (0, $bBvqO.isSingleItem)(urls);\n        const urlArray = (0, $anknw.convertToList)(urls).map((url)=>{\n            if (typeof url !== \"string\") {\n                const aliases = this.resolver.getAlias(url);\n                if (aliases.some((alias)=>!this.resolver.hasKey(alias))) this.add(url);\n                return Array.isArray(aliases) ? aliases[0] : aliases;\n            }\n            if (!this.resolver.hasKey(url)) this.add({\n                alias: url,\n                src: url\n            });\n            return url;\n        });\n        const resolveResults = this.resolver.resolve(urlArray);\n        const out = await this._mapLoadToResolve(resolveResults, onProgress);\n        return singleAsset ? out[urlArray[0]] : out;\n    }\n    /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */ addBundle(bundleId, assets) {\n        this.resolver.addBundle(bundleId, assets);\n    }\n    /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */ async loadBundle(bundleIds, onProgress) {\n        if (!this._initialized) await this.init();\n        let singleAsset = false;\n        if (typeof bundleIds === \"string\") {\n            singleAsset = true;\n            bundleIds = [\n                bundleIds\n            ];\n        }\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n        const out = {};\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = ()=>{\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId)=>{\n            const resolveResult = resolveResults[bundleId];\n            total += Object.keys(resolveResult).length;\n            return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2)=>{\n                out[bundleId] = resolveResult2;\n            });\n        });\n        await Promise.all(promises);\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n    /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your initial load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */ async backgroundLoad(urls) {\n        if (!this._initialized) await this.init();\n        if (typeof urls === \"string\") urls = [\n            urls\n        ];\n        const resolveResults = this.resolver.resolve(urls);\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n    /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */ async backgroundLoadBundle(bundleIds) {\n        if (!this._initialized) await this.init();\n        if (typeof bundleIds === \"string\") bundleIds = [\n            bundleIds\n        ];\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n        Object.values(resolveResults).forEach((resolveResult)=>{\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n    /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */ reset() {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n        this._initialized = false;\n    }\n    get(keys) {\n        if (typeof keys === \"string\") return (0, $6n8as.Cache).get(keys);\n        const assets = {};\n        for(let i = 0; i < keys.length; i++)assets[i] = (0, $6n8as.Cache).get(keys[i]);\n        return assets;\n    }\n    /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */ async _mapLoadToResolve(resolveResults, onProgress) {\n        const resolveArray = [\n            ...new Set(Object.values(resolveResults))\n        ];\n        this._backgroundLoader.active = false;\n        const loadedAssets = await this.loader.load(resolveArray, onProgress);\n        this._backgroundLoader.active = true;\n        const out = {};\n        resolveArray.forEach((resolveResult)=>{\n            const asset = loadedAssets[resolveResult.src];\n            const keys = [\n                resolveResult.src\n            ];\n            if (resolveResult.alias) keys.push(...resolveResult.alias);\n            keys.forEach((key)=>{\n                out[key] = asset;\n            });\n            (0, $6n8as.Cache).set(keys, asset);\n        });\n        return out;\n    }\n    /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */ async unload(urls) {\n        if (!this._initialized) await this.init();\n        const urlArray = (0, $anknw.convertToList)(urls).map((url)=>typeof url !== \"string\" ? url.src : url);\n        const resolveResults = this.resolver.resolve(urlArray);\n        await this._unloadFromResolved(resolveResults);\n    }\n    /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */ async unloadBundle(bundleIds) {\n        if (!this._initialized) await this.init();\n        bundleIds = (0, $anknw.convertToList)(bundleIds);\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n        const promises = Object.keys(resolveResults).map((bundleId)=>this._unloadFromResolved(resolveResults[bundleId]));\n        await Promise.all(promises);\n    }\n    async _unloadFromResolved(resolveResult) {\n        const resolveArray = Object.values(resolveResult);\n        resolveArray.forEach((resolveResult2)=>{\n            (0, $6n8as.Cache).remove(resolveResult2.src);\n        });\n        await this.loader.unload(resolveArray);\n    }\n    /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */ async _detectFormats(options) {\n        let formats = [];\n        if (options.preferredFormats) formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [\n            options.preferredFormats\n        ];\n        for (const detection of options.detections){\n            if (options.skipDetections || await detection.test()) formats = await detection.add(formats);\n            else if (!options.skipDetections) formats = await detection.remove(formats);\n        }\n        formats = formats.filter((format, index)=>formats.indexOf(format) === index);\n        return formats;\n    }\n    /** All the detection parsers currently added to the Assets class. */ get detections() {\n        return this._detections;\n    }\n    /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */ setPreferences(preferences) {\n        this.loader.parsers.forEach((parser)=>{\n            if (!parser.config) return;\n            Object.keys(parser.config).filter((key)=>key in preferences).forEach((key)=>{\n                parser.config[key] = preferences[key];\n            });\n        });\n    }\n}\nconst $237b9dbd6c58e9b4$export$c8eca95e306f7116 = new $237b9dbd6c58e9b4$export$137d4dd907afac85();\n(0, $kFA6i.extensions).handleByList((0, $kFA6i.ExtensionType).LoadParser, $237b9dbd6c58e9b4$export$c8eca95e306f7116.loader.parsers).handleByList((0, $kFA6i.ExtensionType).ResolveParser, $237b9dbd6c58e9b4$export$c8eca95e306f7116.resolver.parsers).handleByList((0, $kFA6i.ExtensionType).CacheParser, $237b9dbd6c58e9b4$export$c8eca95e306f7116.cache.parsers).handleByList((0, $kFA6i.ExtensionType).DetectionParser, $237b9dbd6c58e9b4$export$c8eca95e306f7116.detections);\n(0, $kFA6i.extensions).add((0, $bf4d6dd69eb87956$export$407b4625a915919d), (0, $4703260a04e3ad03$export$b106d7c2de3b4d89), (0, $e4069250bf4ed59b$export$a60d2d4a3c570783), (0, $3a1b830066a7e872$export$d19529a9ed9823d4), (0, $e23ff61575e7ef80$export$7726d83fee274e25), (0, $90a31412308a1b55$export$5a1da481121f806a), (0, $8d16b6a6892fe269$export$a041d698a1896657), (0, $74c666bcc10ff43e$export$e7c8553478f3aac7), (0, $87210ffa948e76ea$export$3835b7ee6dbebde8), (0, $99a8f3f35449bcfa$export$129ed93ad26b0298), (0, $5122d03721d5b815$export$b6a2e78b63791dfa), (0, $659928910a21979a$export$897b113ee8307cd0), (0, $cfb1b656613615e1$export$68fa0976ba667d63), (0, $3a63b46ae10c80ec$export$402edee29ac8bed4), (0, $3a63b46ae10c80ec$export$778a313228f06f6c), (0, $919dd6816e91d631$export$cc356fa83de02bea), (0, $b994a900f223e232$export$2b5cca0b89cb089c));\nconst $237b9dbd6c58e9b4$var$assetKeyMap = {\n    loader: (0, $kFA6i.ExtensionType).LoadParser,\n    resolver: (0, $kFA6i.ExtensionType).ResolveParser,\n    cache: (0, $kFA6i.ExtensionType).CacheParser,\n    detection: (0, $kFA6i.ExtensionType).DetectionParser\n};\n(0, $kFA6i.extensions).handle((0, $kFA6i.ExtensionType).Asset, (extension)=>{\n    const ref = extension.ref;\n    Object.entries($237b9dbd6c58e9b4$var$assetKeyMap).filter(([key])=>!!ref[key]).forEach(([key, type])=>(0, $kFA6i.extensions).add(Object.assign(ref[key], // Allow the function to optionally define it's own\n        // ExtensionMetadata, the use cases here is priority for LoaderParsers\n        {\n            extension: ref[key].extension ?? type\n        })));\n}, (extension)=>{\n    const ref = extension.ref;\n    Object.keys($237b9dbd6c58e9b4$var$assetKeyMap).filter((key)=>!!ref[key]).forEach((key)=>(0, $kFA6i.extensions).remove(ref[key]));\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\n\n\n\n\n\n\n\n\n\nvar $9ErZc = parcelRequire(\"9ErZc\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $3binI = parcelRequire(\"3binI\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $6NgLT = parcelRequire(\"6NgLT\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $dq7e0 = parcelRequire(\"dq7e0\");\n\nvar $aCdt0 = parcelRequire(\"aCdt0\");\n\nvar $4ndcs = parcelRequire(\"4ndcs\");\n\"use strict\";\nclass $d1bbd571f88f6097$export$daf74670712de91 extends (0, $4ndcs.ViewContainer) {\n    constructor(options, styleClass){\n        const { text: text, resolution: resolution, style: style, anchor: anchor, width: width, height: height, roundPixels: roundPixels, ...rest } = options;\n        super({\n            ...rest\n        });\n        this.batched = true;\n        this._resolution = null;\n        this._autoResolution = true;\n        this._didTextUpdate = true;\n        this._styleClass = styleClass;\n        this.text = text ?? \"\";\n        this.style = style;\n        this.resolution = resolution ?? null;\n        this.allowChildren = false;\n        this._anchor = new (0, $dq7e0.ObservablePoint)({\n            _onUpdate: ()=>{\n                this.onViewUpdate();\n            }\n        });\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n        if (width !== void 0) this.width = width;\n        if (height !== void 0) this.height = height;\n    }\n    /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from 'pixi.js';\n   *\n   * const text = new Text('hello world');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */ get anchor() {\n        return this._anchor;\n    }\n    set anchor(value) {\n        typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n    /** Set the copy for the text object. To split a line you can use '\\n'. */ set text(value) {\n        value = value.toString();\n        if (this._text === value) return;\n        this._text = value;\n        this.onViewUpdate();\n    }\n    get text() {\n        return this._text;\n    }\n    /**\n   * The resolution / device pixel ratio of the canvas.\n   * @default 1\n   */ set resolution(value) {\n        this._autoResolution = value === null;\n        this._resolution = value;\n        this.onViewUpdate();\n    }\n    get resolution() {\n        return this._resolution;\n    }\n    get style() {\n        return this._style;\n    }\n    /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */ set style(style) {\n        style || (style = {});\n        this._style?.off(\"update\", this.onViewUpdate, this);\n        if (style instanceof this._styleClass) this._style = style;\n        else this._style = new this._styleClass(style);\n        this._style.on(\"update\", this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */ get width() {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n    set width(value) {\n        this._setWidth(value, this.bounds.width);\n    }\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */ get height() {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n    set height(value) {\n        this._setHeight(value, this.bounds.height);\n    }\n    /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */ getSize(out) {\n        out || (out = {});\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n        return out;\n    }\n    /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */ setSize(value, height) {\n        if (typeof value === \"object\") {\n            height = value.height ?? value.width;\n            value = value.width;\n        } else height ?? (height = value);\n        value !== void 0 && this._setWidth(value, this.bounds.width);\n        height !== void 0 && this._setHeight(height, this.bounds.height);\n    }\n    /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n        if (point.x >= x1 && point.x <= x1 + width) {\n            y1 = -height * this.anchor.y;\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n        return false;\n    }\n    onViewUpdate() {\n        if (!this.didViewUpdate) this._didTextUpdate = true;\n        super.onViewUpdate();\n    }\n    _getKey() {\n        return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n    }\n    /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */ destroy(options = false) {\n        super.destroy(options);\n        this.owner = null;\n        this._bounds = null;\n        this._anchor = null;\n        if (typeof options === \"boolean\" ? options : options?.style) this._style.destroy(options);\n        this._style = null;\n        this._text = null;\n    }\n}\nfunction $d1bbd571f88f6097$export$1f008a47b72e40d9(args, name) {\n    let options = args[0] ?? {};\n    if (typeof options === \"string\" || args[1]) {\n        (0, $aCdt0.deprecation)((0, $aCdt0.v8_0_0), `use new ${name}({ text: \"hi!\", style }) instead`);\n        options = {\n            text: options,\n            style: args[1]\n        };\n    }\n    return options;\n}\n\n\n\nvar $dzZFt = parcelRequire(\"dzZFt\");\n\nvar $2oqF9 = parcelRequire(\"2oqF9\");\n\"use strict\";\nclass $e18e9fe6681a60c8$export$5f1af8db9871e1d6 extends (0, $d1bbd571f88f6097$export$daf74670712de91) {\n    constructor(...args){\n        const options = (0, $d1bbd571f88f6097$export$1f008a47b72e40d9)(args, \"Text\");\n        super(options, (0, $2oqF9.TextStyle));\n        this.renderPipeId = \"text\";\n    }\n    /** @private */ updateBounds() {\n        const bounds = this._bounds;\n        const anchor = this._anchor;\n        const canvasMeasurement = (0, $dzZFt.CanvasTextMetrics).measureText(this._text, this._style);\n        const { width: width, height: height } = canvasMeasurement;\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n\n\n\nvar $2oqF9 = parcelRequire(\"2oqF9\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $6p5EE = parcelRequire(\"6p5EE\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $fPquT = parcelRequire(\"fPquT\");\n\"use strict\";\n(0, $kFA6i.extensions).add((0, $46e9c21fe5524152$export$a6aad6334ef58a1c), (0, $aac24c264e299d39$export$ee43dd1acddf6cf8));\n\n\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\n\nvar $gRXu9 = parcelRequire(\"gRXu9\");\nvar $6NgLT = parcelRequire(\"6NgLT\");\nvar $4YnyE = parcelRequire(\"4YnyE\");\n\n\nfunction $f3289b285438d34f$export$53a61779c1fcd190(name, connect = false) {\n    return `./${name}${connect ? '_connect' : ''}.png`;\n}\nclass $f3289b285438d34f$export$60667f9de734e56 {\n    async init() {\n        let assetsNames = [];\n        Object.values((0, $72762a06a728e4a1$export$1114c7e4bc5b368c)).forEach((symbolName)=>{\n            assetsNames.push($f3289b285438d34f$export$53a61779c1fcd190(symbolName), $f3289b285438d34f$export$53a61779c1fcd190(symbolName, true));\n        });\n        return await (0, $237b9dbd6c58e9b4$export$c8eca95e306f7116).load(assetsNames);\n    }\n}\n\n\n\nclass $40a1f344e0cf63d9$export$3e25e887b7a5b37b {\n    constructor(_id){\n        this._id = _id;\n        this._mainTexture = new (0, $4YnyE.Texture)();\n        this._winTexture = new (0, $4YnyE.Texture)();\n        this._sprite = new (0, $6NgLT.Sprite)();\n        this._container = new (0, $gRXu9.Container)();\n        this.initTextures();\n    }\n    get container() {\n        return this._container;\n    }\n    get x() {\n        return this._container.x;\n    }\n    get y() {\n        return this._container.y;\n    }\n    set x(x) {\n        this._container.x = x;\n    }\n    set y(y) {\n        this._container.y = y;\n    }\n    setSymbol(symbolId) {\n        this._id = symbolId;\n        this.setTextures();\n    }\n    win() {\n        this._sprite.texture = this._winTexture;\n    }\n    stop() {\n        this._sprite.texture = this._mainTexture;\n    }\n    initTextures() {\n        this.setTextures();\n        this._sprite.anchor = 0.5;\n        this._container.addChild(this._sprite);\n        this._container.scale = 0.5;\n    }\n    setTextures() {\n        const symbolName = (0, $72762a06a728e4a1$export$1114c7e4bc5b368c)[this._id];\n        this._mainTexture = (0, $4YnyE.Texture).from((0, $f3289b285438d34f$export$53a61779c1fcd190)(symbolName));\n        this._winTexture = (0, $4YnyE.Texture).from((0, $f3289b285438d34f$export$53a61779c1fcd190)(symbolName, true));\n        this._sprite.texture = this._mainTexture;\n    }\n}\n\n\nconst $72762a06a728e4a1$export$1114c7e4bc5b368c = {\n    0: '9',\n    1: '10',\n    2: 'J',\n    3: 'Q',\n    4: 'K',\n    5: 'A',\n    6: 'M1',\n    7: 'M2',\n    8: 'M3',\n    9: 'M4',\n    10: 'M5',\n    11: 'H1',\n    12: 'H2',\n    13: 'H3',\n    14: 'H4',\n    15: 'H5'\n};\nclass $72762a06a728e4a1$export$d548f983b9413d19 {\n    constructor(){}\n    createSymbol(symbolId) {\n        return new (0, $40a1f344e0cf63d9$export$3e25e887b7a5b37b)(symbolId);\n    }\n}\n\n\nclass $e2bcf89fe38d2db5$export$daee430848a3913d {\n    constructor(_reelConfig, _pixiApp, _symbolManager){\n        this._reelConfig = _reelConfig;\n        this._pixiApp = _pixiApp;\n        this._symbolManager = _symbolManager;\n        this._reels = [];\n        this._tweening = [];\n    }\n    init() {\n        this.initReels();\n        this.initTicker();\n    }\n    start(endCallback) {\n        for(let i = 0; i < this._reels.length; i++){\n            const reel = this._reels[i];\n            const target = reel.position + 10 + i * 5;\n            const time = 1000 + i * 300;\n            this.tweenTo(reel, reel.position, target, time, $e2bcf89fe38d2db5$var$backout(0.5), i === this._reelConfig.reel - 1 ? ()=>{\n                endCallback();\n            } : null);\n        }\n    }\n    initReels() {\n        // Build the reels\n        const reelsContainer = new (0, $gRXu9.Container)();\n        for(let i = 0; i < this._reelConfig.reel; i++){\n            const reelContainer = new (0, $gRXu9.Container)();\n            reelContainer.x = i * this._reelConfig.reelWidth;\n            reelContainer.y = this._reelConfig.symbolSize;\n            reelsContainer.addChild(reelContainer);\n            const reel = {\n                symbols: [],\n                container: reelContainer,\n                position: 0\n            };\n            // Build the symbols, last row is bumper symbol\n            for(let j = 0; j < this._reelConfig.row + 1; j++){\n                const randomSymbolId = $e2bcf89fe38d2db5$var$getRandomSymbolId();\n                const symbol = this._symbolManager.createSymbol(randomSymbolId);\n                symbol.y = j * this._reelConfig.symbolSize;\n                reelContainer.addChild(symbol.container);\n                reel.symbols.push(symbol);\n            }\n            this._reels.push(reel);\n        }\n        this._pixiApp.stage.addChild(reelsContainer);\n        const marginTop = 200;\n        const reelsWidth = this._reelConfig.reelWidth * this._reelConfig.reel;\n        reelsContainer.y = marginTop - this._reelConfig.symbolSize / 2;\n        reelsContainer.x = this._pixiApp.screen.width / 2 - reelsWidth / 2 + this._reelConfig.symbolSize / 2;\n    }\n    initTicker() {\n        // Listen for animate update.\n        this._pixiApp.ticker.add(()=>{\n            // reel tweener\n            const now = Date.now();\n            const remove = [];\n            for(let i = 0; i < this._tweening.length; i++){\n                const tween = this._tweening[i];\n                const phase = Math.min(1, (now - tween.start) / tween.time);\n                tween.reel.position = $e2bcf89fe38d2db5$var$lerp(tween.value, tween.target, tween.easing(phase));\n                if (phase === 1) {\n                    tween.reel.position = tween.target;\n                    if (tween.complete) tween.complete(tween);\n                    remove.push(tween);\n                }\n            }\n            for(let i = 0; i < remove.length; i++)this._tweening.splice(this._tweening.indexOf(remove[i]), 1);\n            // Update the slots.\n            for(let i = 0; i < this._reels.length; i++){\n                const reel = this._reels[i];\n                // Update symbol positions on reel.\n                for(let j = 0; j < reel.symbols.length; j++){\n                    const symbol = reel.symbols[j];\n                    const prevy = symbol.y;\n                    symbol.y = (reel.position + j) % reel.symbols.length * this._reelConfig.symbolSize - this._reelConfig.symbolSize;\n                    if (symbol.y < 0 && prevy > this._reelConfig.symbolSize) symbol.setSymbol($e2bcf89fe38d2db5$var$getRandomSymbolId());\n                }\n            }\n        });\n    }\n    tweenTo(reel, value, target, time, easing, oncomplete) {\n        const tween = {\n            reel: reel,\n            value: value,\n            target: target,\n            easing: easing,\n            time: time,\n            complete: oncomplete,\n            start: Date.now()\n        };\n        this._tweening.push(tween);\n    }\n}\n// Basic lerp funtion.\nfunction $e2bcf89fe38d2db5$var$lerp(a1, a2, t) {\n    return a1 * (1 - t) + a2 * t;\n}\n// Backout function from tweenjs.\n// https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js\nfunction $e2bcf89fe38d2db5$var$backout(amount) {\n    return (t)=>--t * t * ((amount + 1) * t + amount) + 1;\n}\nfunction $e2bcf89fe38d2db5$var$getRandomSymbolId() {\n    return Math.floor(Math.random() * Object.keys((0, $72762a06a728e4a1$export$1114c7e4bc5b368c)).length);\n}\n\n\n\n\n\nvar $3binI = parcelRequire(\"3binI\");\nvar $2oqF9 = parcelRequire(\"2oqF9\");\nclass $fbd10fc1f281616b$export$2524c4960ed9dff2 {\n    constructor(_pixiApp){\n        this._pixiApp = _pixiApp;\n    }\n    init(spinCallback) {\n        const marginTop = 200;\n        const top = new (0, $3binI.Graphics)().rect(0, 0, this._pixiApp.screen.width, marginTop).fill({\n            color: 0x0\n        });\n        const bottom = new (0, $3binI.Graphics)().rect(0, 0, this._pixiApp.screen.width, marginTop).fill({\n            color: 0x0\n        });\n        bottom.y = 500;\n        this._pixiApp.stage.addChild(top);\n        this._pixiApp.stage.addChild(bottom);\n        const style = new (0, $2oqF9.TextStyle)({\n            fontFamily: 'Arial',\n            fontSize: 36,\n            fontWeight: 'bold',\n            fill: 0xffffff\n        });\n        // Header\n        const headerText = new (0, $e18e9fe6681a60c8$export$5f1af8db9871e1d6)('AvatarUX Test', style);\n        headerText.x = Math.round((top.width - headerText.width) / 2);\n        headerText.y = Math.round((marginTop - headerText.height) / 2);\n        top.addChild(headerText);\n        // Spin Button\n        const playText = new (0, $e18e9fe6681a60c8$export$5f1af8db9871e1d6)('Spin', style);\n        playText.x = Math.round((bottom.width - playText.width) / 2);\n        playText.y = 20;\n        bottom.addChild(playText);\n        bottom.eventMode = 'static';\n        bottom.cursor = 'pointer';\n        bottom.addListener('pointerdown', ()=>{\n            spinCallback();\n        });\n    }\n}\n\n\nclass $546bb75ca3527d11$export$985739bfa5723e08 {\n    constructor(pixiApp, reelConfig){\n        this._isRunning = false;\n        this._resourceManager = new (0, $f3289b285438d34f$export$60667f9de734e56)();\n        this._symbolManager = new (0, $72762a06a728e4a1$export$d548f983b9413d19)();\n        this._reelManager = new (0, $e2bcf89fe38d2db5$export$daee430848a3913d)(reelConfig, pixiApp, this._symbolManager);\n        this._uiManager = new (0, $fbd10fc1f281616b$export$2524c4960ed9dff2)(pixiApp);\n    }\n    async init() {\n        await this._resourceManager.init();\n        this._reelManager.init();\n        // add callback for spin\n        this._uiManager.init(()=>{\n            if (this._isRunning) return;\n            this._isRunning = true;\n            this._reelManager.start(()=>this._isRunning = false);\n        });\n    }\n}\n\n\n(async ()=>{\n    // Create a new application\n    const app = new (0, $70be694526cfb04e$export$16975c34e60e1e61)();\n    // Initialize the application\n    await app.init({\n        background: '#1099bb',\n        resizeTo: document.body\n    });\n    // Append the application canvas to the document body\n    document.body.appendChild(app.canvas);\n    const reelConfig = {\n        reel: 5,\n        row: 3,\n        reelWidth: 100,\n        symbolSize: 100\n    };\n    const game = new (0, $546bb75ca3527d11$export$985739bfa5723e08)(app, reelConfig);\n    await game.init();\n})();\n\n\n//# sourceMappingURL=index.28167d82.js.map\n","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","\"use strict\";\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2[\"Application\"] = \"application\";\n  ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n  ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n  ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n  ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n  ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n  ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n  ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n  ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n  ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n  ExtensionType2[\"Asset\"] = \"asset\";\n  ExtensionType2[\"LoadParser\"] = \"load-parser\";\n  ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n  ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n  ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n  ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n  ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n  ExtensionType2[\"TextureSource\"] = \"texture-source\";\n  ExtensionType2[\"Environment\"] = \"environment\";\n  ExtensionType2[\"ShapeBuilder\"] = \"shape-builder\";\n  ExtensionType2[\"Batcher\"] = \"batcher\";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error(\"Extension class must have an extension object\");\n    }\n    const metadata = typeof ext.extension !== \"object\" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === \"object\") {\n    ext = { ...ext };\n  } else {\n    throw new Error(\"Invalid extension type\");\n  }\n  if (typeof ext.type === \"string\") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  }\n};\n\nexport { ExtensionType, extensions, normalizeExtensionPriority };\n//# sourceMappingURL=Extensions.mjs.map\n","/**\n * `extensions` is a global object that holds all the extensions registered with PixiJS.\n * PixiJS uses a this extensions architecture a lot to make the library more modular and\n * flexible.\n *\n * For example, if you want to add load a new type of asset, you can register a new\n * {@link assets.LoaderParser} with the `extensions` object.\n *\n * ```js\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // create a custom asset loader\n * const customAssetLoader = {\n *    extension: {\n *        type: ExtensionType.LoadParser,\n *        name: 'custom-asset-loader',\n *    },\n *    test(url) {\n *       // check if this new loader should be used...\n *    },\n *    load(url) {\n *        // load the asset...\n *    },\n * };\n *\n * // add the custom asset loader to pixi\n * extensions.add(customAssetLoader);\n * ```\n *\n * This would add the `customAssetLoader` to the list of available loaders that PixiJS can use.\n *\n * There are many different types of extensions, which are listed in {@link extensions.ExtensionType}.\n * @namespace extensions\n */\n\n/**\n * Collection of valid extension types.\n * @memberof extensions\n */\nenum ExtensionType\n{\n    /** extensions that are registered as Application plugins */\n    Application = 'application',\n\n    /** extensions that are registered as WebGL render pipes */\n    WebGLPipes = 'webgl-pipes',\n    /** extensions that are registered as WebGL render pipes adaptors */\n    WebGLPipesAdaptor = 'webgl-pipes-adaptor',\n    /** extensions that are registered as WebGL render systems */\n    WebGLSystem = 'webgl-system',\n\n    /** extensions that are registered as WebGPU render pipes */\n    WebGPUPipes = 'webgpu-pipes',\n    /** extensions that are registered as WebGPU render pipes adaptors */\n    WebGPUPipesAdaptor = 'webgpu-pipes-adaptor',\n    /** extensions that are registered as WebGPU render systems */\n    WebGPUSystem = 'webgpu-system',\n\n    /** extensions that are registered as Canvas render pipes */\n    CanvasSystem = 'canvas-system',\n    /** extensions that are registered as Canvas render pipes adaptors */\n    CanvasPipesAdaptor = 'canvas-pipes-adaptor',\n    /** extensions that are registered as Canvas render systems */\n    CanvasPipes = 'canvas-pipes',\n\n    /** extensions that combine the other Asset extensions */\n    Asset = 'asset',\n    /** extensions that are used to load assets through Assets */\n    LoadParser = 'load-parser',\n    /** extensions that are used to resolve asset urls through Assets */\n    ResolveParser = 'resolve-parser',\n    /** extensions that are used to handle how urls are cached by Assets */\n    CacheParser = 'cache-parser',\n    /** extensions that are used to add/remove available resources from Assets */\n    DetectionParser = 'detection-parser',\n\n    /** extensions that are registered with the MaskEffectManager */\n    MaskEffect = 'mask-effect',\n\n    /** A type of extension for creating a new advanced blend mode */\n    BlendMode = 'blend-mode',\n\n    /** A type of extension that will be used to auto detect a resource type */\n    TextureSource = 'texture-source',\n\n    /** A type of extension that will be used to auto detect an environment */\n    Environment = 'environment',\n\n    /** A type of extension for building and triangulating custom shapes used in graphics. */\n    ShapeBuilder = 'shape-builder',\n\n    /** A type of extension for creating custom batchers used in rendering. */\n    Batcher = 'batcher',\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n * @ignore\n */\ninterface ExtensionMetadataDetails\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, to make them more easily accessible */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n */\ntype ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @memberof extensions\n */\ninterface ExtensionFormat\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n    /** Reference to the plugin object/class */\n    ref: any;\n}\n\n/**\n * Extension format that is used internally for registrations.\n * @memberof extensions\n * @ignore\n */\ninterface StrictExtensionFormat extends ExtensionFormat\n{\n    /** The extension type, always expressed as multiple, even if a single */\n    type: ExtensionType[];\n}\n\ntype ExtensionHandler = (extension: StrictExtensionFormat) => void;\n\n/**\n * Convert input into extension format data.\n * @ignore\n */\nconst normalizeExtension = (ext: ExtensionFormat | any): StrictExtensionFormat =>\n{\n    // Class/Object submission, use extension object\n    if (typeof ext === 'function' || (typeof ext === 'object' && ext.extension))\n    {\n        // #if _DEBUG\n        if (!ext.extension)\n        {\n            throw new Error('Extension class must have an extension object');\n        }\n        // #endif\n        const metadata: ExtensionMetadataDetails = (typeof ext.extension !== 'object')\n            ? { type: ext.extension }\n            : ext.extension;\n\n        ext = { ...metadata, ref: ext };\n    }\n    if (typeof ext === 'object')\n    {\n        ext = { ...ext };\n    }\n    else\n    {\n        throw new Error('Invalid extension type');\n    }\n\n    if (typeof ext.type === 'string')\n    {\n        ext.type = [ext.type];\n    }\n\n    return ext;\n};\n\n/**\n * Get the priority for an extension.\n * @ignore\n * @param ext - Any extension\n * @param defaultPriority - Fallback priority if none is defined.\n * @returns The priority for the extension.\n * @memberof extensions\n */\nexport const normalizeExtensionPriority = (ext: ExtensionFormat | any, defaultPriority: number): number =>\n    normalizeExtension(ext).priority ?? defaultPriority;\n\n/**\n * Global registration of all PixiJS extensions. One-stop-shop for extensibility.\n *\n * Import the `extensions` object and use it to register new functionality via the described methods below.\n * ```js\n * import { extensions } from 'pixi.js';\n *\n * // register a new extension\n * extensions.add(myExtension);\n * ```\n * @property {Function} remove - Remove extensions from PixiJS.\n * @property {Function} add - Register new extensions with PixiJS.\n * @property {Function} handle - Internal method to handle extensions by name.\n * @property {Function} handleByMap - Handle a type, but using a map by `name` property.\n * @property {Function} handleByNamedList - Handle a type, but using a list of extensions with a `name` property.\n * @property {Function} handleByList - Handle a type, but using a list of extensions.\n * @memberof extensions\n */\nconst extensions = {\n\n    /** @ignore */\n    _addHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _removeHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _queue: {} as Partial<Record<ExtensionType, StrictExtensionFormat[]>>,\n\n    /**\n     * Remove extensions from PixiJS.\n     * @param extensions - Extensions to be removed.\n     * @returns {extensions} For chaining.\n     */\n    remove(...extensions: Array<ExtensionFormat | any>)\n    {\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n        });\n\n        return this;\n    },\n\n    /**\n     * Register new extensions with PixiJS.\n     * @param extensions - The spread of extensions to add to PixiJS.\n     * @returns {extensions} For chaining.\n     */\n    add(...extensions: Array<ExtensionFormat | any>)\n    {\n        // Handle any extensions either passed as class w/ data or as data\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) =>\n            {\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n\n                if (!handlers[type])\n                {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                }\n                else\n                {\n                    handlers[type]?.(ext);\n                }\n            });\n        });\n\n        return this;\n    },\n\n    /**\n     * Internal method to handle extensions by name.\n     * @param type - The extension type.\n     * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n     * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n     * @returns {extensions} For chaining.\n     */\n    handle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler)\n    {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n\n        // #if _DEBUG\n        if (addHandlers[type] || removeHandlers[type])\n        {\n            throw new Error(`Extension type ${type} already has a handler`);\n        }\n        // #endif\n\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n\n        // Process the queue\n        const queue = this._queue;\n\n        // Process any plugins that have been registered before the handler\n        if (queue[type])\n        {\n            queue[type]?.forEach((ext) => onAdd(ext));\n            delete queue[type];\n        }\n\n        return this;\n    },\n\n    /**\n     * Handle a type, but using a map by `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The object map of named extensions.\n     * @returns {extensions} For chaining.\n     */\n    handleByMap(type: ExtensionType, map: Record<string, any>)\n    {\n        return this.handle(type,\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    map[extension.name] = extension.ref;\n                }\n            },\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    delete map[extension.name];\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions with a `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The array of named extensions.\n     * @param defaultPriority - Fallback priority if none is defined.\n     * @returns {extensions} For chaining.\n     */\n    handleByNamedList(type: ExtensionType, map: {name: string, value: any}[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index >= 0) return;\n\n                map.push({ name: extension.name, value: extension.ref });\n                map.sort((a, b) =>\n                    normalizeExtensionPriority(b.value, defaultPriority)\n                    - normalizeExtensionPriority(a.value, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index !== -1)\n                {\n                    map.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions.\n     * @param type - Type of extension to handle.\n     * @param list - The list of extensions.\n     * @param defaultPriority - The default priority to use if none is specified.\n     * @returns {extensions} For chaining.\n     */\n    handleByList(type: ExtensionType, list: any[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                if (list.includes(extension.ref))\n                {\n                    return;\n                }\n\n                list.push(extension.ref);\n                list.sort((a, b) =>\n                    normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = list.indexOf(extension.ref);\n\n                if (index !== -1)\n                {\n                    list.splice(index, 1);\n                }\n            }\n        );\n    },\n};\n\nexport {\n    extensions,\n    ExtensionType,\n};\nexport type {\n    StrictExtensionFormat as ExtensionFormat,\n    ExtensionFormat as ExtensionFormatLoose,\n    ExtensionHandler,\n    ExtensionMetadata,\n    ExtensionMetadataDetails\n};\n","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = Promise.all([load(\"d1bSR\"), load(\"5nC1g\")]).then(() => parcelRequire('4zK10'));","\"use strict\";\n\nfunction load(id) {\n  // eslint-disable-next-line no-undef\n  return __parcel__import__(require('../bundle-manifest').resolve(id));\n}\nmodule.exports = load;","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = Promise.all([load(\"d1bSR\"), load(\"8rxSw\")]).then(() => parcelRequire('i6XA8'));","import { extensions } from '../extensions/Extensions.mjs';\nimport { AlphaMask } from './mask/alpha/AlphaMask.mjs';\nimport { ColorMask } from './mask/color/ColorMask.mjs';\nimport { StencilMask } from './mask/stencil/StencilMask.mjs';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource.mjs';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource.mjs';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource.mjs';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource.mjs';\nimport './renderers/shared/texture/utils/textureFrom.mjs';\nimport './mask/MaskEffectManager.mjs';\n\n\"use strict\";\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\n/**\n * The rendering namespace contains all the classes used for core rendering in PixiJS\n * this includes all the lower level resources such as Textures, Shaders, State, Buffers,\n * Geometry and the systems required to use them. This covers WebGL and WebGPU and their shared classes.\n *\n * To automatically create a renderer based on available resources, see the {@link rendering.autoDetectRenderer} function.\n * @namespace rendering\n */\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.inverse = false;\n    this.pipe = \"alphaMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    if (!this.inverse) {\n      addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite;\n  }\n}\nAlphaMask.extension = ExtensionType.MaskEffect;\n\nexport { AlphaMask };\n//# sourceMappingURL=AlphaMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public inverse: boolean = false;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        if (!this.inverse)\n        {\n            addMaskBounds(this.mask, bounds, skipUpdateTransform);\n        }\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n","import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { deprecation } from '../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../view/ViewContainer.mjs';\n\n\"use strict\";\nclass Sprite extends ViewContainer {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = Texture.EMPTY) {\n    if (options instanceof Texture) {\n      options = { texture: options };\n    }\n    const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: \"Sprite\",\n      ...rest\n    });\n    this.renderPipeId = \"sprite\";\n    this.batched = true;\n    this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (texture.defaultAnchor) {\n      this.anchor = texture.defaultAnchor;\n    }\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof Texture) {\n      return new Sprite(source);\n    }\n    return new Sprite(Texture.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    if (this._width) {\n      this._setWidth(this._width, this._texture.orig.width);\n    }\n    if (this._height) {\n      this._setHeight(this._height, this._texture.orig.height);\n    }\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */\n  get visualBounds() {\n    updateQuadBounds(this._visualBounds, this._anchor, this._texture);\n    return this._visualBounds;\n  }\n  /**\n   * @deprecated\n   */\n  get sourceBounds() {\n    deprecation(\"8.6.1\", \"Sprite.sourceBounds is deprecated, use visualBounds instead.\");\n    return this.visualBounds;\n  }\n  /** @private */\n  updateBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const bounds = this._bounds;\n    const { width, height } = texture.orig;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._visualBounds = null;\n    this._bounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n    this._width = value;\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n    this._height = value;\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this._texture.orig.width);\n    height !== void 0 && this._setHeight(height, this._texture.orig.height);\n  }\n}\n\nexport { Sprite };\n//# sourceMappingURL=Sprite.mjs.map\n","import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { deprecation } from '../../utils/logging/deprecation';\nimport { ViewContainer } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for the {@link scene.Sprite} constructor.\n * @memberof scene\n */\nexport interface SpriteOptions extends ContainerOptions\n{\n    /** The texture to use for the sprite. */\n    texture?: Texture;\n    /** The anchor point of the sprite. */\n    anchor?: PointData | number;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link assets.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * import { Assets, Sprite } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n * ```\n * @memberof scene\n * @extends scene.Container\n */\nexport class Sprite extends ViewContainer\n{\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image, video, canvas element, video element, texture\n     * @param source - Source to create texture from\n     * @param [skipCache] - Whether to skip the cache or not\n     * @returns The newly created sprite\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    public override readonly renderPipeId: string = 'sprite';\n\n    public batched = true;\n    public readonly _anchor: ObservablePoint;\n\n    // sprite specific..\n    public _texture: Texture;\n\n    private readonly _visualBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor)\n        {\n            this.anchor = anchor;\n        }\n        else if (texture.defaultAnchor)\n        {\n            this.anchor = texture.defaultAnchor;\n        }\n\n        this.texture = texture;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        if (this._width)\n        {\n            this._setWidth(this._width, this._texture.orig.width);\n        }\n\n        if (this._height)\n        {\n            this._setHeight(this._height, this._texture.orig.height);\n        }\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The bounds of the sprite, taking the texture's trim into account.\n     * @type {rendering.Bounds}\n     */\n    get visualBounds()\n    {\n        updateQuadBounds(this._visualBounds, this._anchor, this._texture);\n\n        return this._visualBounds;\n    }\n\n    /**\n     * @deprecated\n     */\n    get sourceBounds()\n    {\n        // #if _DEBUG\n        deprecation('8.6.1', 'Sprite.sourceBounds is deprecated, use visualBounds instead.');\n        // #endif\n\n        return this.visualBounds;\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const bounds = this._bounds;\n\n        const { width, height } = texture.orig;\n\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._visualBounds as null) = null;\n        (this._bounds as null) = null;\n        (this._anchor as null) = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n        this._width = value;\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n        this._height = value;\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Sprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this._texture.orig.width);\n        height !== undefined && this._setHeight(height, this._texture.orig.height);\n    }\n}\n","\"use strict\";\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\nexport { ObservablePoint };\n//# sourceMappingURL=ObservablePoint.mjs.map\n","import type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface ObservablePoint extends PixiMixins.ObservablePoint { }\n\n/**\n * Observer used to listen for observable point changes.\n * @memberof maths\n */\nexport interface Observer<T>\n{\n    /** Callback to call when the point has updated. */\n    _onUpdate: (point?: T) => void;\n}\n\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * An `ObservablePoint` is a point that triggers the `onUpdate` method on an observer when the point's position is changed.\n * @memberof maths\n */\nexport class ObservablePoint implements PointLike\n{\n    /** @ignore */\n    public _x: number;\n    /** @ignore */\n    public _y: number;\n\n    /** This object used to call the `onUpdate` callback when the point changes. */\n    private readonly _observer: Observer<ObservablePoint>;\n\n    /**\n     * Creates a new `ObservablePoint`\n     * @param observer - Observer to pass to listen for change events.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(observer: Observer<ObservablePoint>, x?: number, y?: number)\n    {\n        this._x = x || 0;\n        this._y = y || 0;\n\n        this._observer = observer;\n    }\n\n    /**\n     * Creates a clone of this point.\n     * @param observer - Optional observer to pass to the new observable point.\n     * @returns a copy of this observable point\n     */\n    public clone(observer?: Observer<ObservablePoint>): ObservablePoint\n    {\n        return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=x] - position of the point on the y axis\n     * @returns The observable point instance itself\n     */\n    public set(x = 0, y = x): this\n    {\n        if (this._x !== x || this._y !== y)\n        {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies x and y from the given point (`p`)\n     * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n     * @returns The observable point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        if (this._x !== p.x || this._y !== p.y)\n        {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into that of the given point (`p`)\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this._x, this._y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this._x) && (p.y === this._y);\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n    }\n    // #endif\n\n    /** Position of the observable point on the x axis. */\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n\n    /** Position of the observable point on the y axis. */\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { NOOP } from '../../../../utils/misc/NOOP.mjs';\nimport { BufferImageSource } from './sources/BufferImageSource.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { TextureMatrix } from './TextureMatrix.mjs';\n\n\"use strict\";\nclass Texture extends EventEmitter {\n  /**\n   * @param {rendering.TextureOptions} options - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = uid(\"texture\");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off(\"resize\", this.update, this);\n    }\n    this._source = value;\n    value.on(\"resize\", this.update, this);\n    this.emit(\"update\", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n  }\n  /**\n   * Call this if you have modified the `texture outside` of the constructor.\n   *\n   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n   */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit(\"update\", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    deprecation(v8_0_0, \"Texture.baseTexture is now Texture.source\");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: \"EMPTY\",\n  source: new TextureSource({\n    label: \"EMPTY\"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    label: \"WHITE\"\n  }),\n  label: \"WHITE\"\n});\nTexture.WHITE.destroy = NOOP;\n\nexport { Texture };\n//# sourceMappingURL=Texture.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferImageSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link scene.NineSlicePlane} texture.\n * @memberof rendering\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @memberof rendering\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @memberof rendering\n */\nexport interface TextureOptions<TextureSourceType extends TextureSource = TextureSource>\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSourceType;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n    /**\n     * Set to true if you plan on modifying this texture's frame, UVs, or swapping its source at runtime.\n     * This is false by default as it improves performance. Generally, it's recommended to create new\n     * textures and swap those rather than modifying an existing texture's properties unless you are\n     * working with a dynamic frames.\n     * Not setting this to true when modifying the texture can lead to visual artifacts.\n     *\n     * If this is false and you modify the texture, you can manually update the sprite's texture by calling\n     * `sprite.onViewUpdate()`.\n     */\n    dynamic?: boolean;\n}\n\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load a texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Assets.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to access the texture once loaded\n * const sameAgainTexture = Asset.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Assets.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @memberof rendering\n * @class\n */\nexport class Texture<TextureSourceType extends TextureSource = TextureSource> extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public readonly uid: number = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    public _source: TextureSourceType;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link maths.groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see scene.NineSliceSprite\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    public dynamic = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {rendering.TextureOptions} options - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate,\n        dynamic\n    }: TextureOptions<TextureSourceType> = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = (source?.source ?? new TextureSource()) as TextureSourceType;\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSourceType)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSourceType\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /**\n     * Call this if you have modified the `texture outside` of the constructor.\n     *\n     * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n     */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture<BufferImageSource>;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import { Matrix } from './Matrix.mjs';\n\n\"use strict\";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\nexport { groupD8 };\n//# sourceMappingURL=groupD8.mjs.map\n","// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group\n//\n// This file implements the dihedral group of order 16, also called\n// of degree 8. That's why its called groupD8.\n\nimport { Matrix } from './Matrix';\n\n/*\n * Transform matrix for operation n is:\n * | ux | vx |\n * | uy | vy |\n */\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\n\n/**\n * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n * for the composition of each rotation in the dihederal group D8.\n * @type {number[][]}\n * @private\n */\nconst rotationCayley: number[][] = [];\n\n/**\n * Matrices for each `GD8Symmetry` rotation.\n * @type {Matrix[]}\n * @private\n */\nconst rotationMatrices: Matrix[] = [];\n\n/*\n * Alias for {@code Math.sign}.\n */\nconst signum = Math.sign;\n\n/*\n * Initializes `rotationCayley` and `rotationMatrices`. It is called\n * only once below.\n */\nfunction init(): void\n{\n    for (let i = 0; i < 16; i++)\n    {\n        const row: number[] = [];\n\n        rotationCayley.push(row);\n\n        for (let j = 0; j < 16; j++)\n        {\n            /* Multiplies rotation matrices i and j. */\n            const _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            const _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            const _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            const _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n\n            /* Finds rotation matrix matching the product and pushes it. */\n            for (let k = 0; k < 16; k++)\n            {\n                if (ux[k] === _ux && uy[k] === _uy\n                      && vx[k] === _vx && vy[k] === _vy)\n                {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < 16; i++)\n    {\n        const mat = new Matrix();\n\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        rotationMatrices.push(mat);\n    }\n}\n\ninit();\n\ntype GD8Symmetry = number;\n/**\n * @typedef {number} GD8Symmetry\n * @see groupD8\n */\n\n/**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n *\n * **Origin:**<br>\n *  This is the small part of gameofbombs.com portal system. It works.\n * @see maths.groupD8.E\n * @see maths.groupD8.SE\n * @see maths.groupD8.S\n * @see maths.groupD8.SW\n * @see maths.groupD8.W\n * @see maths.groupD8.NW\n * @see maths.groupD8.N\n * @see maths.groupD8.NE\n * @author Ivan @ivanpopelyshev\n * @namespace maths.groupD8\n */\nexport const groupD8 = {\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 0°       | East      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    E: 0,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 45°↻     | Southeast |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SE: 1,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 90°↻     | South     |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    S: 2,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 135°↻    | Southwest |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SW: 3,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 180°     | West      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    W: 4,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -135°/225°↻ | Northwest    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NW: 5,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -90°/270°↻  | North        |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    N: 6,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -45°/315°↻  | Northeast    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NE: 7,\n\n    /**\n     * Reflection about Y-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_VERTICAL: 8,\n\n    /**\n     * Reflection about the main diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MAIN_DIAGONAL: 10,\n\n    /**\n     * Reflection about X-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_HORIZONTAL: 12,\n\n    /**\n     * Reflection about reverse diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    REVERSE_DIAGONAL: 14,\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the U-axis\n     *    after rotating the axes.\n     */\n    uX: (ind: GD8Symmetry): GD8Symmetry => ux[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the U-axis\n     *    after rotating the axes.\n     */\n    uY: (ind: GD8Symmetry): GD8Symmetry => uy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the V-axis\n     *    after rotating the axes.\n     */\n    vX: (ind: GD8Symmetry): GD8Symmetry => vx[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the V-axis\n     *    after rotating the axes.\n     */\n    vY: (ind: GD8Symmetry): GD8Symmetry => vy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - symmetry whose opposite\n     *   is needed. Only rotations have opposite symmetries while\n     *   reflections don't.\n     * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n     */\n    inv: (rotation: GD8Symmetry): GD8Symmetry =>\n    {\n        if (rotation & 8)// true only if between 8 & 15 (reflections)\n        {\n            return rotation & 15;// or rotation % 16\n        }\n\n        return (-rotation) & 7;// or (8 - rotation) % 8\n    },\n\n    /**\n     * Composes the two D8 operations.\n     *\n     * Taking `^` as reflection:\n     *\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n     *\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation, which\n     *   is the row in the above cayley table.\n     * @param {GD8Symmetry} rotationFirst - First operation, which\n     *   is the column in the above cayley table.\n     * @returns {GD8Symmetry} Composed operation\n     */\n    add: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][rotationFirst]\n    ),\n\n    /**\n     * Reverse of `add`.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation\n     * @param {GD8Symmetry} rotationFirst - First operation\n     * @returns {GD8Symmetry} Result\n     */\n    sub: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][groupD8.inv(rotationFirst)]\n    ),\n\n    /**\n     * Adds 180 degrees to rotation, which is a commutative\n     * operation.\n     * @memberof maths.groupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} Rotated number\n     */\n    rotate180: (rotation: number): number => rotation ^ 4,\n\n    /**\n     * Checks if the rotation angle is vertical, i.e. south\n     * or north. It doesn't work for reflections.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: (rotation: GD8Symmetry): boolean => (rotation & 3) === 2, // rotation % 4 === 2\n\n    /**\n     * Approximates the vector `V(dx,dy)` into one of the\n     * eight directions provided by `groupD8`.\n     * @memberof maths.groupD8\n     * @param {number} dx - X-component of the vector\n     * @param {number} dy - Y-component of the vector\n     * @returns {GD8Symmetry} Approximation of the vector into\n     *  one of the eight symmetries.\n     */\n    byDirection: (dx: number, dy: number): GD8Symmetry =>\n    {\n        if (Math.abs(dx) * 2 <= Math.abs(dy))\n        {\n            if (dy >= 0)\n            {\n                return groupD8.S;\n            }\n\n            return groupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx))\n        {\n            if (dx > 0)\n            {\n                return groupD8.E;\n            }\n\n            return groupD8.W;\n        }\n        else if (dy > 0)\n        {\n            if (dx > 0)\n            {\n                return groupD8.SE;\n            }\n\n            return groupD8.SW;\n        }\n        else if (dx > 0)\n        {\n            return groupD8.NE;\n        }\n\n        return groupD8.NW;\n    },\n\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     * @memberof maths.groupD8\n     * @param {Matrix} matrix - sprite world matrix\n     * @param {GD8Symmetry} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: (matrix: Matrix, rotation: GD8Symmetry, tx = 0, ty = 0): void =>\n    {\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        const mat: Matrix = rotationMatrices[groupD8.inv(rotation)];\n\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n};\n","import { PI_2 } from '../misc/const.mjs';\nimport { Point } from '../point/Point.mjs';\n\n\"use strict\";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new Point();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /** Checks if this matrix is an identity matrix */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */\n  equals(matrix) {\n    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\nexport { Matrix };\n//# sourceMappingURL=Matrix.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { PI_2 } from '../misc/const';\nimport { Point } from '../point/Point';\n\nimport type { PointData } from '../point/PointData';\n\ninterface TransformableObject\n{\n    position: PointData;\n    scale: PointData;\n    pivot: PointData;\n    skew: PointData;\n    rotation: number;\n}\n\n/**\n * A fast matrix for 2D transformations.\n * ```js\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n * ```\n * @memberof maths\n */\nexport class Matrix\n{\n    /** @default 1 */\n    public a: number;\n\n    /** @default 0 */\n    public b: number;\n\n    /** @default 0 */\n    public c: number;\n\n    /** @default 1 */\n    public d: number;\n\n    /** @default 0 */\n    public tx: number;\n\n    /** @default 0 */\n    public ty: number;\n\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    public array: Float32Array | null = null;\n\n    /**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n     *\n     * a = array[0]\n     * b = array[1]\n     * c = array[3]\n     * d = array[4]\n     * tx = array[2]\n     * ty = array[5]\n     * @param array - The array that the matrix will be populated from.\n     */\n    public fromArray(array: number[]): void\n    {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n\n    /**\n     * Sets the matrix properties.\n     * @param a - Matrix component\n     * @param b - Matrix component\n     * @param c - Matrix component\n     * @param d - Matrix component\n     * @param tx - Matrix component\n     * @param ty - Matrix component\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n    }\n\n    /**\n     * Creates an array from the current Matrix object.\n     * @param transpose - Whether we need to transpose the matrix or not\n     * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n     * @returns The newly created array which contains the matrix\n     */\n    public toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.array)\n        {\n            this.array = new Float32Array(9);\n        }\n\n        const array = out || this.array;\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n    }\n\n    /**\n     * Get a new position with the current transformation applied.\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, transformed through this matrix\n     */\n    public apply<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n\n        return newPos;\n    }\n\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, inverse-transformed through this matrix\n     */\n    public applyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n\n        const id = 1 / ((a * d) + (c * -b));\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\n        newPos.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\n\n        return newPos;\n    }\n\n    /**\n     * Translates the matrix on the x and y.\n     * @param x - How much to translate x by\n     * @param y - How much to translate y by\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public translate(x: number, y: number): this\n    {\n        this.tx += x;\n        this.ty += y;\n\n        return this;\n    }\n\n    /**\n     * Applies a scale transformation to the matrix.\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public scale(x: number, y: number): this\n    {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the matrix.\n     * @param angle - The angle in radians.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public rotate(angle: number): this\n    {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n\n        return this;\n    }\n\n    /**\n     * Appends the given Matrix to this Matrix.\n     * @param matrix - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public append(matrix: Matrix): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n\n        return this;\n    }\n\n    /**\n     * Appends two matrix's and sets the result to this matrix. AB = A * B\n     * @param a - The matrix to append.\n     * @param b - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public appendFrom(a: Matrix, b: Matrix): this\n    {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n\n        this.a = (a1 * a2) + (b1 * c2);\n        this.b = (a1 * b2) + (b1 * d2);\n        this.c = (c1 * a2) + (d1 * c2);\n        this.d = (c1 * b2) + (d1 * d2);\n        this.tx = (tx * a2) + (ty * c2) + b.tx;\n        this.ty = (tx * b2) + (ty * d2) + b.ty;\n\n        return this;\n    }\n\n    /**\n     * Sets the matrix based on all the available properties\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number,\n        scaleY: number, rotation: number, skewX: number, skewY: number): this\n    {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n\n        return this;\n    }\n\n    /**\n     * Prepends the given Matrix to this Matrix.\n     * @param matrix - The matrix to prepend\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public prepend(matrix: Matrix): this\n    {\n        const tx1 = this.tx;\n\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n        {\n            const a1 = this.a;\n            const c1 = this.c;\n\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n     * @param transform - The transform to apply the properties to.\n     * @returns The transform with the newly applied properties\n     */\n    public decompose(transform: TransformableObject): TransformableObject\n    {\n        // sort out rotation / skew..\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n\n        const delta = Math.abs(skewX + skewY);\n\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)\n        {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else\n        {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n        // next set position\n        transform.position.x = this.tx + ((pivot.x * a) + (pivot.y * c));\n        transform.position.y = this.ty + ((pivot.x * b) + (pivot.y * d));\n\n        return transform;\n    }\n\n    /**\n     * Inverts this matrix\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public invert(): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = (a1 * d1) - (b1 * c1);\n\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n\n        return this;\n    }\n\n    /** Checks if this matrix is an identity matrix */\n    public isIdentity(): boolean\n    {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n\n    /**\n     * Resets this Matrix to an identity (default) matrix.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public identity(): this\n    {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n\n        return this;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @returns A copy of this matrix. Good for chaining method calls.\n     */\n    public clone(): Matrix\n    {\n        const matrix = new Matrix();\n\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the given matrix to be the same as the ones in this matrix\n     * @param matrix - The matrix to copy to.\n     * @returns The matrix given in parameter with its values updated.\n     */\n    public copyTo(matrix: Matrix): Matrix\n    {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the matrix to be the same as the ones in given matrix\n     * @param matrix - The matrix to copy from.\n     * @returns this\n     */\n    public copyFrom(matrix: Matrix): this\n    {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * check to see if two matrices are the same\n     * @param matrix - The matrix to compare to.\n     */\n    public equals(matrix: Matrix)\n    {\n        return matrix.a === this.a && matrix.b === this.b\n            && matrix.c === this.c && matrix.d === this.d\n            && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    // #endif\n\n    /**\n     * A default (identity) matrix.\n     *\n     * This is a shared object, if you want to modify it consider creating a new `Matrix`\n     * @readonly\n     */\n    static get IDENTITY(): Readonly<Matrix>\n    {\n        return identityMatrix.identity();\n    }\n\n    /**\n     * A static Matrix that can be used to avoid creating new objects.\n     * Will always ensure the matrix is reset to identity when requested.\n     * Use this object for fast but temporary calculations, as it may be mutated later on.\n     * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n     * @readonly\n     */\n    static get shared(): Matrix\n    {\n        return tempMatrix.identity();\n    }\n}\n\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n","\"use strict\";\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\nexport { DEG_TO_RAD, PI_2, RAD_TO_DEG };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Two Pi.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const PI_2 = Math.PI * 2;\n\n/**\n * Conversion factor for converting radians to degrees.\n * @static\n * @member {number} RAD_TO_DEG\n * @memberof maths\n */\nexport const RAD_TO_DEG = 180 / Math.PI;\n\n/**\n * Conversion factor for converting degrees to radians.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const DEG_TO_RAD = Math.PI / 180;\n\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n * @memberof maths\n */\nexport type SHAPE_PRIMITIVE =\n    | 'polygon'\n    | 'rectangle'\n    | 'circle'\n    | 'ellipse'\n    | 'triangle'\n    | 'roundedRectangle';\n\n/**\n * The `maths` folder contains utility classes and functions for mathematical operations used throughout the project.\n * This includes constants such as conversion factors for radians and degrees, as well as shapes such as polygons,\n * rectangles, circles, ellipses, triangles, and rounded rectangles.\n * ```js\n * import { RAD_TO_DEG, Circle } from 'pixi.js';\n *\n * // Convert 180 degrees to radians\n * const radians = 180 * RAD_TO_DEG;\n *\n * // test if a point is inside a circle\n * const isPointInCircle = new Circle(0, 0, 10).contains(0, 0); // true\n * ```\n * @namespace maths\n */\n","\"use strict\";\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /** Position of the point on the x axis */\n    this.x = 0;\n    /** Position of the point on the y axis */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\nexport { Point };\n//# sourceMappingURL=Point.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface Point extends PixiMixins.Point { }\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n * <br/>\n * Many Pixi functions accept the `PointData` type as an alternative to `Point`,\n * which only requires `x` and `y` properties.\n * @class\n * @implements {PointLike}\n * @memberof maths\n */\nexport class Point implements PointLike\n{\n    /** Position of the point on the x axis */\n    public x = 0;\n    /** Position of the point on the y axis */\n    public y = 0;\n\n    /**\n     * Creates a new `Point`\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(x = 0, y = 0)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Creates a clone of this point\n     * @returns A clone of this point\n     */\n    public clone(): Point\n    {\n        return new Point(this.x, this.y);\n    }\n\n    /**\n     * Copies `x` and `y` from the given point into this point\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        this.set(p.x, p.y);\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point (`p`).\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this.x, this.y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this.x) && (p.y === this.y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the `x` axis\n     * @param {number} [y=x] - position of the point on the `y` axis\n     * @returns The point instance itself\n     */\n    public set(x = 0, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    // #endif\n\n    /**\n     * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n     * @readonly\n     */\n    static get shared(): Point\n    {\n        tempPoint.x = 0;\n        tempPoint.y = 0;\n\n        return tempPoint;\n    }\n}\n\nconst tempPoint = new Point();\n","import { Point } from '../point/Point.mjs';\n\n\"use strict\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    this.type = \"rectangle\";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const strokeWidthOuter = strokeWidth * (1 - alignment);\n    const strokeWidthInner = strokeWidth - strokeWidthOuter;\n    const outerLeft = _x - strokeWidthOuter;\n    const outerRight = _x + width + strokeWidthOuter;\n    const outerTop = _y - strokeWidthOuter;\n    const outerBottom = _y + height + strokeWidthOuter;\n    const innerLeft = _x + strokeWidthInner;\n    const innerRight = _x + width - strokeWidthInner;\n    const innerTop = _y + strokeWidthInner;\n    const innerBottom = _y + height - strokeWidthInner;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexport { Rectangle };\n//# sourceMappingURL=Rectangle.mjs.map\n","// import { SHAPES } from '../const';\nimport { Point } from '../point/Point';\n\nimport type { Bounds } from '../../scene/container/bounds/Bounds';\nimport type { Matrix } from '../matrix/Matrix';\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface Rectangle extends PixiMixins.Rectangle { }\n\n/**\n * The `Rectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`.\n *\n * It also provides convenience methods to get and set the position and size of the rectangle such as\n * {@link maths.Rectangle#bottom|bottom}, {@link maths.Rectangle#right|right} and {@link maths.Rectangle#isEmpty|isEmpty}.\n * @memberof maths\n */\nexport class Rectangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'rectangle';\n\n    /**\n     * The X coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rectangle\n     *  @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    constructor(x: string | number = 0, y: string | number = 0, width: string | number = 0, height: string | number = 0)\n    {\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n\n    /** Returns the left edge of the rectangle. */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /** Returns the right edge of the rectangle. */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /** Returns the top edge of the rectangle. */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /** Returns the bottom edge of the rectangle. */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /** Determines whether the Rectangle is empty. */\n    public isEmpty(): boolean\n    {\n        return this.left === this.right || this.top === this.bottom;\n    }\n\n    /** A constant empty rectangle. This is a new object every time the property is accessed */\n    static get EMPTY(): Rectangle\n    {\n        return new Rectangle(0, 0, 0, 0);\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     * @returns a copy of the rectangle\n     */\n    public clone(): Rectangle\n    {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Converts a Bounds object to a Rectangle object.\n     * @param bounds - The bounds to copy and convert to a rectangle.\n     * @returns Returns itself.\n     */\n    public copyFromBounds(bounds: Bounds): this\n    {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n\n        return this;\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: Rectangle): Rectangle\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: Rectangle): Rectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { width, height } = this;\n\n        if (width <= 0 || height <= 0) return false;\n\n        const _x = this.x;\n        const _y = this.y;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const outerLeft = _x - strokeWidthOuter;\n        const outerRight = _x + width + strokeWidthOuter;\n        const outerTop = _y - strokeWidthOuter;\n        const outerBottom = _y + height + strokeWidthOuter;\n\n        const innerLeft = _x + strokeWidthInner;\n        const innerRight = _x + width - strokeWidthInner;\n        const innerTop = _y + strokeWidthInner;\n        const innerBottom = _y + height - strokeWidthInner;\n\n        return (x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom)\n            && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    public intersects(other: Rectangle, transform?: Matrix): boolean\n    {\n        if (!transform)\n        {\n            const x0 = this.x < other.x ? other.x : this.x;\n            const x1 = this.right > other.right ? other.right : this.right;\n\n            if (x1 <= x0)\n            {\n                return false;\n            }\n\n            const y0 = this.y < other.y ? other.y : this.y;\n            const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n            return y1 > y0;\n        }\n\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n\n        if (x1 <= x0 || y1 <= y0)\n        {\n            return false;\n        }\n\n        const lt = tempPoints[0].set(other.left, other.top);\n        const lb = tempPoints[1].set(other.left, other.bottom);\n        const rt = tempPoints[2].set(other.right, other.top);\n        const rb = tempPoints[3].set(other.right, other.bottom);\n\n        if (rt.x <= lt.x || lb.y <= lt.y)\n        {\n            return false;\n        }\n\n        const s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n\n        if (s === 0)\n        {\n            return false;\n        }\n\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1)\n        {\n            return false;\n        }\n\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = (nx * x0) + (ny * y0);\n        const n10 = (nx * x1) + (ny * y0);\n        const n01 = (nx * x0) + (ny * y1);\n        const n11 = (nx * x1) + (ny * y1);\n\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y))\n        {\n            return false;\n        }\n\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = (mx * x0) + (my * y0);\n        const m10 = (mx * x1) + (my * y0);\n        const m01 = (mx * x0) + (my * y1);\n        const m11 = (mx * x1) + (my * y1);\n\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     * @returns Returns itself.\n     */\n    public pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     * @param rectangle - The rectangle to fit.\n     * @returns Returns itself.\n     */\n    public fit(rectangle: Rectangle): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     * @param resolution - resolution\n     * @param eps - precision\n     * @returns Returns itself.\n     */\n    public ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @param rectangle - The rectangle to include.\n     * @returns Returns itself.\n     */\n    public enlarge(rectangle: Rectangle): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n\n    /**\n     * Returns the framing rectangle of the rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n        out.copyFrom(this);\n\n        return out;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n    // #endif\n}\n","\"use strict\";\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = \"default\") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\nexport { resetUids, uid };\n//# sourceMappingURL=uid.mjs.map\n","const uidCache: Record<string, number> = {\n    default: -1,\n};\n\ntype UIDNames =\n    | 'default'\n    | 'resource'\n    | 'texture'\n    | 'textureSource'\n    | 'textureResource'\n    | 'batcher' //\n    | 'graphicsContext' //\n    | 'graphicsView' //\n    | 'graphicsPath' //\n    | 'fillGradient' //\n    | 'fillPattern' //\n    | 'meshView' //\n    | 'renderable' //\n    | 'buffer' //\n    | 'bufferResource' //\n    | 'geometry'\n    | 'instructionSet' //\n    | 'renderTarget' //\n    | 'uniform' //\n    | 'spriteView' //\n    | 'textView' //\n    | 'tilingSpriteView' //\n    | 'shader';\n\n/**\n * Gets the next unique identifier\n * @param name - The name of the identifier.\n * @function uid\n * @returns {number} The next unique identifier to use.\n * @memberof utils\n */\nexport function uid(name: UIDNames = 'default'): number\n{\n    if (uidCache[name] === undefined)\n    {\n        uidCache[name] = -1;\n    }\n\n    return ++uidCache[name];\n}\n\n/** Resets the next unique identifier to 0. This is used for some tests, dont touch or things WILL explode :) */\nexport function resetUids(): void\n{\n    for (const key in uidCache)\n    {\n        delete uidCache[key];\n    }\n}\n","\"use strict\";\nconst warnings = {};\nconst v8_0_0 = \"8.0.0\";\nconst v8_3_4 = \"8.3.4\";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === \"undefined\") {\n    console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        \"%cPixiJS Deprecation Warning: %c%s\",\n        \"color:#614108;background:#fffbe6\",\n        \"font-weight:normal;color:#614108;background:#fffbe6\",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\nexport { deprecation, v8_0_0, v8_3_4 };\n//# sourceMappingURL=deprecation.mjs.map\n","import type { Dict } from '../types';\n\n// A map of warning messages already fired\nconst warnings: Dict<boolean> = {};\n\n/**\n * deprecation name for version 8.0.0\n * @ignore\n */\nexport const v8_0_0 = '8.0.0';\nexport const v8_3_4 = '8.3.4';\n\n/**\n * Helper for warning developers about deprecated features & settings.\n * A stack track for warnings is given; useful for tracking-down where\n * deprecated methods/properties/classes are being used within the code.\n * @memberof utils\n * @ignore\n * @function deprecation\n * @param {string} version - The version where the feature became deprecated\n * @param {string} message - Message should include what is deprecated, where, and the new solution\n * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack\n *        this is mostly to ignore internal deprecation calls.\n */\nexport function deprecation(version: string, message: string, ignoreDepth = 3): void\n{\n    // Ignore duplicate\n    if (warnings[message])\n    {\n        return;\n    }\n\n    /* eslint-disable no-console */\n    let stack = new Error().stack;\n\n    // Handle IE < 10 and Safari < 6\n    if (typeof stack === 'undefined')\n    {\n        console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n    }\n    else\n    {\n        // chop off the stack trace which includes PixiJS internal calls\n        stack = stack.split('\\n').splice(ignoreDepth).join('\\n');\n\n        if (console.groupCollapsed)\n        {\n            console.groupCollapsed(\n                '%cPixiJS Deprecation Warning: %c%s',\n                'color:#614108;background:#fffbe6',\n                'font-weight:normal;color:#614108;background:#fffbe6',\n                `${message}\\nDeprecated since v${version}`\n            );\n            console.warn(stack);\n            console.groupEnd();\n        }\n        else\n        {\n            console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n            console.warn(stack);\n        }\n    }\n    /* eslint-enable no-console */\n\n    warnings[message] = true;\n}\n","\"use strict\";\nconst NOOP = () => {\n};\n\nexport { NOOP };\n//# sourceMappingURL=NOOP.mjs.map\n","export const NOOP = () =>\n{\n    // empty!\n};\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass BufferImageSource extends TextureSource {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = \"rgba32float\";\n      } else if (buffer instanceof Int32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Uint32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Int16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Uint16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Int8Array) {\n        format = \"bgra8unorm\";\n      } else {\n        format = \"bgra8unorm\";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = \"buffer\";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = ExtensionType.TextureSource;\n\nexport { BufferImageSource };\n//# sourceMappingURL=BufferImageSource.mjs.map\n","import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer>\n{\n    width: number;\n    height: number;\n}\n\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'buffer';\n\n    constructor(options: BufferSourceOptions)\n    {\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n\n        if (!format)\n        {\n            if (buffer instanceof Float32Array)\n            {\n                format = 'rgba32float';\n            }\n            else if (buffer instanceof Int32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Uint32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Int16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Uint16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Int8Array)\n            {\n                format = 'bgra8unorm';\n            }\n            else\n            {\n                format = 'bgra8unorm';\n            }\n        }\n\n        super({\n            ...options,\n            resource: buffer,\n            format,\n        });\n    }\n\n    public static test(resource: any): resource is TypedArray | ArrayBuffer\n    {\n        return resource instanceof Int8Array\n        || resource instanceof Uint8Array\n        || resource instanceof Uint8ClampedArray\n        || resource instanceof Int16Array\n        || resource instanceof Uint16Array\n        || resource instanceof Int32Array\n        || resource instanceof Uint32Array\n        || resource instanceof Float32Array;\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2.mjs';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps.mjs';\nimport { uid } from '../../../../../utils/data/uid.mjs';\nimport { TextureStyle } from '../TextureStyle.mjs';\n\n\"use strict\";\nconst _TextureSource = class _TextureSource extends EventEmitter {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = uid(\"textureSource\");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = \"textureSource\";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = \"unknown\";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = \"rgba8unorm\";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = \"2d\";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? \"\";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off(\"change\", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on(\"change\", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit(\"styleChange\", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit(\"update\", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    this.emit(\"unload\", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution || (resolution = this._resolution);\n    width || (width = this.width);\n    height || (height = this.height);\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit(\"resize\", this);\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit(\"updateMipmaps\", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error(\"Unimplemented\");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: \"bgra8unorm\",\n  alphaMode: \"premultiply-alpha-on-upload\",\n  dimensions: \"2d\",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\nexport { TextureSource };\n//# sourceMappingURL=TextureSource.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\nimport type { TextureResourceOrOptions } from '../utils/textureFrom';\n\n/**\n * options for creating a new TextureSource\n * @memberof rendering\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @memberof rendering\n * @typeParam T - The TextureSource's Resource type.\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid: number = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    // dimensions\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no need to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution ||= this._resolution;\n        width ||= this.width;\n        height ||= this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n\n    /**\n     * A helper function that creates a new TextureSource based on the resource you provide.\n     * @param resource - The resource to create the texture source from.\n     */\n    public static from: (resource: TextureResourceOrOptions) => TextureSource;\n}\n","\"use strict\";\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\nexport { isPow2, log2, nextPow2 };\n//# sourceMappingURL=pow2.mjs.map\n","// Taken from the bit-twiddle package\n\n/**\n * Rounds to next power of two.\n * @function nextPow2\n * @param {number} v - input value\n * @returns {number} - next rounded power of two\n * @memberof maths\n */\nexport function nextPow2(v: number): number\n{\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n\n    return v + 1;\n}\n\n/**\n * Checks if a number is a power of two.\n * @function isPow2\n * @param {number} v - input value\n * @returns {boolean} `true` if value is power of two\n * @memberof maths\n */\nexport function isPow2(v: number): boolean\n{\n    return !(v & (v - 1)) && (!!v);\n}\n\n/**\n * Computes ceil of log base 2\n * @function log2\n * @param {number} v - input value\n * @returns {number} logarithm base 2\n * @memberof maths\n */\nexport function log2(v: number): number\n{\n    let r = (v > 0xFFFF ? 1 : 0) << 4;\n\n    v >>>= r;\n\n    let shift = (v > 0xFF ? 1 : 0) << 3;\n\n    v >>>= shift; r |= shift;\n    shift = (v > 0xF ? 1 : 0) << 2;\n    v >>>= shift; r |= shift;\n    shift = (v > 0x3 ? 1 : 0) << 1;\n    v >>>= shift; r |= shift;\n\n    return r | (v >> 1);\n}\n","\"use strict\";\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\nexport { definedProps };\n//# sourceMappingURL=definedProps.mjs.map\n","/**\n * Returns a new object with all properties from the input object that have defined values.\n * @template T - The type of the input object.\n * @param {T} obj - The input object.\n * @returns {T} - A new object with only the defined properties from the input object.\n * @memberof utils\n * @ignore\n */\nexport function definedProps<T extends Record<string, any>>(obj: T): T\n{\n    const result: Partial<T> = {};\n\n    for (const key in obj)\n    {\n        if (obj[key] !== undefined)\n        {\n            result[key] = obj[key];\n        }\n    }\n\n    return result as T;\n}\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = uid(\"resource\");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends EventEmitter {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    this._resourceType = \"textureSampler\";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    deprecation(v8_0_0, \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = \"linear\";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit(\"change\", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: \"clamp-to-edge\",\n  scaleMode: \"linear\"\n};\nlet TextureStyle = _TextureStyle;\n\nexport { TextureStyle };\n//# sourceMappingURL=TextureStyle.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { COMPARE_FUNCTION, SCALE_MODE, WRAP_MODE } from './const';\n\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * This takes a shader string and maps it to a resource id.\n * This is a little different than regular resource ids as these ids\n * are not unique to the resource. But must not overlap with other (non sampler) resources Ids.\n * @param value - the string to turn into a resource id\n * @returns a unique resource id\n */\nfunction createResourceIdFromString(value: string): number\n{\n    const id = idHash[value];\n\n    if (id === undefined)\n    {\n        idHash[value] = uid('resource');\n    }\n\n    return id;\n}\n\nexport interface TextureStyleOptions extends Partial<TextureStyle>\n{\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    addressMode?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeU?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeW?: WRAP_MODE;\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    scaleMode?: SCALE_MODE;\n\n    /** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    magFilter?: SCALE_MODE;\n    /** specifies the sampling behavior when the sample footprint is larger than one texel. */\n    minFilter?: SCALE_MODE;\n    /** specifies behavior for sampling between mipmap levels. */\n    mipmapFilter?: SCALE_MODE;\n\n    /** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     *\n     * setting this to anything higher than 1 will set scale modes to 'linear'\n     */\n    maxAnisotropy?: number;\n}\n\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @memberof rendering\n */\nexport class TextureStyle extends EventEmitter<{\n    change: TextureStyle,\n    destroy: TextureStyle,\n}> implements BindResource\n{\n    public _resourceType = 'textureSampler';\n    public _touched = 0;\n    private _sharedResourceId: number;\n\n    /** default options for the style */\n    public static readonly defaultOptions: TextureStyleOptions = {\n        addressMode: 'clamp-to-edge',\n        scaleMode: 'linear'\n    };\n\n    /** */\n    public addressModeU?: WRAP_MODE;\n    /** */\n    public addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    public addressModeW?: WRAP_MODE;\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    public magFilter?: SCALE_MODE;\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    public minFilter?: SCALE_MODE;\n    /** Specifies behavior for sampling between mipmap levels. */\n    public mipmapFilter?: SCALE_MODE;\n    /** */\n    public lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    public lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    public compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    public _maxAnisotropy?: number = 1;\n\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * @param options - options for the style\n     */\n    constructor(options: TextureStyleOptions = {})\n    {\n        super();\n\n        options = { ...TextureStyle.defaultOptions, ...options };\n\n        this.addressMode = options.addressMode;\n\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n\n        this.scaleMode = options.scaleMode;\n\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n\n        this.compare = options.compare;\n\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this.addressModeU;\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'TextureStyle.wrapMode is now TextureStyle.addressMode');\n        // #endif\n\n        this.addressMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this.addressMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this.magFilter;\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._maxAnisotropy = Math.min(value, 16);\n\n        if (this._maxAnisotropy > 1)\n        {\n            this.scaleMode = 'linear';\n        }\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._maxAnisotropy;\n    }\n\n    // TODO - move this to WebGL?\n    get _resourceId(): number\n    {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n\n    public update()\n    {\n        // manage the resource..\n        this.emit('change', this);\n        this._sharedResourceId = null;\n    }\n\n    private _generateResourceId(): number\n    {\n        // eslint-disable-next-line max-len\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n\n        this._sharedResourceId = createResourceIdFromString(bigKey);\n\n        return this._resourceId;\n    }\n\n    /** Destroys the style */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this.removeAllListeners();\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\n\n\"use strict\";\nconst tempMat = new Matrix();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new Matrix();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === \"undefined\") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener(\"update\", this.update, this);\n    this._texture = value;\n    this._texture.addListener(\"update\", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset / texBase._resolution;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\nexport { TextureMatrix };\n//# sourceMappingURL=TextureMatrix.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\n\nimport type { Texture } from './Texture';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv mapping from Texture normal space to BaseTexture normal space.\n *\n * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.\n *\n * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * Takes track of Texture changes through `_lastTextureID` private field.\n * Use `update()` method call to track it from outside.\n * @see Texture\n * @see Mesh\n * @see TilingSprite\n * @memberof rendering\n */\nexport class TextureMatrix\n{\n    /**\n     * Matrix operation that converts texture region coords to texture coords\n     * @readonly\n     */\n    public mapCoord: Matrix;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     * @default 0\n     */\n    public clampOffset: number;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     */\n    public clampMargin: number;\n\n    /**\n     * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.\n     * Calculated based on clampOffset.\n     */\n    public readonly uClampFrame: Float32Array;\n\n    /** Normalized clamp offset. Calculated based on clampOffset. */\n    public readonly uClampOffset: Float32Array;\n\n    /**\n     * Tracks Texture frame changes.\n     * @ignore\n     */\n    public _updateID: number;\n\n    /**\n     * Tracks Texture frame changes.\n     * @protected\n     */\n    protected _textureID: number;\n\n    protected _texture: Texture;\n\n    /**\n     * If texture size is the same as baseTexture.\n     * @default false\n     * @readonly\n     */\n    public isSimple: boolean;\n\n    /**\n     * @param texture - observed texture\n     * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     */\n    constructor(texture: Texture, clampMargin?: number)\n    {\n        this.mapCoord = new Matrix();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n\n        this.clampOffset = 0;\n\n        if ((typeof clampMargin === 'undefined'))\n        {\n            this.clampMargin = (texture.width < 10) ? 0 : 0.5;\n        }\n        else\n        {\n            this.clampMargin = clampMargin;\n        }\n\n        this.isSimple = false;\n\n        this.texture = texture;\n    }\n\n    /** Texture property. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this._texture?.removeListener('update', this.update, this);\n        this._texture = value;\n        this._texture.addListener('update', this.update, this);\n\n        this.update();\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param uvs - mesh uvs\n     * @param [out=uvs] - output\n     * @returns - output\n     */\n    public multiplyUvs(uvs: Float32Array, out?: Float32Array): Float32Array\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * Updates matrices if texture was changed\n     * @returns - whether or not it was updated\n     */\n    public update(): boolean\n    {\n        const tex = this._texture;\n\n        this._updateID++;\n\n        const uvs = tex.uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(\n                orig.width / trim.width,\n                0, 0, orig.height / trim.height,\n                -trim.x / trim.width,\n                -trim.y / trim.height\n            );\n\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset / texBase._resolution;\n\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n\n        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n\n        this.isSimple = tex.frame.width === texBase.width\n            && tex.frame.height === texBase.height\n            && tex.rotate === 0;\n\n        return true;\n    }\n}\n","\"use strict\";\nfunction updateQuadBounds(bounds, anchor, texture) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n}\n\nexport { updateQuadBounds };\n//# sourceMappingURL=updateQuadBounds.mjs.map\n","import type { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../../scene/container/bounds/Bounds';\n\n/**\n * Updates the bounds of a quad (a rectangular area) based on the provided texture and anchor point.\n *\n * This function calculates the minimum and maximum x and y coordinates of the bounds, taking into\n * account the texture's original dimensions and any trimming that may have been applied to it.\n * @param {BoundsData} bounds - The bounds object to be updated. It contains minX, maxX, minY, and maxY properties.\n * @param {ObservablePoint} anchor - The anchor point of the texture, which affects the positioning of the bounds.\n * @param {Texture} texture - The texture whose dimensions and trimming information are used to update the bounds.\n */\nexport function updateQuadBounds(\n    bounds: BoundsData,\n    anchor: ObservablePoint,\n    texture: Texture\n): void\n{\n    const { width, height } = texture.orig;\n    const trim = texture.trim;\n\n    // If the texture has trimming information, adjust the bounds accordingly\n    if (trim)\n    {\n        // Calculate the source width and height from the trim\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n\n        // Update the bounds using the trim's x and y offsets and the anchor point\n        bounds.minX = trim.x - (anchor._x * width);\n        bounds.maxX = bounds.minX + sourceWidth;\n\n        bounds.minY = trim.y - (anchor._y * height);\n        bounds.maxY = bounds.minY + sourceHeight;\n    }\n    // If there is no trimming, calculate the bounds based solely on the texture's original dimensions\n    else\n    {\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n","import { Bounds } from '../container/bounds/Bounds.mjs';\nimport { Container } from '../container/Container.mjs';\n\n\"use strict\";\nclass ViewContainer extends Container {\n  constructor() {\n    super(...arguments);\n    /** @private */\n    this.canBundle = true;\n    /** @private */\n    this.allowChildren = false;\n    /** @private */\n    this._roundPixels = 0;\n    /** @private */\n    this._lastUsed = -1;\n    this._bounds = new Bounds(0, 1, 0, 0);\n    this._boundsDirty = true;\n  }\n  /**\n   * The local bounds of the view.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this.updateBounds();\n    this._boundsDirty = false;\n    return this._bounds;\n  }\n  /**\n   * Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.bounds;\n    const { x, y } = point;\n    return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;\n  }\n  /** @private */\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  destroy(options) {\n    super.destroy(options);\n    this._bounds = null;\n  }\n  collectRenderablesSimple(instructionSet, renderer, currentLayer) {\n    const { renderPipes, renderableGC } = renderer;\n    renderPipes.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);\n    const rp = renderPipes;\n    rp[this.renderPipeId].addRenderable(this, instructionSet);\n    renderableGC.addRenderable(this);\n    this.didViewUpdate = false;\n    const children = this.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      children[i].collectRenderables(instructionSet, renderer, currentLayer);\n    }\n  }\n}\n\nexport { ViewContainer };\n//# sourceMappingURL=ViewContainer.mjs.map\n","import { type InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { Bounds } from '../container/bounds/Bounds';\nimport { Container } from '../container/Container';\nimport { type IRenderLayer } from '../layers/RenderLayer';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * A ViewContainer is a type of container that represents a view.\n * This view can be a Sprite, a Graphics object, or any other object that can be rendered.\n * This class is abstract and should not be used directly.\n * @memberof scene\n */\nexport abstract class ViewContainer extends Container implements View\n{\n    /** @private */\n    public override readonly renderPipeId: string;\n    /** @private */\n    public readonly canBundle = true;\n    /** @private */\n    public override allowChildren = false;\n\n    /** @private */\n    public _roundPixels: 0 | 1 = 0;\n    /** @private */\n    public _lastUsed = -1;\n\n    protected _bounds: Bounds = new Bounds(0, 1, 0, 0);\n    protected _boundsDirty = true;\n\n    /**\n     * The local bounds of the view.\n     * @type {rendering.Bounds}\n     */\n    public get bounds()\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this.updateBounds();\n\n        this._boundsDirty = false;\n\n        return this._bounds;\n    }\n\n    /** @private */\n    protected abstract updateBounds(): void;\n\n    /**\n     * Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.bounds;\n        const { x, y } = point;\n\n        return (x >= bounds.minX\n            && x <= bounds.maxX\n            && y >= bounds.minY\n            && y <= bounds.maxY);\n    }\n\n    /** @private */\n    public abstract batched: boolean;\n\n    /** @private */\n    protected onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public override destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        this._bounds = null;\n    }\n\n    public override collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const { renderPipes, renderableGC } = renderer;\n\n        // TODO add blends in\n        renderPipes.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);\n\n        const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n        rp[this.renderPipeId].addRenderable(this, instructionSet);\n\n        renderableGC.addRenderable(this);\n\n        this.didViewUpdate = false;\n\n        const children = this.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nconst defaultMatrix = new Matrix();\nclass Bounds {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /** @default Infinity */\n    this.minX = Infinity;\n    /** @default Infinity */\n    this.minY = Infinity;\n    /** @default -Infinity */\n    this.maxX = -Infinity;\n    /** @default -Infinity */\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** The bounding rectangle of the bounds. */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new Rectangle();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */\n  fitBounds(left, right, top, bottom) {\n    if (this.minX < left)\n      this.minX = left;\n    if (this.maxX > right)\n      this.maxX = right;\n    if (this.minY < top)\n      this.minY = top;\n    if (this.maxY > bottom)\n      this.maxY = bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /** Ceils the bounds. */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /** Clones the bounds. */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /** the x value of the bounds. */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /** the y value of the bounds. */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /** the width value of the bounds. */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /** the height value of the bounds. */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /** the left value of the bounds. */\n  get left() {\n    return this.minX;\n  }\n  /** the right value of the bounds. */\n  get right() {\n    return this.maxX;\n  }\n  /** the top value of the bounds. */\n  get top() {\n    return this.minY;\n  }\n  /** the bottom value of the bounds. */\n  get bottom() {\n    return this.maxY;\n  }\n  /** Is the bounds positive. */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n  /**\n   * Copies the bounds from another bounds object.\n   * @param bounds - The bounds to copy from.\n   * @returns - This bounds object.\n   */\n  copyFrom(bounds) {\n    this.minX = bounds.minX;\n    this.minY = bounds.minY;\n    this.maxX = bounds.maxX;\n    this.maxY = bounds.maxY;\n    return this;\n  }\n}\n\nexport { Bounds };\n//# sourceMappingURL=Bounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\n\n/**\n * Simple bounds implementation instead of more ambiguous [number, number, number, number]\n * @memberof rendering\n */\nexport interface BoundsData\n{\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nconst defaultMatrix = new Matrix();\n\n// TODO optimisations\n// 1 - get rectangle could use a dirty flag, rather than setting the data each time is called\n// 2- getFrame ALWAYS assumes a matrix, could be optimised to avoid the matrix calculation if not needed\n\n/**\n * A representation of an AABB bounding box.\n * @memberof rendering\n */\nexport class Bounds\n{\n    /** @default Infinity */\n    public minX = Infinity;\n\n    /** @default Infinity */\n    public minY = Infinity;\n\n    /** @default -Infinity */\n    public maxX = -Infinity;\n\n    /** @default -Infinity */\n    public maxY = -Infinity;\n\n    public matrix = defaultMatrix;\n\n    private _rectangle: Rectangle;\n\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity)\n    {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     * @returns - True if empty.\n     */\n    public isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /** The bounding rectangle of the bounds. */\n    get rectangle(): Rectangle\n    {\n        if (!this._rectangle)\n        {\n            this._rectangle = new Rectangle();\n        }\n\n        const rectangle = this._rectangle;\n\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        }\n        else\n        {\n            rectangle.copyFromBounds(this);\n        }\n\n        return rectangle;\n    }\n\n    /** Clears the bounds and resets. */\n    public clear(): this\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.matrix = defaultMatrix;\n\n        return this;\n    }\n\n    /**\n     * Sets the bounds.\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    public set(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n\n    /**\n     * Adds sprite frame\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param matrix\n     */\n    public addFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void\n    {\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds a rectangle to the bounds.\n     * @param rect - The rectangle to be added.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public addRect(rect: Rectangle, matrix?: Matrix)\n    {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n\n    /**\n     * Adds other {@link Bounds}.\n     * @param bounds - The Bounds to be added\n     * @param matrix\n     */\n    public addBounds(bounds: BoundsData, matrix?: Matrix)\n    {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     * @param mask - The Bounds to be added.\n     */\n    public addBoundsMask(mask: Bounds): void\n    {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n\n    /**\n     * Adds other Bounds, multiplied with matrix.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public applyMatrix(matrix: Matrix): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        // multiple bounds by matrix\n        const { a, b, c, d, tx, ty } = matrix;\n\n        let x = (a * minX) + (c * minY) + tx;\n        let y = (b * minX) + (d * minY) + ty;\n\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n\n        x = (a * maxX) + (c * minY) + tx;\n        y = (b * maxX) + (d * minY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * minX) + (c * maxY) + tx;\n        y = (b * minX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * maxX) + (c * maxY) + tx;\n        y = (b * maxX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n\n    /**\n     * Resizes the bounds object to include the given rectangle.\n     * @param rect - The rectangle to be included.\n     */\n    public fit(rect: Rectangle): this\n    {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n\n        return this;\n    }\n\n    /**\n     * Resizes the bounds object to include the given bounds.\n     * @param left - The left value of the bounds.\n     * @param right - The right value of the bounds.\n     * @param top - The top value of the bounds.\n     * @param bottom - The bottom value of the bounds.\n     */\n    public fitBounds(left: number, right: number, top: number, bottom: number): this\n    {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n\n        return this;\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */\n    public pad(paddingX: number, paddingY: number = paddingX): this\n    {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n\n        return this;\n    }\n\n    /** Ceils the bounds. */\n    public ceil(): this\n    {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n\n        return this;\n    }\n\n    /** Clones the bounds. */\n    public clone(): Bounds\n    {\n        return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n    }\n\n    /**\n     * Scales the bounds by the given values\n     * @param x - The X value to scale by.\n     * @param y - The Y value to scale by.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n\n        return this;\n    }\n\n    /** the x value of the bounds. */\n    get x(): number\n    {\n        return this.minX;\n    }\n    set x(value: number)\n    {\n        const width = this.maxX - this.minX;\n\n        this.minX = value;\n        this.maxX = value + width;\n    }\n\n    /** the y value of the bounds. */\n    get y(): number\n    {\n        return this.minY;\n    }\n\n    set y(value: number)\n    {\n        const height = this.maxY - this.minY;\n\n        this.minY = value;\n        this.maxY = value + height;\n    }\n\n    /** the width value of the bounds. */\n    get width(): number\n    {\n        return this.maxX - this.minX;\n    }\n\n    set width(value: number)\n    {\n        this.maxX = this.minX + value;\n    }\n\n    /** the height value of the bounds. */\n    get height(): number\n    {\n        return this.maxY - this.minY;\n    }\n\n    set height(value: number)\n    {\n        this.maxY = this.minY + value;\n    }\n\n    /** the left value of the bounds. */\n    get left(): number\n    {\n        return this.minX;\n    }\n\n    /** the right value of the bounds. */\n    get right(): number\n    {\n        return this.maxX;\n    }\n\n    /** the top value of the bounds. */\n    get top(): number\n    {\n        return this.minY;\n    }\n\n    /** the bottom value of the bounds. */\n    get bottom(): number\n    {\n        return this.maxY;\n    }\n\n    /** Is the bounds positive. */\n    get isPositive(): boolean\n    {\n        return (this.maxX - this.minX > 0) && (this.maxY - this.minY > 0);\n    }\n\n    get isValid(): boolean\n    {\n        return (this.minX + this.minY !== Infinity);\n    }\n\n    /**\n     * Adds screen vertices from array\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param matrix\n     */\n    public addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n\n            const x = (a * localX) + (c * localY) + tx;\n            const y = (b * localX) + (d * localY) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if the point is contained within the bounds.\n     * @param x - x coordinate\n     * @param y - y coordinate\n     */\n    public containsPoint(x: number, y: number): boolean\n    {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public toString(): string\n    {\n        // eslint-disable-next-line max-len\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n\n    /**\n     * Copies the bounds from another bounds object.\n     * @param bounds - The bounds to copy from.\n     * @returns - This bounds object.\n     */\n    public copyFrom(bounds: Bounds): this\n    {\n        this.minX = bounds.minX;\n        this.minY = bounds.minY;\n        this.maxX = bounds.maxX;\n        this.maxY = bounds.maxY;\n\n        return this;\n    }\n}\n\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { cullingMixin } from '../../culling/cullingMixin.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { RAD_TO_DEG, DEG_TO_RAD } from '../../maths/misc/const.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { uid } from '../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { cacheAsTextureMixin } from './container-mixins/cacheAsTextureMixin.mjs';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin.mjs';\nimport { collectRenderablesMixin } from './container-mixins/collectRenderablesMixin.mjs';\nimport { effectsMixin } from './container-mixins/effectsMixin.mjs';\nimport { findMixin } from './container-mixins/findMixin.mjs';\nimport { getFastGlobalBoundsMixin } from './container-mixins/getFastGlobalBoundsMixin.mjs';\nimport { bgr2rgb, getGlobalMixin } from './container-mixins/getGlobalMixin.mjs';\nimport { measureMixin } from './container-mixins/measureMixin.mjs';\nimport { onRenderMixin } from './container-mixins/onRenderMixin.mjs';\nimport { sortMixin } from './container-mixins/sortMixin.mjs';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin.mjs';\nimport { RenderGroup } from './RenderGroup.mjs';\nimport { assignWithIgnore } from './utils/assignWithIgnore.mjs';\n\n\"use strict\";\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    /** unique id for this container */\n    this.uid = uid(\"renderable\");\n    /** @private */\n    this._updateFlags = 15;\n    // the render group this container owns\n    /** @private */\n    this.renderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    this.parentRenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    this.parentRenderGroupIndex = 0;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = \"inherit\";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = \"normal\";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    this._didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    this._didViewChangeTick = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    this.effects = [];\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  // = 'default';\n  /**\n   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n   * @deprecated since 8.2.6\n   * @ignore\n   */\n  set _didChangeId(value) {\n    this._didViewChangeTick = value >> 12 & 4095;\n    this._didContainerChangeTick = value & 4095;\n  }\n  get _didChangeId() {\n    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (renderGroup) {\n        renderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child._updateFlags = 15;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    this.emit(\"childAdded\", child, this, this.children.length - 1);\n    child.emit(\"added\", this);\n    this._didViewChangeTick++;\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this._didViewChangeTick++;\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      } else if (this.parentRenderGroup) {\n        this.parentRenderGroup.removeChild(child);\n      }\n      if (child.parentRenderLayer) {\n        child.parentRenderLayer.detach(child);\n      }\n      child.parent = null;\n      this.emit(\"childRemoved\", child, this, index);\n      child.emit(\"removed\", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didContainerChangeTick++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (!!this.renderGroup === value)\n      return;\n    if (value) {\n      this.enableRenderGroup();\n    } else {\n      this.disableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return !!this.renderGroup;\n  }\n  /**\n   * Calling this enables a render group for this container.\n   * This means it will be rendered as a separate set of instructions.\n   * The transform of the container will also be handled on the GPU rather than the CPU.\n   */\n  enableRenderGroup() {\n    if (this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    this.renderGroup = BigPool.get(RenderGroup, this);\n    this.groupTransform = Matrix.IDENTITY;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** This will disable the render group for this container. */\n  disableRenderGroup() {\n    if (!this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    BigPool.return(this.renderGroup);\n    this.renderGroup = null;\n    this.groupTransform = this.relativeGroupTransform;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.renderGroup && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix());\n    if (this.renderGroup) {\n      this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n    } else if (this.parentRenderGroup) {\n      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n    }\n    return this._worldTransform;\n  }\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * RAD_TO_DEG;\n  }\n  set angle(value) {\n    this.rotation = value * DEG_TO_RAD;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, size.width);\n    height !== void 0 && this._setHeight(height, size.height);\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === \"number\" ? opts.x : this.position.x,\n      typeof opts.y === \"number\" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    const localTransformChangeId = this._didContainerChangeTick;\n    if (this._didLocalTransformChangeId === localTransformChangeId)\n      return;\n    this._didLocalTransformChangeId = localTransformChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return bgr2rgb(this.localColor);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 2 : 0;\n    if ((this.localDisplayStatus & 2) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 0 : 4;\n    if ((this.localDisplayStatus & 4) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    let oldChildren;\n    if (this.children.length) {\n      oldChildren = this.removeChildren(0, this.children.length);\n    }\n    this.removeFromParent();\n    this.parent = null;\n    this._maskEffect = null;\n    this._filterEffect = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit(\"destroyed\", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n    if (destroyChildren && oldChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n    this.renderGroup?.destroy();\n    this.renderGroup = null;\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(getFastGlobalBoundsMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\nContainer.mixin(cacheAsTextureMixin);\nContainer.mixin(getGlobalMixin);\nContainer.mixin(collectRenderablesMixin);\n\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE };\n//# sourceMappingURL=Container.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { cullingMixin } from '../../culling/cullingMixin';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { DEG_TO_RAD, RAD_TO_DEG } from '../../maths/misc/const';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { type IRenderLayer } from '../layers/RenderLayer';\nimport { cacheAsTextureMixin } from './container-mixins/cacheAsTextureMixin';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin';\nimport { collectRenderablesMixin } from './container-mixins/collectRenderablesMixin';\nimport { effectsMixin } from './container-mixins/effectsMixin';\nimport { findMixin } from './container-mixins/findMixin';\nimport { getFastGlobalBoundsMixin } from './container-mixins/getFastGlobalBoundsMixin';\nimport { bgr2rgb, getGlobalMixin } from './container-mixins/getGlobalMixin';\nimport { measureMixin } from './container-mixins/measureMixin';\nimport { onRenderMixin } from './container-mixins/onRenderMixin';\nimport { sortMixin } from './container-mixins/sortMixin';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin';\nimport { RenderGroup } from './RenderGroup';\nimport { assignWithIgnore } from './utils/assignWithIgnore';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Rectangle } from '../../maths/shapes/Rectangle';\nimport type { BLEND_MODES } from '../../rendering/renderers/shared/state/const';\nimport type { Dict } from '../../utils/types';\nimport type { Optional } from './container-mixins/measureMixin';\nimport type { DestroyOptions } from './destroyTypes';\n\nexport type ContainerChild = Container;\n\n/**\n * This is where you'll find all the display objects available in Pixi.\n *\n * All display objects inherit from the {@link scene.Container} class. You can use a `Container` for simple grouping of\n * other display objects. Here's all the available display object classes.\n *\n * - {@link scene.Container} is the base class for all display objects that act as a container for other objects.\n *   - {@link scene.Sprite} is a display object that uses a texture\n *      - {@link scene.AnimatedSprite} is a sprite that can play animations\n *   - {@link scene.TilingSprite} a fast way of rendering a tiling image\n *   - {@link scene.NineSliceSprite} allows you to stretch a texture using 9-slice scaling\n *   - {@link scene.Graphics} is a graphic object that can be drawn to the screen.\n *   - {@link scene.Mesh} empowers you to have maximum flexibility to render any kind of visuals you can think of\n *      - {@link scene.MeshSimple} mimics Mesh, providing easy-to-use constructor arguments\n *      - {@link scene.MeshPlane} allows you to draw a texture across several points and then manipulate these points\n *      - {@link scene.MeshRope} allows you to draw a texture across several points and then manipulate these points\n *   - {@link scene.Text} render text using custom fonts\n *      - {@link scene.BitmapText} render text using a bitmap font\n *      - {@link scene.HTMLText} render text using HTML and CSS\n * @namespace scene\n */\n\n// as pivot and skew are the least used properties of a container, we can use this optimisation\n// to avoid allocating lots of unnecessary objects for them.\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\n\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents\n{\n    added: [container: Container];\n    childAdded: [child: C, container: Container, index: number];\n    removed: [container: Container];\n    childRemoved: [child: C, container: Container, index: number];\n    destroyed: [container: Container];\n}\n\ntype AnyEvent = {\n    // The following is a hack to allow any custom event while maintaining type safety.\n    // For some reason, the tsc compiler gets angry about error TS1023\n    // \"An index signature parameter type must be either 'string' or 'number'.\"\n    // This is really odd since ({}&string) should interpret as string, but then again\n    // there is some black magic behind why this works in the first place.\n    // Closest thing to an explanation:\n    // https://stackoverflow.com/questions/70144348/why-does-a-union-of-type-literals-and-string-cause-ide-code-completion-wh\n    //\n    // Side note, we disable @typescript-eslint/ban-types since {}&string is the only syntax that works.\n    // Nor of the Record/unknown/never alternatives work.\n    [K: ({} & string) | ({} & symbol)]: any;\n};\n\nexport const UPDATE_COLOR = 0b0001;\nexport const UPDATE_BLEND = 0b0010;\nexport const UPDATE_VISIBLE = 0b0100;\nexport const UPDATE_TRANSFORM = 0b1000;\n\nexport interface UpdateTransformOptions\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    skewX: number;\n    skewY: number;\n    pivotX: number;\n    pivotY: number;\n}\n\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @memberof scene\n * @see scene.Container\n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions\n{\n    /** @see scene.Container#isRenderGroup */\n    isRenderGroup?: boolean;\n\n    /** @see scene.Container#blendMode */\n    blendMode?: BLEND_MODES;\n    /** @see scene.Container#tint */\n    tint?: ColorSource;\n\n    /** @see scene.Container#alpha */\n    alpha?: number;\n    /** @see scene.Container#angle */\n    angle?: number;\n    /** @see scene.Container#children */\n    children?: C[];\n    /** @see scene.Container#parent */\n    parent?: Container;\n    /** @see scene.Container#renderable */\n    renderable?: boolean;\n    /** @see scene.Container#rotation */\n    rotation?: number;\n    /** @see scene.Container#scale */\n    scale?: PointData | number;\n    /** @see scene.Container#pivot */\n    pivot?: PointData | number;\n    /** @see scene.Container#position */\n    position?: PointData;\n    /** @see scene.Container#skew */\n    skew?: PointData;\n    /** @see scene.Container#visible */\n    visible?: boolean;\n    /** @see scene.Container#x */\n    x?: number;\n    /** @see scene.Container#y */\n    y?: number;\n    /** @see scene.Container#boundArea */\n    boundsArea?: Rectangle;\n}\n\nexport interface Container<C extends ContainerChild>\n    extends PixiMixins.Container<C>, EventEmitter<ContainerEvents<C> & AnyEvent> {}\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link scene.Container#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link scene.Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link scene.Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link scene.Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link scene.Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link scene.Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link scene.Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link scene.Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link scene.Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link scene.Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link scene.Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link scene.Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link scene.Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link scene.Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJS’s rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @memberof scene\n */\nexport class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent>\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to Container.\n     * @param source - The source of properties and methods to mix in.\n     */\n    public static mixin(source: Dict<any>): void\n    {\n        Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n\n    /** unique id for this container */\n    public readonly uid: number = uid('renderable');\n\n    /** @private */\n    public _updateFlags = 0b1111;\n\n    // the render group this container owns\n    /** @private */\n    public renderGroup: RenderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    public parentRenderGroup: RenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    public parentRenderGroupIndex: number = 0;\n\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    public didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    public didViewUpdate = false;\n\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    public relativeRenderGroupDepth = 0;\n\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    public children: C[] = [];\n    /** The display object container that contains this display object. */\n    public parent: Container = null;\n\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    public includeInBuild = true;\n    /** @private */\n    public measurable = true;\n    /** @private */\n    public isSimple = true;\n\n    /**\n     * The RenderLayer this container belongs to, if any.\n     * If it belongs to a RenderLayer, it will be rendered from the RenderLayer's position in the scene.\n     * @readonly\n     */\n    public parentRenderLayer: IRenderLayer;\n\n    // / /////////////Transform related props//////////////\n\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    public updateTick = -1;\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    public localTransform: Matrix = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    public relativeGroupTransform: Matrix = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    public groupTransform: Matrix = this.relativeGroupTransform;\n\n    // the global transform taking into account the render group and all parents\n    private _worldTransform: Matrix;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    public destroyed = false;\n\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    public _position: ObservablePoint = new ObservablePoint(this, 0, 0);\n\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    public _scale: ObservablePoint = defaultScale;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    public _pivot: ObservablePoint = defaultPivot;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    public _skew: ObservablePoint = defaultSkew;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cx = 1;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sx = 0;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cy = 0;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sy = 1;\n\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    private _rotation = 0;\n\n    // / COLOR related props //////////////\n\n    // color stored as ABGR\n    public localColor = 0xFFFFFF;\n    public localAlpha = 1;\n\n    public groupAlpha = 1; // A\n    public groupColor = 0xFFFFFF; // BGR\n    public groupColorAlpha = 0xFFFFFFFF; // ABGR\n\n    // / BLEND related props //////////////\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public localBlendMode: BLEND_MODES = 'inherit';\n    /**\n     * @internal\n     * @ignore\n     */\n    public groupBlendMode: BLEND_MODES = 'normal';\n\n    // / VISIBILITY related props //////////////\n\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    public localDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    public globalDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n\n    public readonly renderPipeId: string;\n\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     * This is great for optimisation! If for example you have a 1000 spinning particles and you know they all sit\n     * within a specific bounds, then setting it will mean the renderer will not need to measure the\n     * 1000 children to find the bounds. Instead it will just use the bounds you set.\n     */\n    public boundsArea: Rectangle;\n\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    public _didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    public _didViewChangeTick = 0;\n\n    public layerParentId: string;// = 'default';\n    /**\n     * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n     * @deprecated since 8.2.6\n     * @ignore\n     */\n    set _didChangeId(value: number)\n    {\n        this._didViewChangeTick = (value >> 12) & 0xFFF; // Extract the upper 12 bits\n        this._didContainerChangeTick = value & 0xFFF; // Extract the lower 12 bits\n    }\n\n    get _didChangeId(): number\n    {\n        return (this._didContainerChangeTick & 0xfff) | ((this._didViewChangeTick & 0xfff) << 12);\n    }\n\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    private _didLocalTransformChangeId = -1;\n\n    constructor(options: ContainerOptions<C> = {})\n    {\n        super();\n\n        this.effects = [];\n        assignWithIgnore(this, options, {\n            children: true,\n            parent: true,\n            effects: true,\n        });\n\n        options.children?.forEach((child) => this.addChild(child));\n        options.parent?.addChild(this);\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     * @param {...Container} children - The Container(s) to add to the container\n     * @returns {Container} - The first child that was added.\n     */\n    public addChild<U extends(C | IRenderLayer)[]>(...children: U): U[0]\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChild: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.addChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0] as C;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (child.parent === this)\n        {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n\n            return child;\n        }\n\n        if (child.parent)\n        {\n            // TODO Optimisation...if the parent has the same render group, this does not need to change!\n            child.parent.removeChild(child);\n        }\n\n        this.children.push(child);\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        child.parent = this;\n\n        child.didChange = true;\n\n        // TODO - OPtimise this? could check what the parent has set?\n        child._updateFlags = 0b1111;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        this.emit('childAdded', child, this, this.children.length - 1);\n        child.emit('added', this);\n\n        this._didViewChangeTick++;\n\n        if (child._zIndex !== 0)\n        {\n            child.depthOfChildModified();\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * @param {...Container} children - The Container(s) to remove\n     * @returns {Container} The first child that was removed.\n     */\n    public removeChild<U extends(C | IRenderLayer)[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0] as C;\n\n        const index = this.children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._didViewChangeTick++;\n\n            this.children.splice(index, 1);\n\n            if (this.renderGroup)\n            {\n                this.renderGroup.removeChild(child);\n            }\n            else if (this.parentRenderGroup)\n            {\n                this.parentRenderGroup.removeChild(child);\n            }\n\n            if (child.parentRenderLayer)\n            {\n                child.parentRenderLayer.detach(child);\n            }\n\n            child.parent = null;\n            this.emit('childRemoved', child, this, index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /** @ignore */\n    public _onUpdate(point?: ObservablePoint)\n    {\n        if (point)\n        {\n            //   this.updateFlags |= UPDATE_TRANSFORM;\n\n            if (point === this._skew)\n            {\n                this._updateSkew();\n            }\n        }\n\n        this._didContainerChangeTick++;\n\n        if (this.didChange) return;\n        this.didChange = true;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.onChildUpdate(this);\n        }\n    }\n\n    set isRenderGroup(value: boolean)\n    {\n        if (!!this.renderGroup === value) return;\n\n        if (value)\n        {\n            this.enableRenderGroup();\n        }\n        else\n        {\n            this.disableRenderGroup();\n        }\n    }\n\n    /**\n     * Returns true if this container is a render group.\n     * This means that it will be rendered as a separate pass, with its own set of instructions\n     */\n    get isRenderGroup(): boolean\n    {\n        return !!this.renderGroup;\n    }\n\n    /**\n     * Calling this enables a render group for this container.\n     * This means it will be rendered as a separate set of instructions.\n     * The transform of the container will also be handled on the GPU rather than the CPU.\n     */\n    public enableRenderGroup(): void\n    {\n        if (this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        this.renderGroup = BigPool.get(RenderGroup, this);\n\n        // this group matrix will now be an identity matrix,\n        // as its own transform will be passed to the GPU\n        this.groupTransform = Matrix.IDENTITY;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /** This will disable the render group for this container. */\n    public disableRenderGroup(): void\n    {\n        if (!this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        BigPool.return(this.renderGroup);\n\n        this.renderGroup = null;\n        this.groupTransform = this.relativeGroupTransform;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /** @ignore */\n    public _updateIsSimple()\n    {\n        this.isSimple = !(this.renderGroup) && (this.effects.length === 0);\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform()\n    {\n        this._worldTransform ||= new Matrix();\n\n        if (this.renderGroup)\n        {\n            this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n        }\n        else if (this.parentRenderGroup)\n        {\n            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n        }\n\n        return this._worldTransform;\n    }\n\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this._position.x;\n    }\n\n    set x(value: number)\n    {\n        this._position.x = value;\n    }\n\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this._position.y;\n    }\n\n    set y(value: number)\n    {\n        this._position.y = value;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this._position;\n    }\n\n    set position(value: PointData)\n    {\n        this._position.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._pivot;\n    }\n\n    set pivot(value: PointData | number)\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._skew;\n    }\n\n    set skew(value: PointData)\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        this._skew.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 1, 1);\n        }\n\n        return this._scale;\n    }\n\n    set scale(value: PointData | number)\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get width(): number\n    {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n\n    set width(value: number)\n    {\n        const localWidth = this.getLocalBounds().width;\n\n        this._setWidth(value, localWidth);\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get height(): number\n    {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n\n    set height(value: number)\n    {\n        const localHeight = this.getLocalBounds().height;\n\n        this._setHeight(value, localHeight);\n    }\n\n    /**\n     * Retrieves the size of the container as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the container.\n     * @memberof scene.Container#\n     */\n    public getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        const bounds = this.getLocalBounds();\n\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the container to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     * @memberof scene.Container#\n     */\n    public setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        const size = this.getLocalBounds();\n\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, size.width);\n        height !== undefined && this._setHeight(height, size.height);\n    }\n\n    /** Called when the skew or the rotation changes. */\n    private _updateSkew(): void\n    {\n        const rotation = this._rotation;\n        const skew = this._skew;\n\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x); // cos, added PI/2\n        this._sy = Math.cos(rotation - skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates the transform properties of the container (accepts partial values).\n     * @param {object} opts - The options for updating the transform.\n     * @param {number} opts.x - The x position of the container.\n     * @param {number} opts.y - The y position of the container.\n     * @param {number} opts.scaleX - The scale factor on the x-axis.\n     * @param {number} opts.scaleY - The scale factor on the y-axis.\n     * @param {number} opts.rotation - The rotation of the container, in radians.\n     * @param {number} opts.skewX - The skew factor on the x-axis.\n     * @param {number} opts.skewY - The skew factor on the y-axis.\n     * @param {number} opts.pivotX - The x coordinate of the pivot point.\n     * @param {number} opts.pivotY - The y coordinate of the pivot point.\n     */\n    public updateTransform(opts: Partial<UpdateTransformOptions>): this\n    {\n        this.position.set(\n            typeof opts.x === 'number' ? opts.x : this.position.x,\n            typeof opts.y === 'number' ? opts.y : this.position.y\n        );\n        this.scale.set(\n            typeof opts.scaleX === 'number' ? opts.scaleX || 1 : this.scale.x,\n            typeof opts.scaleY === 'number' ? opts.scaleY || 1 : this.scale.y\n        );\n        this.rotation = typeof opts.rotation === 'number' ? opts.rotation : this.rotation;\n        this.skew.set(\n            typeof opts.skewX === 'number' ? opts.skewX : this.skew.x,\n            typeof opts.skewY === 'number' ? opts.skewY : this.skew.y\n        );\n        this.pivot.set(\n            typeof opts.pivotX === 'number' ? opts.pivotX : this.pivot.x,\n            typeof opts.pivotY === 'number' ? opts.pivotY : this.pivot.y\n        );\n\n        return this;\n    }\n\n    /**\n     * Updates the local transform using the given matrix.\n     * @param matrix - The matrix to use for updating the transform.\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n    }\n\n    /** Updates the local transform. */\n    public updateLocalTransform(): void\n    {\n        const localTransformChangeId = this._didContainerChangeTick;\n\n        if (this._didLocalTransformChangeId === localTransformChangeId) return;\n\n        this._didLocalTransformChangeId = localTransformChangeId;\n        //   this.didChange = false;\n\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n\n        const sx = scale._x;\n        const sy = scale._y;\n\n        const px = pivot._x;\n        const py = pivot._y;\n\n        // get the matrix values of the container based on its this properties..\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n\n        lt.tx = position._x - ((px * lt.a) + (py * lt.c));\n        lt.ty = position._y - ((px * lt.b) + (py * lt.d));\n    }\n\n    // / ///// color related stuff\n\n    set alpha(value: number)\n    {\n        if (value === this.localAlpha) return;\n\n        this.localAlpha = value;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /** The opacity of the object. */\n    get alpha(): number\n    {\n        return this.localAlpha;\n    }\n\n    set tint(value: ColorSource)\n    {\n        const tempColor = Color.shared.setValue(value ?? 0xFFFFFF);\n        const bgr = tempColor.toBgrNumber();\n\n        if (bgr === this.localColor) return;\n\n        this.localColor = bgr;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The tint applied to the sprite. This is a hex value.\n     *\n     * A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    get tint(): number\n    {\n        // convert bgr to rgb..\n        return bgr2rgb(this.localColor);\n    }\n\n    // / //////////////// blend related stuff\n\n    set blendMode(value: BLEND_MODES)\n    {\n        if (this.localBlendMode === value) return;\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_BLEND;\n\n        this.localBlendMode = value;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this.localBlendMode;\n    }\n\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n    get visible()\n    {\n        return !!(this.localDisplayStatus & 0b010);\n    }\n\n    set visible(value: boolean)\n    {\n        const valueNumber = value ? 0b010 : 0;\n\n        if ((this.localDisplayStatus & 0b010) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n\n        this.localDisplayStatus ^= 0b010;\n\n        this._onUpdate();\n    }\n\n    /** @ignore */\n    get culled()\n    {\n        return !(this.localDisplayStatus & 0b100);\n    }\n\n    /** @ignore */\n    set culled(value: boolean)\n    {\n        const valueNumber = value ? 0 : 0b100;\n\n        if ((this.localDisplayStatus & 0b100) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b100;\n\n        this._onUpdate();\n    }\n\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n    get renderable()\n    {\n        return !!(this.localDisplayStatus & 0b001);\n    }\n\n    set renderable(value: boolean)\n    {\n        const valueNumber = value ? 0b001 : 0;\n\n        if ((this.localDisplayStatus & 0b001) === valueNumber) return;\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b001;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._onUpdate();\n    }\n\n    /** Whether or not the object should be rendered. */\n    get isRenderable(): boolean\n    {\n        return (this.localDisplayStatus === 0b111 && this.groupAlpha > 0);\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n     * is set to true it should destroy the texture of the child sprite\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true it should destroy the texture source of the child sprite\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true it should destroy the context of the child graphics\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        // remove children is faster than removeChild..\n\n        let oldChildren: ContainerChild[];\n\n        // we add this check as calling removeChildren on particle container will throw an error\n        // As we know it does cannot have any children, check before calling the function.\n        if (this.children.length)\n        {\n            oldChildren = this.removeChildren(0, this.children.length);\n        }\n\n        this.removeFromParent();\n        this.parent = null;\n        this._maskEffect = null;\n        this._filterEffect = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n\n        this.emit('destroyed', this);\n\n        this.removeAllListeners();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        if (destroyChildren && oldChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n\n        this.renderGroup?.destroy();\n        this.renderGroup = null;\n    }\n}\n\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(getFastGlobalBoundsMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\nContainer.mixin(cacheAsTextureMixin);\nContainer.mixin(getGlobalMixin);\nContainer.mixin(collectRenderablesMixin);\n","import { extend, colord } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\n\"use strict\";\nextend([namesPlugin]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error(\"Cannot set Color#value to null\");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._value = this._cloneSource(value);\n      this._normalize(this._value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === \"object\" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out || (out = this._arrayRgb);\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out || (out = this._arrayRgba);\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out || (out = this._arrayRgb);\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexadecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexadecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === \"string\" || typeof value === \"object\") {\n      if (typeof value === \"string\") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = colord(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === \"number\") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from 'pixi.js';\n   * Color.isColorLike('white'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */\n  static isColorLike(value) {\n    return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from 'pixi.js';\n * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\nexport { Color };\n//# sourceMappingURL=Color.mjs.map\n","import { colord, extend } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\nimport type { AnyColor, HslaColor, HslColor, HsvaColor, HsvColor, RgbaColor, RgbColor } from '@pixi/colord';\n\nextend([namesPlugin]);\n\n/**\n * Pixi supports multiple color formats, including CSS color strings, hex, numbers, and arrays.\n *\n * When providing values for any of the color properties, you can use any of the {@link color.ColorSource} formats.\n * ```typescript\n * import { Color } from 'pixi.js';\n *\n * // All of these are valid:\n * sprite.tint = 'red';\n * sprite.tint = 0xff0000;\n * sprite.tint = '#ff0000';\n * sprite.tint = new Color('red');\n *\n * // Same for graphics fill/stroke colors and other  color values:\n * graphics.fill({ color: 'red' });\n * graphics.fill({ color: 0xff0000 });\n * graphics.stroke({ color: '#ff0000' });\n * graphics.stroke({ color: new Color('red')};\n * ```\n * @namespace color\n */\n\n/**\n * RGBA color array.\n *\n * `[number, number, number, number]`\n * @memberof color\n */\nexport type RgbaArray = [number, number, number, number];\n\n/**\n * Valid formats to use when defining any color properties, also valid for the {@link color.Color} constructor.\n *\n * These types are extended from [colord](https://www.npmjs.com/package/colord) with some PixiJS-specific extensions.\n *\n * Possible value types are:\n * - [Color names](https://www.w3.org/TR/css-color-4/#named-colors):\n *   `'red'`, `'green'`, `'blue'`, `'white'`, etc.\n * - RGB hex integers (`0xRRGGBB`):\n *   `0xff0000`, `0x00ff00`, `0x0000ff`, etc.\n * - [RGB(A) hex strings](https://www.w3.org/TR/css-color-4/#hex-notation):\n *   - 6 digits (`RRGGBB`): `'ff0000'`, `'#00ff00'`, `'0x0000ff'`, etc.\n *   - 3 digits (`RGB`): `'f00'`, `'#0f0'`, `'0x00f'`, etc.\n *   - 8 digits (`RRGGBBAA`): `'ff000080'`, `'#00ff0080'`, `'0x0000ff80'`, etc.\n *   - 4 digits (`RGBA`): `'f008'`, `'#0f08'`, `'0x00f8'`, etc.\n * - RGB(A) objects:\n *   `{ r: 255, g: 0, b: 0 }`, `{ r: 255, g: 0, b: 0, a: 0.5 }`, etc.\n * - [RGB(A) strings](https://www.w3.org/TR/css-color-4/#rgb-functions):\n *   `'rgb(255, 0, 0)'`, `'rgb(100% 0% 0%)'`, `'rgba(255, 0, 0, 0.5)'`, `'rgba(100% 0% 0% / 50%)'`, etc.\n * - RGB(A) arrays:\n *   `[1, 0, 0]`, `[1, 0, 0, 0.5]`, etc.\n * - RGB(A) Float32Array:\n *   `new Float32Array([1, 0, 0])`, `new Float32Array([1, 0, 0, 0.5])`, etc.\n * - RGB(A) Uint8Array:\n *   `new Uint8Array([255, 0, 0])`, `new Uint8Array([255, 0, 0, 128])`, etc.\n * - RGB(A) Uint8ClampedArray:\n *   `new Uint8ClampedArray([255, 0, 0])`, `new Uint8ClampedArray([255, 0, 0, 128])`, etc.\n * - HSL(A) objects:\n *   `{ h: 0, s: 100, l: 50 }`, `{ h: 0, s: 100, l: 50, a: 0.5 }`, etc.\n * - [HSL(A) strings](https://www.w3.org/TR/css-color-4/#the-hsl-notation):\n *   `'hsl(0, 100%, 50%)'`, `'hsl(0deg 100% 50%)'`, `'hsla(0, 100%, 50%, 0.5)'`, `'hsla(0deg 100% 50% / 50%)'`, etc.\n * - HSV(A) objects:\n *   `{ h: 0, s: 100, v: 100 }`, `{ h: 0, s: 100, v: 100, a: 0.5 }`, etc.\n * - {@link color.Color} objects.\n * @since 7.2.0\n * @memberof color\n */\nexport type ColorSource =\n    | string\n    | number\n    | number[]\n    | Float32Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | HslColor\n    | HslaColor\n    | HsvColor\n    | HsvaColor\n    | RgbColor\n    | RgbaColor\n    | Color\n    | number;\n\ntype ColorSourceTypedArray = Float32Array | Uint8Array | Uint8ClampedArray;\n\n/**\n * Color utility class. Can accept any {@link color.ColorSource} format in its constructor.\n * ```js\n * import { Color } from 'pixi.js';\n *\n * new Color('red').toArray(); // [1, 0, 0, 1]\n * new Color(0xff0000).toArray(); // [1, 0, 0, 1]\n * new Color('ff0000').toArray(); // [1, 0, 0, 1]\n * new Color('#f00').toArray(); // [1, 0, 0, 1]\n * new Color('0xff0000ff').toArray(); // [1, 0, 0, 1]\n * new Color('#f00f').toArray(); // [1, 0, 0, 1]\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('rgb(255, 0, 0, 0.5)').toArray(); // [1, 0, 0, 0.5]\n * new Color([1, 1, 1]).toArray(); // [1, 1, 1, 1]\n * new Color([1, 0, 0, 0.5]).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Float32Array([1, 0, 0, 0.5])).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Uint8Array([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color(new Uint8ClampedArray([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('hsl(0, 100%, 50%, 50%)').toArray(); // [1, 0, 0, 0.5]\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * ```\n * @since 7.2.0\n * @memberof color\n */\nexport class Color\n{\n    /**\n     * Default Color object for static uses\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n     */\n    public static readonly shared = new Color();\n\n    /**\n     * Temporary Color object for static uses internally.\n     * As to not conflict with Color.shared.\n     * @ignore\n     */\n    private static readonly _temp = new Color();\n\n    /** Pattern for hex strings */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static readonly HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\n\n    /** Internal color source, from constructor or set value */\n    private _value: Exclude<ColorSource, Color> | null;\n\n    /** Normalized rgba component, floats from 0-1 */\n    private _components: Float32Array;\n\n    /** Cache color as number */\n    private _int: number;\n\n    /** An array of the current Color. Only populated when `toArray` functions are called */\n    private _arrayRgba: number[] | null;\n    private _arrayRgb: number[] | null;\n\n    /**\n     * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n     */\n    constructor(value: ColorSource = 0xffffff)\n    {\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 0xffffff;\n        this.value = value;\n    }\n\n    /** Get red component (0 - 1) */\n    get red(): number\n    {\n        return this._components[0];\n    }\n\n    /** Get green component (0 - 1) */\n    get green(): number\n    {\n        return this._components[1];\n    }\n\n    /** Get blue component (0 - 1) */\n    get blue(): number\n    {\n        return this._components[2];\n    }\n\n    /** Get alpha component (0 - 1) */\n    get alpha(): number\n    {\n        return this._components[3];\n    }\n\n    /**\n     * Set the value, suitable for chaining\n     * @param value\n     * @see Color.value\n     */\n    public setValue(value: ColorSource): this\n    {\n        this.value = value;\n\n        return this;\n    }\n\n    /**\n     * The current color source.\n     *\n     * When setting:\n     * - Setting to an instance of `Color` will copy its color source and components.\n     * - Otherwise, `Color` will try to normalize the color source and set the components.\n     *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n     *\n     * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n     * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n     *\n     * When getting:\n     * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n     *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n     * - Otherwise, the color source used when setting is returned.\n     */\n    set value(value: ColorSource | null)\n    {\n        // Support copying from other Color objects\n        if (value instanceof Color)\n        {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        }\n        else if (value === null)\n        {\n            throw new Error('Cannot set Color#value to null');\n        }\n        else if (this._value === null || !this._isSourceEqual(this._value, value))\n        {\n            this._value = this._cloneSource(value);\n            this._normalize(this._value);\n        }\n    }\n    get value(): Exclude<ColorSource, Color> | null\n    {\n        return this._value;\n    }\n\n    /**\n     * Copy a color source internally.\n     * @param value - Color source\n     */\n    private _cloneSource(value: Exclude<ColorSource, Color> | null): Exclude<ColorSource, Color> | null\n    {\n        if (typeof value === 'string' || typeof value === 'number' || value instanceof Number || value === null)\n        {\n            return value;\n        }\n        else if (Array.isArray(value) || ArrayBuffer.isView(value))\n        {\n            return value.slice(0);\n        }\n        else if (typeof value === 'object' && value !== null)\n        {\n            return { ...value };\n        }\n\n        return value;\n    }\n\n    /**\n     * Equality check for color sources.\n     * @param value1 - First color source\n     * @param value2 - Second color source\n     * @returns `true` if the color sources are equal, `false` otherwise.\n     */\n    private _isSourceEqual(value1: Exclude<ColorSource, Color>, value2: Exclude<ColorSource, Color>): boolean\n    {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n\n        // Mismatched types\n        if (type1 !== type2)\n        {\n            return false;\n        }\n        // Handle numbers/strings and things that extend Number\n        // important to do the instanceof Number first, as this is \"object\" type\n        else if (type1 === 'number' || type1 === 'string' || value1 instanceof Number)\n        {\n            return value1 === value2;\n        }\n        // Handle Arrays and TypedArrays\n        else if (\n            (Array.isArray(value1) && Array.isArray(value2))\n            || (ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))\n        )\n        {\n            if (value1.length !== value2.length)\n            {\n                return false;\n            }\n\n            return value1.every((v, i) => v === value2[i]);\n        }\n        // Handle Objects\n        else if (value1 !== null && value2 !== null)\n        {\n            const keys1 = Object.keys(value1) as (keyof typeof value1)[];\n            const keys2 = Object.keys(value2) as (keyof typeof value2)[];\n\n            if (keys1.length !== keys2.length)\n            {\n                return false;\n            }\n\n            return keys1.every((key) => value1[key] === value2[key]);\n        }\n\n        return value1 === value2;\n    }\n\n    /**\n     * Convert to a RGBA color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n     */\n    public toRgba(): RgbaColor\n    {\n        const [r, g, b, a] = this._components;\n\n        return { r, g, b, a };\n    }\n\n    /**\n     * Convert to a RGB color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n     */\n    public toRgb(): RgbColor\n    {\n        const [r, g, b] = this._components;\n\n        return { r, g, b };\n    }\n\n    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n    public toRgbaString(): string\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n     * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Output array\n     */\n    public toUint8RgbArray(): number[];\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out: T): T;\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out?: T): T\n    {\n        const [r, g, b] = this._components;\n\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out ||= this._arrayRgb as T;\n\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toArray(); // returns [1, 1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toArray(): number[];\n    public toArray<T extends number[] | Float32Array>(out: T): T;\n    public toArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgba)\n        {\n            this._arrayRgba = [];\n        }\n\n        out ||= this._arrayRgba as T;\n        const [r, g, b, a] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgbArray(); // returns [1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toRgbArray(): number[];\n    public toRgbArray<T extends number[] | Float32Array>(out: T): T;\n    public toRgbArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out ||= this._arrayRgb as T;\n        const [r, g, b] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n\n        return out;\n    }\n\n    /**\n     * Convert to a hexadecimal number.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toNumber(); // returns 16777215\n     */\n    public toNumber(): number\n    {\n        return this._int;\n    }\n\n    /**\n     * Convert to a BGR number\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n     */\n    public toBgrNumber(): number\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return (b << 16) + (g << 8) + r;\n    }\n\n    /**\n     * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n     * @returns {number} - The color as a number in little endian format.\n     */\n    public toLittleEndianNumber(): number\n    {\n        const value = this._int;\n\n        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n    }\n\n    /**\n     * Multiply with another color. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param {ColorSource} value - The color to multiply by.\n     */\n    public multiply(value: ColorSource): this\n    {\n        const [r, g, b, a] = Color._temp.setValue(value)._components;\n\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Converts color to a premultiplied alpha format. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {Color} - Itself.\n     */\n    public premultiply(alpha: number, applyToRGB = true): this\n    {\n        if (applyToRGB)\n        {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Premultiplies alpha with current color.\n     * @param {number} alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {number} tint multiplied by alpha\n     */\n    public toPremultiplied(alpha: number, applyToRGB = true): number\n    {\n        if (alpha === 1.0)\n        {\n            return (0xff << 24) + this._int;\n        }\n        if (alpha === 0.0)\n        {\n            return applyToRGB ? 0 : this._int;\n        }\n        let r = (this._int >> 16) & 0xff;\n        let g = (this._int >> 8) & 0xff;\n        let b = this._int & 0xff;\n\n        if (applyToRGB)\n        {\n            r = ((r * alpha) + 0.5) | 0;\n            g = ((g * alpha) + 0.5) | 0;\n            b = ((b * alpha) + 0.5) | 0;\n        }\n\n        return ((alpha * 255) << 24) + (r << 16) + (g << 8) + b;\n    }\n\n    /**\n     * Convert to a hexadecimal string.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHex(); // returns \"#ffffff\"\n     */\n    public toHex(): string\n    {\n        const hexString = this._int.toString(16);\n\n        return `#${'000000'.substring(0, 6 - hexString.length) + hexString}`;\n    }\n\n    /**\n     * Convert to a hexadecimal string with alpha.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHexa(); // returns \"#ffffffff\"\n     */\n    public toHexa(): string\n    {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n\n        return this.toHex() + '00'.substring(0, 2 - alphaString.length) + alphaString;\n    }\n\n    /**\n     * Set alpha, suitable for chaining.\n     * @param alpha\n     */\n    public setAlpha(alpha: number): this\n    {\n        this._components[3] = this._clamp(alpha);\n\n        return this;\n    }\n\n    /**\n     * Normalize the input value into rgba\n     * @param value - Input value\n     */\n    private _normalize(value: Exclude<ColorSource, Color>): void\n    {\n        let r: number | undefined;\n        let g: number | undefined;\n        let b: number | undefined;\n        let a: number | undefined;\n\n        // Number is a primitive so typeof works fine, but in the case\n        // that someone creates a class that extends Number, we also\n        // need to check for instanceof Number\n        if (\n            (typeof value === 'number' || value instanceof Number)\n            && (value as number) >= 0\n            && (value as number) <= 0xffffff\n        )\n        {\n            const int = value as number; // cast required because instanceof Number is ambiguous for TS\n\n            r = ((int >> 16) & 0xff) / 255;\n            g = ((int >> 8) & 0xff) / 255;\n            b = (int & 0xff) / 255;\n            a = 1.0;\n        }\n        else if (\n            (Array.isArray(value) || value instanceof Float32Array)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 1\n            value = this._clamp(value);\n            [r, g, b, a = 1.0] = value;\n        }\n        else if (\n            (value instanceof Uint8Array || value instanceof Uint8ClampedArray)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 255\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        }\n        else if (typeof value === 'string' || typeof value === 'object')\n        {\n            if (typeof value === 'string')\n            {\n                const match = Color.HEX_PATTERN.exec(value);\n\n                if (match)\n                {\n                    // Normalize hex string, remove 0x or # prefix\n                    value = `#${match[2]}`;\n                }\n            }\n\n            const color = colord(value as AnyColor);\n\n            if (color.isValid())\n            {\n                ({ r, g, b, a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n\n        // Cache normalized values for rgba and hex integer\n        if (r !== undefined)\n        {\n            this._components[0] = r as number;\n            this._components[1] = g as number;\n            this._components[2] = b as number;\n            this._components[3] = a as number;\n            this._refreshInt();\n        }\n        else\n        {\n            throw new Error(`Unable to convert color ${value}`);\n        }\n    }\n\n    /** Refresh the internal color rgb number */\n    private _refreshInt(): void\n    {\n        // Clamp values to 0 - 1\n        this._clamp(this._components);\n\n        const [r, g, b] = this._components;\n\n        this._int = ((r * 255) << 16) + ((g * 255) << 8) + ((b * 255) | 0);\n    }\n\n    /**\n     * Clamps values to a range. Will override original values\n     * @param value - Value(s) to clamp\n     * @param min - Minimum value\n     * @param max - Maximum value\n     */\n    private _clamp<T extends number | number[] | ColorSourceTypedArray>(value: T, min = 0, max = 1): T\n    {\n        if (typeof value === 'number')\n        {\n            return Math.min(Math.max(value, min), max) as T;\n        }\n\n        value.forEach((v, i) =>\n        {\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n\n        return value;\n    }\n\n    /**\n     * Check if the value is a color-like object\n     * @param value - Value to check\n     * @returns True if the value is a color-like object\n     * @static\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.isColorLike('white'); // returns true\n     * Color.isColorLike(0xffffff); // returns true\n     * Color.isColorLike([1, 1, 1]); // returns true\n     */\n    public static isColorLike(value: unknown): value is ColorSource\n    {\n        return (\n            typeof value === 'number'\n            || typeof value === 'string'\n            || value instanceof Number\n            || value instanceof Color\n            || Array.isArray(value)\n            || value instanceof Uint8Array\n            || value instanceof Uint8ClampedArray\n            || value instanceof Float32Array\n            || ((value as RgbColor).r !== undefined\n                && (value as RgbColor).g !== undefined\n                && (value as RgbColor).b !== undefined)\n            || ((value as RgbaColor).r !== undefined\n                && (value as RgbaColor).g !== undefined\n                && (value as RgbaColor).b !== undefined\n                && (value as RgbaColor).a !== undefined)\n            || ((value as HslColor).h !== undefined\n                && (value as HslColor).s !== undefined\n                && (value as HslColor).l !== undefined)\n            || ((value as HslaColor).h !== undefined\n                && (value as HslaColor).s !== undefined\n                && (value as HslaColor).l !== undefined\n                && (value as HslaColor).a !== undefined)\n            || ((value as HsvColor).h !== undefined\n                && (value as HsvColor).s !== undefined\n                && (value as HsvColor).v !== undefined)\n            || ((value as HsvaColor).h !== undefined\n                && (value as HsvaColor).s !== undefined\n                && (value as HsvaColor).v !== undefined\n                && (value as HsvaColor).a !== undefined)\n        );\n    }\n}\n","var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n","export default function(e,f){var a={white:\"#ffffff\",bisque:\"#ffe4c4\",blue:\"#0000ff\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",azure:\"#f0ffff\",whitesmoke:\"#f5f5f5\",papayawhip:\"#ffefd5\",plum:\"#dda0dd\",blanchedalmond:\"#ffebcd\",black:\"#000000\",gold:\"#ffd700\",goldenrod:\"#daa520\",gainsboro:\"#dcdcdc\",cornsilk:\"#fff8dc\",cornflowerblue:\"#6495ed\",burlywood:\"#deb887\",aquamarine:\"#7fffd4\",beige:\"#f5f5dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkkhaki:\"#bdb76b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkgrey:\"#a9a9a9\",peachpuff:\"#ffdab9\",darkmagenta:\"#8b008b\",darkred:\"#8b0000\",darkorchid:\"#9932cc\",darkorange:\"#ff8c00\",darkslateblue:\"#483d8b\",gray:\"#808080\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",wheat:\"#f5deb3\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",ghostwhite:\"#f8f8ff\",darkviolet:\"#9400d3\",magenta:\"#ff00ff\",green:\"#008000\",dodgerblue:\"#1e90ff\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",blueviolet:\"#8a2be2\",forestgreen:\"#228b22\",lawngreen:\"#7cfc00\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",fuchsia:\"#ff00ff\",brown:\"#a52a2a\",maroon:\"#800000\",mediumblue:\"#0000cd\",lightcoral:\"#f08080\",darkturquoise:\"#00ced1\",lightcyan:\"#e0ffff\",ivory:\"#fffff0\",lightyellow:\"#ffffe0\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",linen:\"#faf0e6\",mediumaquamarine:\"#66cdaa\",lemonchiffon:\"#fffacd\",lime:\"#00ff00\",khaki:\"#f0e68c\",mediumseagreen:\"#3cb371\",limegreen:\"#32cd32\",mediumspringgreen:\"#00fa9a\",lightskyblue:\"#87cefa\",lightblue:\"#add8e6\",midnightblue:\"#191970\",lightpink:\"#ffb6c1\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",mintcream:\"#f5fffa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",navajowhite:\"#ffdead\",navy:\"#000080\",mediumvioletred:\"#c71585\",powderblue:\"#b0e0e6\",palegoldenrod:\"#eee8aa\",oldlace:\"#fdf5e6\",paleturquoise:\"#afeeee\",mediumturquoise:\"#48d1cc\",mediumorchid:\"#ba55d3\",rebeccapurple:\"#663399\",lightsteelblue:\"#b0c4de\",mediumslateblue:\"#7b68ee\",thistle:\"#d8bfd8\",tan:\"#d2b48c\",orchid:\"#da70d6\",mediumpurple:\"#9370db\",purple:\"#800080\",pink:\"#ffc0cb\",skyblue:\"#87ceeb\",springgreen:\"#00ff7f\",palegreen:\"#98fb98\",red:\"#ff0000\",yellow:\"#ffff00\",slateblue:\"#6a5acd\",lavenderblush:\"#fff0f5\",peru:\"#cd853f\",palevioletred:\"#db7093\",violet:\"#ee82ee\",teal:\"#008080\",slategray:\"#708090\",slategrey:\"#708090\",aliceblue:\"#f0f8ff\",darkseagreen:\"#8fbc8f\",darkolivegreen:\"#556b2f\",greenyellow:\"#adff2f\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",tomato:\"#ff6347\",silver:\"#c0c0c0\",sienna:\"#a0522d\",lavender:\"#e6e6fa\",lightgreen:\"#90ee90\",orange:\"#ffa500\",orangered:\"#ff4500\",steelblue:\"#4682b4\",royalblue:\"#4169e1\",turquoise:\"#40e0d0\",yellowgreen:\"#9acd32\",salmon:\"#fa8072\",saddlebrown:\"#8b4513\",sandybrown:\"#f4a460\",rosybrown:\"#bc8f8f\",darksalmon:\"#e9967a\",lightgoldenrodyellow:\"#fafad2\",snow:\"#fffafa\",lightgrey:\"#d3d3d3\",lightgray:\"#d3d3d3\",dimgray:\"#696969\",dimgrey:\"#696969\",olivedrab:\"#6b8e23\",olive:\"#808000\"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return\"transparent\";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b=\"black\";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d=\"transparent\"===r?\"#0000\":a[r];return d?new e(d).toRgb():null},\"name\"])}\n","\"use strict\";\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\nexport { cullingMixin };\n//# sourceMappingURL=cullingMixin.mjs.map\n","import type { Rectangle } from '../maths/shapes/Rectangle';\n\nexport interface CullingMixinConstructor\n{\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     * @memberof scene.Container#\n     */\n    cullArea: Rectangle,\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     * @default false\n     * @memberof scene.Container#\n     */\n    cullable: boolean,\n    /**\n     * Determines if the children to the container can be culled\n     * Setting this to false allows PixiJS to bypass a recursive culling function\n     * Which can help to optimize very complex scenes\n     * @default true\n     * @memberof scene.Container#\n     */\n    cullableChildren: boolean,\n}\n\nexport const cullingMixin: CullingMixinConstructor = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true,\n};\n","import { Pool } from './Pool.mjs';\n\n\"use strict\";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new Pool(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\nexport { BigPool, PoolGroupClass };\n//# sourceMappingURL=PoolGroup.mjs.map\n","import { Pool } from './Pool';\n\nimport type { PoolItem, PoolItemConstructor } from './Pool';\n\n/**\n * A type alias for a constructor of a Pool.\n * @template T The type of items in the pool. Must extend PoolItem.\n * @memberof utils\n */\nexport type PoolConstructor<T extends PoolItem> = new () => Pool<T>;\n\n/**\n * A group of pools that can be used to store objects of different types.\n * @memberof utils\n */\nexport class PoolGroupClass\n{\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    private readonly _poolsByClass: Map<PoolItemConstructor<PoolItem>, Pool<PoolItem>> = new Map();\n\n    /**\n     * Prepopulates a specific pool with a given number of items.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {number} total - The number of items to add to the pool.\n     */\n    public prepopulate<T extends PoolItem>(Class: PoolItemConstructor<T>, total: number): void\n    {\n        const classPool = this.getPool(Class);\n\n        classPool.prepopulate(total);\n    }\n\n    /**\n     * Gets an item from a specific pool.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get<T extends PoolItem>(Class: PoolItemConstructor<T>, data?: unknown): T\n    {\n        const pool = this.getPool(Class);\n\n        return pool.get(data) as T;\n    }\n\n    /**\n     * Returns an item to its respective pool.\n     * @param {PoolItem} item - The item to return to the pool.\n     */\n    public return(item: PoolItem): void\n    {\n        const pool = this.getPool(item.constructor as PoolItemConstructor<PoolItem>);\n\n        pool.return(item);\n    }\n\n    /**\n     * Gets a specific pool based on the class type.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n     * @returns {Pool<T>} The pool of the given class type.\n     */\n    public getPool<T extends PoolItem>(ClassType: PoolItemConstructor<T>): Pool<T>\n    {\n        if (!this._poolsByClass.has(ClassType))\n        {\n            this._poolsByClass.set(ClassType, new Pool(ClassType));\n        }\n\n        return this._poolsByClass.get(ClassType) as Pool<T>;\n    }\n\n    /** gets the usage stats of each pool in the system */\n    public stats(): Record<string, {free: number; used: number; size: number}>\n    {\n        const stats = {} as Record<string, {free: number; used: number; size: number}>;\n\n        this._poolsByClass.forEach((pool) =>\n        {\n            // TODO: maybe we should allow the name to be set when `createEntity` is called\n            const name = stats[pool._classType.name]\n                ? pool._classType.name + (pool._classType as any).ID : pool._classType.name;\n\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize,\n            };\n        });\n\n        return stats;\n    }\n}\n\nexport const BigPool = new PoolGroupClass();\n","\"use strict\";\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n  /** clears the pool - mainly used for debugging! */\n  clear() {\n    this._pool.length = 0;\n    this._index = 0;\n  }\n}\n\nexport { Pool };\n//# sourceMappingURL=Pool.mjs.map\n","/**\n * A generic class for managing a pool of items.\n * @template T The type of items in the pool. Must implement {@link utils.PoolItem}.\n * @memberof utils\n */\nexport class Pool<T extends PoolItem>\n{\n    public readonly _classType: PoolItemConstructor<T>;\n    private readonly _pool: T[] = [];\n    private _count = 0;\n    private _index = 0;\n\n    /**\n     * Constructs a new Pool.\n     * @param ClassType - The constructor of the items in the pool.\n     * @param {number} [initialSize] - The initial size of the pool.\n     */\n    constructor(ClassType: PoolItemConstructor<T>, initialSize?: number)\n    {\n        this._classType = ClassType;\n\n        if (initialSize)\n        {\n            this.prepopulate(initialSize);\n        }\n    }\n\n    /**\n     * Prepopulates the pool with a given number of items.\n     * @param total - The number of items to add to the pool.\n     */\n    public prepopulate(total: number): void\n    {\n        for (let i = 0; i < total; i++)\n        {\n            this._pool[this._index++] = new this._classType();\n        }\n\n        this._count += total;\n    }\n\n    /**\n     * Gets an item from the pool. Calls the item's `init` method if it exists.\n     * If there are no items left in the pool, a new one will be created.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get(data?: unknown): T\n    {\n        let item;\n\n        if (this._index > 0)\n        {\n            item = this._pool[--this._index];\n        }\n        else\n        {\n            item = new this._classType();\n        }\n\n        item.init?.(data);\n\n        return item;\n    }\n\n    /**\n     * Returns an item to the pool. Calls the item's `reset` method if it exists.\n     * @param {T} item - The item to return to the pool.\n     */\n    public return(item: T): void\n    {\n        item.reset?.();\n\n        this._pool[this._index++] = item;\n    }\n\n    /**\n     * Gets the number of items in the pool.\n     * @readonly\n     * @member {number}\n     */\n    get totalSize(): number\n    {\n        return this._count;\n    }\n\n    /**\n     * Gets the number of items in the pool that are free to use without needing to create more.\n     * @readonly\n     * @member {number}\n     */\n    get totalFree(): number\n    {\n        return this._index;\n    }\n\n    /**\n     * Gets the number of items in the pool that are currently in use.\n     * @readonly\n     * @member {number}\n     */\n    get totalUsed(): number\n    {\n        return this._count - this._index;\n    }\n\n    /** clears the pool - mainly used for debugging! */\n    public clear()\n    {\n        this._pool.length = 0;\n        this._index = 0;\n    }\n}\n\n/**\n * An object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItem = {\n    init?: (data?: any) => void;\n    reset?: () => void;\n    [key: string]: any;\n};\n\n/**\n * The constructor of an object that can be stored in a {@link utils.Pool}.\n * @typeParam K - The type of the object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItemConstructor<K extends PoolItem> = new () => K;\n","import { deprecation } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst cacheAsTextureMixin = {\n  /**\n   * Is this container cached as a texture?\n   * @readonly\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  get isCachedAsTexture() {\n    return !!this.renderGroup?.isCachedAsTexture;\n  },\n  cacheAsTexture(val) {\n    if (typeof val === \"boolean\" && val === false) {\n      this.disableRenderGroup();\n    } else {\n      this.enableRenderGroup();\n      this.renderGroup.enableCacheAsTexture(val === true ? {} : val);\n    }\n  },\n  /**\n   * Updates the cached texture. Will flag that this container's cached texture needs to be redrawn.\n   * This will happen on the next render.\n   * @memberof scene.Container#\n   */\n  updateCacheTexture() {\n    this.renderGroup?.updateCacheTexture();\n  },\n  /**\n   * Allows backwards compatibility with pixi.js below version v8. Use `cacheAsTexture` instead.\n   * @deprecated\n   */\n  get cacheAsBitmap() {\n    return this.isCachedAsTexture;\n  },\n  /**\n   * @deprecated\n   */\n  set cacheAsBitmap(val) {\n    deprecation(\"v8.6.0\", \"cacheAsBitmap is deprecated, use cacheAsTexture instead.\");\n    this.cacheAsTexture(val);\n  }\n};\n\nexport { cacheAsTextureMixin };\n//# sourceMappingURL=cacheAsTextureMixin.mjs.map\n","import { deprecation } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\nimport type { CacheAsTextureOptions } from '../RenderGroup';\n\nexport interface CacheAsTextureMixinConstructor\n{\n    cacheAsTexture?: (val: boolean | CacheAsTextureOptions) => void;\n}\n\nexport interface CacheAsTextureMixin extends Required<CacheAsTextureMixinConstructor>\n{\n    /**\n     * Caches this container as a texture. This allows the container to be rendered as a single texture,\n     * which can improve performance for complex static containers.\n     * @param val - If true, enables caching with default options. If false, disables caching.\n     * Can also pass options object to configure caching behavior.\n     * @memberof scene.Container#\n     */\n    cacheAsTexture: (val: boolean | CacheAsTextureOptions) => void;\n\n    /**\n     * Updates the cached texture of this container. This will flag the container's cached texture\n     * to be redrawn on the next render.\n     * @memberof scene.Container#\n     */\n    updateCacheTexture: () => void;\n\n    /**\n     * Legacy property for backwards compatibility with PixiJS v7 and below.\n     * Use `cacheAsTexture` instead.\n     * @deprecated Since PixiJS v8\n     * @memberof scene.Container#\n     */\n    cacheAsBitmap: boolean;\n\n    /**\n     * Whether this container is currently cached as a texture.\n     * @readonly\n     * @memberof scene.Container#\n     */\n    readonly isCachedAsTexture: boolean;\n}\n\nexport const cacheAsTextureMixin: Partial<Container> = {\n    /**\n     * Is this container cached as a texture?\n     * @readonly\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    get isCachedAsTexture(): boolean\n    {\n        return !!this.renderGroup?.isCachedAsTexture;\n    },\n\n    cacheAsTexture(val: boolean | CacheAsTextureOptions): void\n    {\n        if (typeof val === 'boolean' && val === false)\n        {\n            this.disableRenderGroup();\n        }\n        else\n        {\n            this.enableRenderGroup();\n            this.renderGroup.enableCacheAsTexture(val === true ? {} : val);\n        }\n    },\n\n    /**\n     * Updates the cached texture. Will flag that this container's cached texture needs to be redrawn.\n     * This will happen on the next render.\n     * @memberof scene.Container#\n     */\n    updateCacheTexture(): void\n    {\n        this.renderGroup?.updateCacheTexture();\n    },\n\n    /**\n     * Allows backwards compatibility with pixi.js below version v8. Use `cacheAsTexture` instead.\n     * @deprecated\n     */\n    get cacheAsBitmap(): boolean\n    {\n        return this.isCachedAsTexture;\n    },\n\n    /**\n     * @deprecated\n     */\n    set cacheAsBitmap(val: boolean)\n    {\n        // #if _DEBUG\n        deprecation('v8.6.0', 'cacheAsBitmap is deprecated, use cacheAsTexture instead.');\n        // #endif\n        this.cacheAsTexture(val);\n    },\n} as Container;\n","import { removeItems } from '../../../utils/data/removeItems.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        removed.push(child);\n        child.parent = null;\n      }\n      removeItems(this.children, beginIndex, end);\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.removeChildren(removed);\n      }\n      for (let i = 0; i < removed.length; ++i) {\n        this.emit(\"childRemoved\", removed[i], this, i);\n        removed[i].emit(\"removed\", this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error(\"The supplied Container must be a child of the caller\");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit(\"childAdded\", child, this, index);\n    child.emit(\"added\", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   * @memberof scene.Container#\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._didContainerChangeTick++;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  },\n  /**\n   * Reparent the child to this container, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @returns The first child that was reparented.\n   * @memberof scene.Container#\n   */\n  reparentChild(...child) {\n    if (child.length === 1) {\n      return this.reparentChildAt(child[0], this.children.length);\n    }\n    child.forEach((c) => this.reparentChildAt(c, this.children.length));\n    return child[0];\n  },\n  /**\n   * Reparent the child to this container at the specified index, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @param index - The index to reparent the child to\n   * @memberof scene.Container#\n   */\n  reparentChildAt(child, index) {\n    if (child.parent === this) {\n      this.setChildIndex(child, index);\n      return child;\n    }\n    const childMat = child.worldTransform.clone();\n    child.removeFromParent();\n    this.addChildAt(child, index);\n    const newMatrix = this.worldTransform.clone();\n    newMatrix.invert();\n    childMat.prepend(newMatrix);\n    child.setFromMatrix(childMat);\n    return child;\n  }\n};\n\nexport { childrenHelperMixin };\n//# sourceMappingURL=childrenHelperMixin.mjs.map\n","import { removeItems } from '../../../utils/data/removeItems';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { IRenderLayer } from '../../layers/RenderLayer';\nimport type { Container, ContainerChild } from '../Container';\n\nexport interface ChildrenHelperMixin<C = ContainerChild>\n{\n    allowChildren: boolean;\n    addChild<U extends(C | IRenderLayer)[]>(...children: U): U[0];\n    removeChild<U extends(C | IRenderLayer)[]>(...children: U): U[0];\n    removeChildren(beginIndex?: number, endIndex?: number): C[];\n    removeChildAt<U extends(C | IRenderLayer)>(index: number): U;\n    getChildAt<U extends(C | IRenderLayer)>(index: number): U;\n    setChildIndex(child: C | IRenderLayer, index: number): void;\n    getChildIndex(child: C | IRenderLayer): number;\n    addChildAt<U extends(C | IRenderLayer)>(child: U, index: number): U;\n    swapChildren<U extends(C | IRenderLayer)>(child: U, child2: U): void;\n    removeFromParent(): void;\n\n    reparentChild<U extends C[]>(...child: U): U[0];\n    reparentChildAt<U extends C>(child: U, index: number): U;\n}\n\nexport const childrenHelperMixin: Partial<Container> = {\n\n    allowChildren: true,\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed children\n     * @memberof scene.Container#\n     */\n    removeChildren(beginIndex = 0, endIndex?: number): ContainerChild[]\n    {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed: ContainerChild[] = [];\n\n        if (range > 0 && range <= end)\n        {\n            for (let i = end - 1; i >= beginIndex; i--)\n            {\n                const child = this.children[i];\n\n                if (!child) continue;\n                removed.push(child);\n                child.parent = null;\n            }\n\n            removeItems(this.children, beginIndex, end);\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.removeChildren(removed);\n            }\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                this.emit('childRemoved', removed[i], this, i);\n                removed[i].emit('removed', this);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return removed;\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    },\n\n    /**\n     * Removes a child from the specified index position.\n     * @param index - The index to get the child from\n     * @returns The child that was removed.\n     * @memberof scene.Container#\n     */\n    removeChildAt<U extends(ContainerChild | IRenderLayer)>(index: number): U\n    {\n        const child = this.getChildAt<U>(index);\n\n        return this.removeChild(child);\n    },\n\n    /**\n     * Returns the child at the specified index\n     * @param index - The index to get the child at\n     * @returns - The child at the given index, if any.\n     * @memberof scene.Container#\n     */\n    getChildAt<U extends(ContainerChild | IRenderLayer)>(index: number): U\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index] as U;\n    },\n\n    /**\n     * Changes the position of an existing child in the container\n     * @param child - The child Container instance for which you want to change the index number\n     * @param index - The resulting index number for the child container\n     * @memberof scene.Container#\n     */\n    setChildIndex(child: ContainerChild | IRenderLayer, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        this.getChildIndex(child); // check if child exists\n        this.addChildAt(child, index);\n    },\n\n    /**\n     * Returns the index position of a child Container instance\n     * @param child - The Container instance to identify\n     * @returns - The index position of the child container to identify\n     * @memberof scene.Container#\n     */\n    getChildIndex(child: ContainerChild | IRenderLayer): number\n    {\n        const index = this.children.indexOf(child as ContainerChild);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied Container must be a child of the caller');\n        }\n\n        return index;\n    },\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the child is already in this container, it will be moved to the specified index.\n     * @param {Container} child - The child to add.\n     * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n     * @returns {Container} The child that was added.\n     * @memberof scene.Container#\n     */\n    addChildAt<U extends(ContainerChild | IRenderLayer)>(child: U, index: number): U\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChildAt: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        const { children } = this;\n\n        if (index < 0 || index > children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        }\n\n        // TODO - check if child is already in the list?\n        // we should be able to optimise this!\n\n        if (child.parent)\n        {\n            const currentIndex = child.parent.children.indexOf(child as ContainerChild);\n\n            // If this child is in the container and in the same position, do nothing\n            if (child.parent === this && currentIndex === index)\n            {\n                return child;\n            }\n\n            if (currentIndex !== -1)\n            {\n                child.parent.children.splice(currentIndex, 1);\n            }\n        }\n\n        if (index === children.length)\n        {\n            children.push(child as ContainerChild);\n        }\n        else\n        {\n            children.splice(index, 0, child as ContainerChild);\n        }\n\n        child.parent = this;\n        child.didChange = true;\n        child._updateFlags = 0b1111;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child as ContainerChild);\n        }\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        this.emit('childAdded', child as ContainerChild, this, index);\n        child.emit('added', this);\n\n        return child;\n    },\n    /**\n     * Swaps the position of 2 Containers within this container.\n     * @param child - First container to swap\n     * @param child2 - Second container to swap\n     * @memberof scene.Container#\n     */\n    swapChildren<U extends(ContainerChild | IRenderLayer)>(child: U, child2: U): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2 as ContainerChild;\n        this.children[index2] = child as ContainerChild;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n\n        this._didContainerChangeTick++;\n    },\n    /**\n     * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n     * @memberof scene.Container#\n     */\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    },\n\n    /**\n     * Reparent the child to this container, keeping the same worldTransform.\n     * @param child - The child to reparent\n     * @returns The first child that was reparented.\n     * @memberof scene.Container#\n     */\n    reparentChild<U extends ContainerChild[]>(...child: U): U[0]\n    {\n        if (child.length === 1)\n        {\n            return this.reparentChildAt(child[0], this.children.length);\n        }\n\n        child.forEach((c) => this.reparentChildAt(c, this.children.length));\n\n        return child[0];\n    },\n\n    /**\n     * Reparent the child to this container at the specified index, keeping the same worldTransform.\n     * @param child - The child to reparent\n     * @param index - The index to reparent the child to\n     * @memberof scene.Container#\n     */\n    reparentChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        if (child.parent === this)\n        {\n            this.setChildIndex(child, index);\n\n            return child;\n        }\n\n        const childMat = child.worldTransform.clone();\n\n        child.removeFromParent();\n        this.addChildAt(child, index);\n\n        const newMatrix = this.worldTransform.clone();\n\n        newMatrix.invert();\n        childMat.prepend(newMatrix);\n\n        child.setFromMatrix(childMat);\n\n        return child;\n    }\n} as Container;\n","\"use strict\";\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\nexport { removeItems };\n//# sourceMappingURL=removeItems.mjs.map\n","/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @memberof utils\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nexport function removeItems(arr: any[], startIdx: number, removeCount: number): void\n{\n    const length = arr.length;\n    let i;\n\n    if (startIdx >= length || removeCount === 0)\n    {\n        return;\n    }\n\n    removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);\n\n    const len = length - removeCount;\n\n    for (i = startIdx; i < len; ++i)\n    {\n        arr[i] = arr[i + removeCount];\n    }\n\n    arr.length = len;\n}\n","\"use strict\";\nconst collectRenderablesMixin = {\n  /**\n   * Main method to collect renderables from the container and its children.\n   * It checks the container's properties to decide whether to use a simple or advanced collection method.\n   * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n   * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n   * @param {IRenderLayer} currentLayer - The current render layer being processed.\n   * @memberof scene.Container#\n   */\n  collectRenderables(instructionSet, renderer, currentLayer) {\n    if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild)\n      return;\n    if (this.sortableChildren) {\n      this.sortChildren();\n    }\n    if (this.isSimple) {\n      this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n    } else if (this.renderGroup) {\n      renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);\n    } else {\n      this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);\n    }\n  },\n  /**\n   * Simple method for collecting renderables from the container's children.\n   * This method is efficient and used when the container is marked as simple.\n   * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n   * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n   * @param {IRenderLayer} currentLayer - The current render layer being processed.\n   * @memberof scene.Container#\n   */\n  collectRenderablesSimple(instructionSet, renderer, currentLayer) {\n    const children = this.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      children[i].collectRenderables(instructionSet, renderer, currentLayer);\n    }\n  },\n  /**\n   * Advanced method for collecting renderables, which handles additional effects.\n   * This method is used when the container has complex processing needs.\n   * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n   * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n   * @param {IRenderLayer} currentLayer - The current render layer being processed.\n   * @memberof scene.Container#\n   */\n  collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {\n    const { renderPipes } = renderer;\n    for (let i = 0; i < this.effects.length; i++) {\n      const effect = this.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.push(effect, this, instructionSet);\n    }\n    this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n    for (let i = this.effects.length - 1; i >= 0; i--) {\n      const effect = this.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.pop(effect, this, instructionSet);\n    }\n  }\n};\n\nexport { collectRenderablesMixin };\n//# sourceMappingURL=collectRenderablesMixin.mjs.map\n","import { type InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer, type RenderPipes } from '../../../rendering/renderers/types';\nimport { type IRenderLayer } from '../../layers/RenderLayer';\n\nimport type { Container } from '../Container';\n\n/**\n * The CollectRenderablesMixin interface defines methods for collecting renderable objects\n * from a container and its children. These methods add the renderables to an instruction set,\n * which is used by the renderer to process and display the scene.\n */\nexport interface CollectRenderablesMixin\n{\n    /**\n     * Collects all renderables from the container and its children, adding them to the instruction set.\n     * This method decides whether to use a simple or advanced collection method based on the container's properties.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: IRenderLayer): void;\n\n    /**\n     * Collects renderables using a simple method, suitable for containers marked as simple.\n     * This method iterates over the container's children and adds their renderables to the instruction set.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderablesSimple(instructionSet: InstructionSet, renderer: Renderer, currentLayer: IRenderLayer): void;\n\n    /**\n     * Collects renderables using an advanced method, suitable for containers with complex processing needs.\n     * This method handles additional effects and transformations that may be applied to the renderables.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void;\n}\n\n/**\n * The collectRenderablesMixin provides implementations for the methods defined in the CollectRenderablesMixin interface.\n * It includes logic to determine the appropriate method for collecting renderables based on the container's properties.\n */\nexport const collectRenderablesMixin: Partial<Container> = {\n\n    /**\n     * Main method to collect renderables from the container and its children.\n     * It checks the container's properties to decide whether to use a simple or advanced collection method.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: IRenderLayer): void\n    {\n        // Skip processing if the container is not in the current render layer or is not fully visible.\n        if ((this.parentRenderLayer && this.parentRenderLayer !== currentLayer)\n            || this.globalDisplayStatus < 0b111 || !this.includeInBuild) return;\n\n        // Sort children if the container has sortable children.\n        if (this.sortableChildren)\n        {\n            this.sortChildren();\n        }\n\n        // Choose the appropriate method for collecting renderables based on the container's properties.\n        if (this.isSimple)\n        {\n            this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n        }\n        else if (this.renderGroup)\n        {\n            renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);\n        }\n        else\n        {\n            this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);\n        }\n    },\n\n    /**\n     * Simple method for collecting renderables from the container's children.\n     * This method is efficient and used when the container is marked as simple.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const children = this.children;\n        const length = children.length;\n\n        // Iterate over each child and collect their renderables.\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n    },\n\n    /**\n     * Advanced method for collecting renderables, which handles additional effects.\n     * This method is used when the container has complex processing needs.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const { renderPipes } = renderer;\n\n        // Apply each effect to the renderables before collecting them.\n        for (let i = 0; i < this.effects.length; i++)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.push(effect, this, instructionSet);\n        }\n\n        // Collect renderables using the simple method after applying effects.\n        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n\n        // Remove effects from the renderables after collection, processing in reverse order.\n        for (let i = this.effects.length - 1; i >= 0; i--)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.pop(effect, this, instructionSet);\n        }\n    }\n} as Container;\n","import { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager.mjs';\n\n\"use strict\";\nconst effectsMixin = {\n  _maskEffect: null,\n  _maskOptions: {\n    inverse: false\n  },\n  _filterEffect: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  _markStructureAsChanged() {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    this._markStructureAsChanged();\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    this._markStructureAsChanged();\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    const effect = this._maskEffect;\n    if (effect?.mask === value)\n      return;\n    if (effect) {\n      this.removeEffect(effect);\n      MaskEffectManager.returnMaskEffect(effect);\n      this._maskEffect = null;\n    }\n    if (value === null || value === void 0)\n      return;\n    this._maskEffect = MaskEffectManager.getMaskEffect(value);\n    this.addEffect(this._maskEffect);\n  },\n  /**\n   * Used to set mask and control mask options.\n   * @param options\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.setMask({\n   *     mask: graphics,\n   *     inverse: true,\n   * });\n   * @memberof scene.Container#\n   */\n  setMask(options) {\n    this._maskOptions = {\n      ...this._maskOptions,\n      ...options\n    };\n    if (options.mask) {\n      this.mask = options.mask;\n    }\n    this._markStructureAsChanged();\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._maskEffect?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    const effect = this._filterEffect || (this._filterEffect = new FilterEffect());\n    value = value;\n    const hasFilters = value?.length > 0;\n    const hadFilters = effect.filters?.length > 0;\n    const didChange = hasFilters !== hadFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    effect.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        this.addEffect(effect);\n      } else {\n        this.removeEffect(effect);\n        effect.filters = value ?? null;\n      }\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filterEffect?.filters;\n  },\n  set filterArea(value) {\n    this._filterEffect || (this._filterEffect = new FilterEffect());\n    this._filterEffect.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filterEffect?.filterArea;\n  }\n};\n\nexport { effectsMixin };\n//# sourceMappingURL=effectsMixin.mjs.map\n","import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { MaskEffect } from '../../../rendering/mask/MaskEffectManager';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\nexport interface EffectsMixinConstructor\n{\n    mask?: Mask;\n    setMask?: (options: Partial<MaskOptionsAndMask>) => void;\n    filters?: Filter | Filter[];\n}\n\nexport type Mask = number | Container | null;\n\nexport interface MaskOptions\n{\n    inverse: boolean;\n}\n\nexport interface MaskOptionsAndMask extends MaskOptions\n{\n    mask: Mask;\n}\n\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    _maskEffect?: MaskEffect;\n    _maskOptions?: MaskOptions;\n    _filterEffect?: FilterEffect,\n\n    filterArea?: Rectangle,\n    effects?: Effect[];\n\n    _markStructureAsChanged(): void;\n    addEffect(effect: Effect): void;\n    removeEffect(effect: Effect): void;\n}\n\nexport const effectsMixin: Partial<Container> = {\n    _maskEffect: null,\n    _maskOptions: {\n        inverse: false,\n    },\n    _filterEffect: null,\n\n    /**\n     * @todo Needs docs.\n     * @memberof scene.Container#\n     * @type {Array<Effect>}\n     */\n    effects: [],\n\n    _markStructureAsChanged()\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to add.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        this._markStructureAsChanged();\n\n        // if (this.renderGroup)\n        // {\n        //     this.renderGroup.structureDidChange = true;\n        // }\n\n        this._updateIsSimple();\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to remove.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        this._markStructureAsChanged();\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: Mask)\n    {\n        const effect = this._maskEffect;\n\n        if (effect?.mask === value) return;\n\n        if (effect)\n        {\n            this.removeEffect(effect);\n\n            MaskEffectManager.returnMaskEffect(effect);\n\n            this._maskEffect = null;\n        }\n\n        if (value === null || value === undefined) return;\n\n        this._maskEffect = MaskEffectManager.getMaskEffect(value);\n\n        this.addEffect(this._maskEffect);\n    },\n\n    /**\n     * Used to set mask and control mask options.\n     * @param options\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: true,\n     * });\n     * @memberof scene.Container#\n     */\n    setMask(options: Partial<MaskOptionsAndMask>)\n    {\n        this._maskOptions = {\n            ...this._maskOptions,\n            ...options,\n        };\n\n        if (options.mask)\n        {\n            this.mask = options.mask;\n        }\n\n        this._markStructureAsChanged();\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @memberof scene.Container#\n     */\n    get mask(): unknown\n    {\n        return this._maskEffect?.mask;\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        const effect = this._filterEffect ||= new FilterEffect();\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n\n        const didChange = hasFilters !== hadFilters;\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        effect.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                this.addEffect(effect);\n            }\n            else\n            {\n                this.removeEffect(effect);\n\n                // sets the empty array...\n                effect.filters = value ?? null;\n            }\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     * @memberof scene.Container#\n     */\n    get filters(): readonly Filter[]\n    {\n        return this._filterEffect?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filterEffect ||= new FilterEffect();\n\n        this._filterEffect.filterArea = value;\n    },\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     * @memberof scene.Container#\n     */\n    get filterArea(): Rectangle\n    {\n        return this._filterEffect?.filterArea;\n    },\n\n} as Container;\n","\"use strict\";\nclass FilterEffect {\n  constructor() {\n    /** the pipe that knows how to handle this effect */\n    this.pipe = \"filter\";\n    /** the priority of this effect */\n    this.priority = 1;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\nexport { FilterEffect };\n//# sourceMappingURL=FilterEffect.mjs.map\n","import type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { Effect } from '../scene/container/Effect';\nimport type { Filter } from './Filter';\n\n/**\n * A filter effect is an effect that can be applied to a container that involves applying special pixel effects\n * to that container as it is rendered. Used internally when the filters property is modified on a container\n */\nexport class FilterEffect implements Effect\n{\n    /** read only filters array - to modify, set it again! */\n    public filters: readonly Filter[];\n    /**\n     * If specified, rather than calculating the bounds of the container that the filter\n     * will apply to, we use this rect instead. This is a local rect - so will have the containers transform\n     * applied to it\n     */\n    public filterArea?: Rectangle;\n\n    /** the pipe that knows how to handle this effect */\n    public pipe = 'filter';\n    /** the priority of this effect */\n    public priority = 1;\n\n    public destroy(): void\n    {\n        for (let i = 0; i < this.filters.length; i++)\n        {\n            this.filters[i].destroy();\n        }\n\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n","import { extensions, ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\n\n\"use strict\";\nclass MaskEffectManagerClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return BigPool.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    BigPool.return(effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nextensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n\nexport { MaskEffectManager, MaskEffectManagerClass };\n//# sourceMappingURL=MaskEffectManager.mjs.map\n","import { extensions, ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\n\nimport type { Effect, EffectConstructor } from '../../scene/container/Effect';\nimport type { PoolItem, PoolItemConstructor } from '../../utils/pool/Pool';\n\ninterface MaskConversionTest\n{\n    test: (item: any) => boolean;\n    maskClass: new (item: any) => Effect & PoolItem;\n}\n\nexport type MaskEffect = {mask: unknown} & Effect;\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @memberof rendering\n * @ignore\n */\nexport class MaskEffectManagerClass\n{\n    /**\n     * @private\n     */\n    public readonly _effectClasses: EffectConstructor[] = [];\n    private readonly _tests: MaskConversionTest[] = [];\n    private _initialized = false;\n\n    public init()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n\n        this._effectClasses.forEach((test) =>\n        {\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n\n    public add(test: MaskConversionTest)\n    {\n        this._tests.push(test);\n    }\n\n    public getMaskEffect(item: any): MaskEffect\n    {\n        if (!this._initialized) this.init();\n\n        for (let i = 0; i < this._tests.length; i++)\n        {\n            const test = this._tests[i];\n\n            if (test.test(item))\n            {\n                return BigPool.get(test.maskClass as PoolItemConstructor<MaskEffect & PoolItem>, item);\n            }\n        }\n\n        return item;\n    }\n\n    public returnMaskEffect(effect: Effect & PoolItem)\n    {\n        BigPool.return(effect);\n    }\n}\n\nexport const MaskEffectManager = new MaskEffectManagerClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    return this.label;\n  },\n  set name(value) {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\nexport { findMixin };\n//# sourceMappingURL=findMixin.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\nexport interface FindMixinConstructor\n{\n    label?: string;\n}\nexport interface FindMixin extends Required<FindMixinConstructor>\n{\n    /**\n     * @deprecated since 8.0.0\n     * @see Container#label\n     */\n    name: string;\n    getChildByName(label: RegExp | string, deep?: boolean): Container | null;\n    getChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n    getChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n\nexport const findMixin: Partial<Container> = {\n    /**\n     * The instance label of the object.\n     * @memberof scene.Container#\n     * @member {string} label\n     */\n    label: null,\n\n    /**\n     * The instance name of the object.\n     * @deprecated since 8.0.0\n     * @see scene.Container#label\n     * @member {string} name\n     * @memberof scene.Container#\n     */\n    get name(): string\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        return this.label;\n    },\n    set name(value: string)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        this.label = value;\n    },\n\n    /**\n     * @method getChildByName\n     * @deprecated since 8.0.0\n     * @param {string} name - Instance name.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified name.\n     * @see scene.Container#getChildByLabel\n     * @memberof scene.Container#\n     */\n    getChildByName(name: string, deep = false): Container | null\n    {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n     * Returns the first child in the container with the specified label.\n     *\n     * Recursive searches are done in a pre-order traversal.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified label.\n     */\n    getChildByLabel(label: string | RegExp, deep = false): Container | null\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label))) return child;\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i];\n                const found = child.getChildByLabel(label, true);\n\n                if (found)\n                {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    },\n\n    /**\n     * Returns all children in the container with the specified label.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @param {Container[]} [out=[]] - The array to store matching children in.\n     * @returns {Container[]} An array of children with the specified label.\n     */\n    getChildrenByLabel(label: string | RegExp, deep = false, out = []): Container[]\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label)))\n            {\n                out.push(child);\n            }\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i].getChildrenByLabel(label, true, out);\n            }\n        }\n\n        return out;\n    },\n} as Container;\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Bounds } from '../bounds/Bounds.mjs';\nimport { boundsPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nconst getFastGlobalBoundsMixin = {\n  /**\n   * Computes the global bounds for the container, considering its children and optionally\n   * factoring in render layers. It starts by clearing the provided bounds object, then\n   * recursively calculates the bounds, and finally applies the world transformation.\n   * @param {boolean} [factorRenderLayers] - Whether to consider render layers in the calculation.\n   * @param {Bounds} [bounds] - The bounds object to store the result. If not provided, a new one is created.\n   * @returns {Bounds} The computed bounds.\n   * @memberof scene.Container#\n   */\n  getFastGlobalBounds(factorRenderLayers, bounds) {\n    bounds || (bounds = new Bounds());\n    bounds.clear();\n    this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n    if (!bounds.isValid) {\n      bounds.set(0, 0, 0, 0);\n    }\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    bounds.applyMatrix(renderGroup.worldTransform);\n    return bounds;\n  },\n  /**\n   * Recursively calculates the global bounds for the container and its children.\n   * It considers visibility, measurability, and effects, and applies transformations\n   * as necessary to compute the bounds accurately.\n   * @param {boolean} factorRenderLayers - Whether to consider render layers in the calculation.\n   * @param {Bounds} bounds - The bounds object to update with the calculated values.\n   * @param {IRenderLayer} currentLayer - The current render layer being processed.\n   * @memberof scene.Container#\n   */\n  _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {\n    let localBounds = bounds;\n    if (factorRenderLayers && this.parentRenderLayer !== currentLayer)\n      return;\n    if (this.localDisplayStatus !== 7 || !this.measurable) {\n      return;\n    }\n    const manageEffects = !!this.effects.length;\n    if (this.renderGroup || manageEffects) {\n      localBounds = boundsPool.get().clear();\n    }\n    if (this.boundsArea) {\n      bounds.addRect(this.boundsArea, this.worldTransform);\n    } else {\n      if (this.renderPipeId) {\n        const viewBounds = this.bounds;\n        localBounds.addFrame(\n          viewBounds.minX,\n          viewBounds.minY,\n          viewBounds.maxX,\n          viewBounds.maxY,\n          this.groupTransform\n        );\n      }\n      const children = this.children;\n      for (let i = 0; i < children.length; i++) {\n        children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n      }\n    }\n    if (manageEffects) {\n      let advanced = false;\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      for (let i = 0; i < this.effects.length; i++) {\n        if (this.effects[i].addBounds) {\n          if (!advanced) {\n            advanced = true;\n            localBounds.applyMatrix(renderGroup.worldTransform);\n          }\n          this.effects[i].addBounds(localBounds, true);\n        }\n      }\n      if (advanced) {\n        localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n        bounds.addBounds(localBounds, this.relativeGroupTransform);\n      }\n      bounds.addBounds(localBounds);\n      boundsPool.return(localBounds);\n    } else if (this.renderGroup) {\n      bounds.addBounds(localBounds, this.relativeGroupTransform);\n      boundsPool.return(localBounds);\n    }\n  }\n};\n\nexport { getFastGlobalBoundsMixin };\n//# sourceMappingURL=getFastGlobalBoundsMixin.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { type Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport { type IRenderLayer } from '../../layers/RenderLayer';\nimport { Bounds } from '../bounds/Bounds';\nimport { boundsPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { Container } from '../Container';\n\nconst tempMatrix = new Matrix();\n\n/**\n * Interface for the GetFastGlobalBoundsMixin, which provides methods to compute\n * an approximate global bounding box for a container and its children.\n */\nexport interface GetFastGlobalBoundsMixin\n{\n    /**\n     * Computes an approximate global bounding box for the container and its children.\n     * This method is optimized for speed by using axis-aligned bounding boxes (AABBs),\n     * and uses the last render results from when it updated the transforms. This function does not update them.\n     * which may result in slightly larger bounds but never smaller than the actual bounds.\n     *\n     * for accurate (but less performant) results use `container.getGlobalBounds`\n     * @param {boolean} [factorRenderLayers] - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} [bounds] - The output bounds object to store the result. If not provided, a new one is created.\n     * @returns {Bounds} The computed bounds.\n     * @memberof scene.Container#\n     */\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds;\n\n    /**\n     * Recursively calculates the global bounds for the container and its children.\n     * This method is used internally by getFastGlobalBounds to traverse the scene graph.\n     * @param {boolean} factorRenderLayers - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} bounds - The bounds object to update with the calculated values.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: IRenderLayer,\n    ): void;\n}\n\n/**\n * Mixin providing the implementation of the GetFastGlobalBoundsMixin interface.\n * It includes methods to compute and recursively calculate global bounds for containers.\n */\nexport const getFastGlobalBoundsMixin: Partial<Container> = {\n    /**\n     * Computes the global bounds for the container, considering its children and optionally\n     * factoring in render layers. It starts by clearing the provided bounds object, then\n     * recursively calculates the bounds, and finally applies the world transformation.\n     * @param {boolean} [factorRenderLayers] - Whether to consider render layers in the calculation.\n     * @param {Bounds} [bounds] - The bounds object to store the result. If not provided, a new one is created.\n     * @returns {Bounds} The computed bounds.\n     * @memberof scene.Container#\n     */\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds\n    {\n        bounds ||= new Bounds();\n\n        // Initialize the bounds for fresh calculations.\n        bounds.clear();\n\n        // Calculate bounds recursively, starting from the current container.\n        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n\n        // Validate the calculated bounds, resetting if invalid.\n        if (!bounds.isValid)\n        {\n            bounds.set(0, 0, 0, 0);\n        }\n\n        // Apply the world transformation to the bounds.\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        bounds.applyMatrix(renderGroup.worldTransform);\n\n        return bounds;\n    },\n\n    /**\n     * Recursively calculates the global bounds for the container and its children.\n     * It considers visibility, measurability, and effects, and applies transformations\n     * as necessary to compute the bounds accurately.\n     * @param {boolean} factorRenderLayers - Whether to consider render layers in the calculation.\n     * @param {Bounds} bounds - The bounds object to update with the calculated values.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: IRenderLayer,\n    )\n    {\n        let localBounds = bounds;\n\n        // Skip if the container is not in the current render layer when factoring render layers.\n        if (factorRenderLayers && this.parentRenderLayer !== currentLayer) return;\n\n        // Skip if the container is not fully visible or not measurable.\n        if (this.localDisplayStatus !== 0b111 || (!this.measurable))\n        {\n            return;\n        }\n\n        // Determine if effects need to be managed, requiring separate bounds handling.\n        const manageEffects = !!this.effects.length;\n\n        // Use a temporary bounds object if the container is a render group or has effects.\n        if (this.renderGroup || manageEffects)\n        {\n            localBounds = boundsPool.get().clear();\n        }\n\n        // Add the container's own bounds area to the bounds if it exists.\n        if (this.boundsArea)\n        {\n            bounds.addRect(this.boundsArea, this.worldTransform);\n        }\n        else\n        {\n            // If the container is renderable, add its bounds to the local bounds.\n            if (this.renderPipeId)\n            {\n                const viewBounds = (this as Renderable).bounds;\n\n                localBounds.addFrame(\n                    viewBounds.minX,\n                    viewBounds.minY,\n                    viewBounds.maxX,\n                    viewBounds.maxY,\n                    this.groupTransform\n                );\n            }\n\n            // Recursively process each child to include their bounds.\n            const children = this.children;\n\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n            }\n        }\n\n        // If effects are managed, apply them to the bounds.\n        if (manageEffects)\n        {\n            let advanced = false;\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            // Apply each effect that modifies bounds.\n            for (let i = 0; i < this.effects.length; i++)\n            {\n                if (this.effects[i].addBounds)\n                {\n                    if (!advanced)\n                    {\n                        advanced = true;\n                        localBounds.applyMatrix(renderGroup.worldTransform);\n                    }\n                    this.effects[i].addBounds(localBounds, true);\n                }\n            }\n\n            // Adjust bounds back to the local coordinate space if advanced bounds were calculated.\n            if (advanced)\n            {\n                localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n                bounds.addBounds(localBounds, this.relativeGroupTransform);\n            }\n\n            // Add the local bounds to the final bounds and return the temporary bounds object.\n            bounds.addBounds(localBounds);\n            boundsPool.return(localBounds);\n        }\n        else if (this.renderGroup)\n        {\n            // If the container is a render group, add its local bounds to the final bounds.\n            bounds.addBounds(localBounds, this.relativeGroupTransform);\n            boundsPool.return(localBounds);\n        }\n    }\n\n} as Container;\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Pool } from '../../../../utils/pool/Pool.mjs';\nimport { Bounds } from '../Bounds.mjs';\n\n\"use strict\";\nconst matrixPool = new Pool(Matrix);\nconst boundsPool = new Pool(Bounds);\n\nexport { boundsPool, matrixPool };\n//# sourceMappingURL=matrixAndBoundsPool.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Pool } from '../../../../utils/pool/Pool';\nimport { Bounds } from '../Bounds';\n\nimport type { PoolItem } from '../../../../utils/pool/Pool';\n\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\nexport const matrixPool = new Pool<MatrixPoolItem>(Matrix);\nexport const boundsPool = new Pool<BoundsPoolItem>(Bounds);\n","import { updateTransformBackwards } from '../bounds/getGlobalBounds.mjs';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\nimport { multiplyColors } from '../utils/multiplyColors.mjs';\n\n\"use strict\";\nfunction bgr2rgb(color) {\n  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);\n}\nconst getGlobalMixin = {\n  /**\n   * Returns the global (compound) alpha of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n   *   - If true: Uses cached worldAlpha from the last render pass for better performance\n   * @returns The resulting alpha value (between 0 and 1)\n   * @example\n   * // Accurate but slower - recalculates entire alpha chain\n   * const preciseAlpha = container.getGlobalAlpha();\n   *\n   * // Faster but may be outdated - uses cached alpha\n   * const cachedAlpha = container.getGlobalAlpha(true);\n   */\n  getGlobalAlpha(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return this.renderGroup.worldAlpha;\n      }\n      if (this.parentRenderGroup) {\n        return this.parentRenderGroup.worldAlpha * this.alpha;\n      }\n      return this.alpha;\n    }\n    let alpha = this.alpha;\n    let current = this.parent;\n    while (current) {\n      alpha *= current.alpha;\n      current = current.parent;\n    }\n    return alpha;\n  },\n  /**\n   * Returns the global transform matrix of the container within the scene.\n   * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire transform chain for accuracy\n   *   - If true: Uses cached worldTransform from the last render pass for better performance\n   * @returns The resulting transformation matrix (either the input matrix or a new one)\n   * @example\n   * // Accurate but slower - recalculates entire transform chain\n   * const preciseTransform = container.getGlobalTransform();\n   *\n   * // Faster but may be outdated - uses cached transform\n   * const cachedTransform = container.getGlobalTransform(undefined, true);\n   *\n   * // Reuse existing matrix\n   * const existingMatrix = new Matrix();\n   * container.getGlobalTransform(existingMatrix);\n   */\n  getGlobalTransform(matrix, skipUpdate) {\n    if (skipUpdate) {\n      return matrix.copyFrom(this.worldTransform);\n    }\n    this.updateLocalTransform();\n    const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n    matrix.appendFrom(this.localTransform, parentTransform);\n    matrixPool.return(parentTransform);\n    return matrix;\n  },\n  /**\n   * Returns the global (compound) tint color of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n   *   - If true: Uses cached worldColor from the last render pass for better performance\n   * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n   * @example\n   * // Accurate but slower - recalculates entire tint chain\n   * const preciseTint = container.getGlobalTint();\n   *\n   * // Faster but may be outdated - uses cached tint\n   * const cachedTint = container.getGlobalTint(true);\n   */\n  getGlobalTint(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return bgr2rgb(this.renderGroup.worldColor);\n      }\n      if (this.parentRenderGroup) {\n        return bgr2rgb(\n          multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n        );\n      }\n      return this.tint;\n    }\n    let color = this.localColor;\n    let parent = this.parent;\n    while (parent) {\n      color = multiplyColors(color, parent.localColor);\n      parent = parent.parent;\n    }\n    return bgr2rgb(color);\n  }\n};\n\nexport { bgr2rgb, getGlobalMixin };\n//# sourceMappingURL=getGlobalMixin.mjs.map\n","import { updateTransformBackwards } from '../bounds/getGlobalBounds';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\nimport { multiplyColors } from '../utils/multiplyColors';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Container } from '../Container';\n\nexport function bgr2rgb(color: number): number\n{\n    return ((color & 0xFF) << 16) + (color & 0xFF00) + ((color >> 16) & 0xFF);\n}\n\nexport interface GetGlobalMixin\n{\n    getGlobalAlpha(skipUpdate: boolean): number;\n    getGlobalTransform(matrix: Matrix, skipUpdate: boolean): Matrix;\n    getGlobalTint(skipUpdate?: boolean): number;\n}\n\nexport const getGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global (compound) alpha of the container within the scene.\n     * @param skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n     *   - If true: Uses cached worldAlpha from the last render pass for better performance\n     * @returns The resulting alpha value (between 0 and 1)\n     * @example\n     * // Accurate but slower - recalculates entire alpha chain\n     * const preciseAlpha = container.getGlobalAlpha();\n     *\n     * // Faster but may be outdated - uses cached alpha\n     * const cachedAlpha = container.getGlobalAlpha(true);\n     */\n    getGlobalAlpha(skipUpdate: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return this.renderGroup.worldAlpha;\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return this.parentRenderGroup.worldAlpha * this.alpha;\n            }\n\n            return this.alpha;\n        }\n\n        let alpha = this.alpha;\n        let current = this.parent;\n\n        while (current)\n        {\n            alpha *= current.alpha;\n            current = current.parent;\n        }\n\n        return alpha;\n    },\n\n    /**\n     * Returns the global transform matrix of the container within the scene.\n     * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n     * @param skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire transform chain for accuracy\n     *   - If true: Uses cached worldTransform from the last render pass for better performance\n     * @returns The resulting transformation matrix (either the input matrix or a new one)\n     * @example\n     * // Accurate but slower - recalculates entire transform chain\n     * const preciseTransform = container.getGlobalTransform();\n     *\n     * // Faster but may be outdated - uses cached transform\n     * const cachedTransform = container.getGlobalTransform(undefined, true);\n     *\n     * // Reuse existing matrix\n     * const existingMatrix = new Matrix();\n     * container.getGlobalTransform(existingMatrix);\n     */\n    getGlobalTransform(matrix: Matrix, skipUpdate: boolean): Matrix\n    {\n        if (skipUpdate)\n        {\n            return matrix.copyFrom(this.worldTransform);\n        }\n\n        this.updateLocalTransform();\n\n        const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n\n        matrix.appendFrom(this.localTransform, parentTransform);\n        matrixPool.return(parentTransform);\n\n        return matrix;\n    },\n\n    /**\n     * Returns the global (compound) tint color of the container within the scene.\n     * @param skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n     *   - If true: Uses cached worldColor from the last render pass for better performance\n     * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n     * @example\n     * // Accurate but slower - recalculates entire tint chain\n     * const preciseTint = container.getGlobalTint();\n     *\n     * // Faster but may be outdated - uses cached tint\n     * const cachedTint = container.getGlobalTint(true);\n     */\n    getGlobalTint(skipUpdate?: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return bgr2rgb(this.renderGroup.worldColor);\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return bgr2rgb(\n                    multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n                );\n            }\n\n            return this.tint;\n        }\n\n        let color = this.localColor;\n        let parent = this.parent;\n\n        while (parent)\n        {\n            color = multiplyColors(color, parent.localColor);\n            parent = parent.parent;\n        }\n\n        return bgr2rgb(color);\n    }\n\n} as Container;\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = matrixPool.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = Matrix.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    matrixPool.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = matrixPool.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.bounds) {\n      bounds.matrix = worldTransform;\n      bounds.addBounds(target.bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    matrixPool.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards };\n//# sourceMappingURL=getGlobalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    let parentTransform;\n    let pooledMatrix;\n\n    if (target.parent)\n    {\n        if (!skipUpdateTransform)\n        {\n            pooledMatrix = matrixPool.get().identity();\n            parentTransform = updateTransformBackwards(target, pooledMatrix);\n        }\n        else\n        {\n            parentTransform = target.parent.worldTransform;\n        }\n    }\n    else\n    {\n        parentTransform = Matrix.IDENTITY;\n    }\n\n    // then collect them...\n\n    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n\n    if (pooledMatrix)\n    {\n        matrixPool.return(pooledMatrix);\n    }\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    skipUpdateTransform: boolean,\n): void\n{\n    if (!target.visible || !target.measurable) return;\n\n    let worldTransform: Matrix;\n\n    if (!skipUpdateTransform)\n    {\n        target.updateLocalTransform();\n\n        worldTransform = matrixPool.get();\n\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    }\n    else\n    {\n        worldTransform = target.worldTransform;\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, worldTransform);\n    }\n    else\n    {\n        if ((target as Renderable).bounds)\n        {\n            // save a copy\n            bounds.matrix = worldTransform;\n            bounds.addBounds((target as Renderable).bounds);\n        }\n\n        for (let i = 0; i < target.children.length; i++)\n        {\n            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addBounds?.(bounds);\n        }\n\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    if (!skipUpdateTransform)\n    {\n        matrixPool.return(worldTransform);\n    }\n}\n\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix)\n{\n    const parent = target.parent;\n\n    if (parent)\n    {\n        updateTransformBackwards(parent, parentTransform);\n\n        parent.updateLocalTransform();\n\n        parentTransform.append(parent.localTransform);\n    }\n\n    return parentTransform;\n}\n","import { multiplyHexColors } from './multiplyHexColors.mjs';\n\n\"use strict\";\nconst WHITE_BGR = 16777215;\nfunction multiplyColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor === WHITE_BGR) {\n    return parentBGRColor;\n  }\n  if (parentBGRColor === WHITE_BGR) {\n    return localBGRColor;\n  }\n  return multiplyHexColors(localBGRColor, parentBGRColor);\n}\n\nexport { multiplyColors };\n//# sourceMappingURL=multiplyColors.mjs.map\n","import { multiplyHexColors } from './multiplyHexColors';\n\nconst WHITE_BGR = 0xFFFFFF;\n\nexport function multiplyColors(localBGRColor: number, parentBGRColor: number)\n{\n    if (localBGRColor === WHITE_BGR)\n    {\n        return parentBGRColor;\n    }\n\n    if (parentBGRColor === WHITE_BGR)\n    {\n        return localBGRColor;\n    }\n\n    return multiplyHexColors(localBGRColor, parentBGRColor);\n}\n","\"use strict\";\nfunction multiplyHexColors(color1, color2) {\n  if (color1 === 16777215 || !color2)\n    return color2;\n  if (color2 === 16777215 || !color1)\n    return color1;\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 * r2 / 255 | 0;\n  const g = g1 * g2 / 255 | 0;\n  const b = b1 * b2 / 255 | 0;\n  return (r << 16) + (g << 8) + b;\n}\n\nexport { multiplyHexColors };\n//# sourceMappingURL=multiplyHexColors.mjs.map\n","export function multiplyHexColors(color1: number, color2: number): number\n{\n    if (color1 === 0xFFFFFF || !color2) return color2;\n    if (color2 === 0xFFFFFF || !color1) return color1;\n\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = ((r1 * r2) / 255) | 0;\n    const g = ((g1 * g2) / 255) | 0;\n    const b = ((b1 * b2) / 255) | 0;\n\n    return (r << 16) + (g << 8) + b;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Bounds } from '../bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds.mjs';\nimport { getLocalBounds } from '../bounds/getLocalBounds.mjs';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didViewChangeTick;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n  }\n};\n\nexport { measureMixin };\n//# sourceMappingURL=measureMixin.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Bounds } from '../bounds/Bounds';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds';\nimport { getLocalBounds } from '../bounds/getLocalBounds';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { Container } from '../Container';\n\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport interface MeasureMixinConstructor\n{\n    width?: number;\n    height?: number;\n}\nexport interface MeasureMixin extends Required<MeasureMixinConstructor>\n{\n    getSize(out?: Size): Size;\n    setSize(width: number, height?: number): void;\n    setSize(value: Optional<Size, 'height'>): void;\n    getLocalBounds(bounds?: Bounds): Bounds;\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n    _localBoundsCacheData: LocalBoundsCacheData;\n    _localBoundsCacheId: number;\n    _setWidth(width: number, localWidth: number): void;\n    _setHeight(height: number, localHeight: number): void;\n}\n\ninterface LocalBoundsCacheData\n{\n    data: number[];\n    index: number;\n    didChange: boolean;\n    localBounds: Bounds;\n}\n\nconst tempMatrix = new Matrix();\n\nexport const measureMixin: Partial<Container> = {\n\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n\n    _setWidth(value: number, localWidth: number)\n    {\n        const sign = Math.sign(this.scale.x) || 1;\n\n        if (localWidth !== 0)\n        {\n            this.scale.x = (value / localWidth) * sign;\n        }\n        else\n        {\n            this.scale.x = sign;\n        }\n    },\n\n    _setHeight(value: number, localHeight: number)\n    {\n        const sign = Math.sign(this.scale.y) || 1;\n\n        if (localHeight !== 0)\n        {\n            this.scale.y = (value / localHeight) * sign;\n        }\n        else\n        {\n            this.scale.y = sign;\n        }\n    },\n\n    /**\n     * Retrieves the local bounds of the container as a Bounds object.\n     * @returns - The bounding area.\n     * @memberof scene.Container#\n     */\n    getLocalBounds(): Bounds\n    {\n        if (!this._localBoundsCacheData)\n        {\n            this._localBoundsCacheData = {\n                data: [],\n                index: 1,\n                didChange: false,\n                localBounds: new Bounds()\n            };\n        }\n\n        const localBoundsCacheData = this._localBoundsCacheData;\n\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n\n        if (localBoundsCacheData.data[0] !== this._didViewChangeTick)\n        {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didViewChangeTick;\n        }\n\n        checkChildrenDidChange(this, localBoundsCacheData);\n\n        if (localBoundsCacheData.didChange)\n        {\n            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n        }\n\n        return localBoundsCacheData.localBounds;\n    },\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param bounds - Optional bounds to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     * @memberof scene.Container#\n     */\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds\n    {\n        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n    },\n} as Container;\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = matrixPool.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = matrixPool.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      bounds.addBounds(target.bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  matrixPool.return(relativeTransform);\n}\nfunction getParent(target, root, matrix) {\n  const parent = target.parent;\n  if (!parent) {\n    warn(\"Item is not inside the root container\");\n    return;\n  }\n  if (parent !== root) {\n    getParent(parent, root, matrix);\n    parent.updateLocalTransform();\n    matrix.append(parent.localTransform);\n  }\n}\n\nexport { getLocalBounds, getParent };\n//# sourceMappingURL=getLocalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { warn } from '../../../utils/logging/warn';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getLocalBounds(target: Container, bounds: Bounds, relativeMatrix?: Matrix): Bounds\n{\n    bounds.clear();\n\n    relativeMatrix ||= Matrix.IDENTITY;\n\n    _getLocalBounds(target, bounds, relativeMatrix, target, true);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getLocalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    rootContainer: Container,\n    isRoot: boolean\n): void\n{\n    let relativeTransform: Matrix;\n\n    if (!isRoot)\n    {\n        if (!target.visible || !target.measurable) return;\n\n        target.updateLocalTransform();\n\n        const localTransform = target.localTransform;\n\n        relativeTransform = matrixPool.get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    }\n    else\n    {\n        relativeTransform = matrixPool.get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, relativeTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            bounds.matrix = relativeTransform;\n            bounds.addBounds((target as Renderable).bounds);\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        }\n\n        // TODO - make a add transformed bounds?\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    matrixPool.return(relativeTransform);\n}\n\nexport function getParent(target: Container, root: Container, matrix: Matrix)\n{\n    const parent = target.parent;\n\n    if (!parent)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Item is not inside the root container');\n        // #endif\n\n        return;\n    }\n\n    if (parent !== root)\n    {\n        getParent(parent, root, matrix);\n\n        parent.updateLocalTransform();\n        matrix.append(parent.localTransform);\n    }\n}\n\n","\"use strict\";\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n  } else {\n    console.warn(\"PixiJS Warning: \", ...args);\n  }\n}\n\nexport { warn };\n//# sourceMappingURL=warn.mjs.map\n","let warnCount = 0;\nconst maxWarnings = 500;\n\n/**\n * Logs a PixiJS warning message to the console. Stops logging after 500 warnings have been logged.\n * @param args - The warning message(s) to log\n * @returns {void}\n * @memberof utils\n * @ignore\n */\nexport function warn(...args: any[])\n{\n    if (warnCount === maxWarnings) return;\n\n    warnCount++;\n\n    if (warnCount === maxWarnings)\n    {\n        console.warn('PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.');\n    }\n    else\n    {\n        console.warn('PixiJS Warning: ', ...args);\n    }\n}\n","\"use strict\";\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const uid = child.uid;\n    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;\n    const index = previousData.index;\n    if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {\n      previousData.data[previousData.index] = uid;\n      previousData.data[previousData.index + 1] = didChange;\n      previousData.didChange = true;\n    }\n    previousData.index = index + 2;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\nexport { checkChildrenDidChange };\n//# sourceMappingURL=checkChildrenDidChange.mjs.map\n","import type { Container } from '../Container';\n\n/**\n * This function will crawl through the container essentially check if the children have changed.\n *\n * This function checkChildrenDidChange recursively checks if any child in a Container\n * or its children has changed. It does this by comparing a generated changeId for each\n * child against a stored value in previousData.\n * The changeId is a combination of the child's uid and _didChangeId, bitwise manipulated for uniqueness.\n * If a change is detected, it updates previousData and sets didChange to true.\n * The function returns a boolean indicating if any change was detected in the entire hierarchy of children.\n * @param container - the container to check for changes\n * @param previousData - the previous data from the last check made\n * @param previousData.data - the data array\n * @param previousData.index - the index of the data array\n * @param previousData.didChange - did the data change\n */\nexport function checkChildrenDidChange(\n    container: Container,\n    previousData: {\n        data: number[];\n        index: number;\n        didChange: boolean;\n    })\n{\n    const children = container.children;\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i];\n\n        const uid = child.uid;\n        const didChange = ((child._didViewChangeTick & 0xffff) << 16) | (child._didContainerChangeTick & 0xffff);\n\n        const index = previousData.index;\n\n        if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange)\n        {\n            previousData.data[previousData.index] = uid;\n            previousData.data[previousData.index + 1] = didChange;\n\n            previousData.didChange = true;\n        }\n\n        previousData.index = index + 2;\n\n        if (child.children.length)\n        {\n            checkChildrenDidChange(child, previousData);\n        }\n    }\n\n    return previousData.didChange;\n}\n","\"use strict\";\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and \"updateTransform\" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */\n  get onRender() {\n    return this._onRender;\n  }\n};\n\nexport { onRenderMixin };\n//# sourceMappingURL=onRenderMixin.mjs.map\n","import type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../Container';\n\nexport interface OnRenderMixinConstructor\n{\n    onRender?: ((renderer: Renderer) => void | null);\n}\nexport interface OnRenderMixin extends Required<OnRenderMixinConstructor>\n{\n    _onRender: ((renderer: Renderer) => void) | null;\n}\n\nexport const onRenderMixin: Partial<Container> = {\n    _onRender: null,\n\n    set onRender(func: (renderer: Renderer) => void)\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (!func)\n        {\n            if (this._onRender)\n            {\n                renderGroup?.removeOnRender(this);\n            }\n\n            this._onRender = null;\n\n            return;\n        }\n\n        if (!this._onRender)\n        {\n            renderGroup?.addOnRender(this);\n        }\n\n        this._onRender = func;\n    },\n\n    /**\n     * This callback is used when the container is rendered. This is where you should add your custom\n     * logic that is needed to be run every frame.\n     *\n     * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n     * and \"updateTransform\" is no longer called every frame\n     * @example\n     * const container = new Container();\n     * container.onRender = () => {\n     *    container.rotation += 0.01;\n     * };\n     * @memberof scene.Container#\n     */\n    get onRender(): (renderer: Renderer) => void\n    {\n        return this._onRender;\n    }\n} as Container;\n","\"use strict\";\nconst sortMixin = {\n  _zIndex: 0,\n  /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortDirty: false,\n  /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortableChildren: false,\n  /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\nexport { sortMixin };\n//# sourceMappingURL=sortMixin.mjs.map\n","import type { Container } from '../Container';\n\nexport interface SortMixinConstructor\n{\n    zIndex?: number;\n    sortDirty?: boolean;\n    sortableChildren?: boolean;\n}\nexport interface SortMixin extends Required<SortMixinConstructor>\n{\n    _zIndex: number;\n\n    sortChildren: () => void;\n    depthOfChildModified: () => void;\n}\n\nexport const sortMixin: Partial<Container> = {\n    _zIndex: 0,\n    /**\n     * Should children be sorted by zIndex at the next render call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortDirty: false,\n    /**\n     * If set to true, the container will sort its children by `zIndex` value\n     * when the next render is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n     *\n     * Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortableChildren: false,\n\n    /**\n     * The zIndex of the container.\n     *\n     * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see scene.Container#sortableChildren\n     * @memberof scene.Container#\n     */\n    get zIndex()\n    {\n        return this._zIndex;\n    },\n\n    set zIndex(value: number)\n    {\n        if (this._zIndex === value) return;\n\n        this._zIndex = value;\n\n        this.depthOfChildModified();\n    },\n\n    depthOfChildModified()\n    {\n        if (this.parent)\n        {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n    },\n\n    /**\n     * Sorts children by zIndex.\n     * @memberof scene.Container#\n     */\n    sortChildren()\n    {\n        if (!this.sortDirty) return;\n\n        this.sortDirty = false;\n\n        this.children.sort(sortChildren);\n    },\n} as Container;\n\nfunction sortChildren(a: Container, b: Container): number\n{\n    return a._zIndex - b._zIndex;\n}\n","import { Point } from '../../../maths/point/Point.mjs';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n    point = globalMatrix.apply(position, point);\n    matrixPool.return(globalMatrix);\n    return point;\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n    point = globalMatrix.applyInverse(position, point);\n    matrixPool.return(globalMatrix);\n    return point;\n  }\n};\n\nexport { toLocalGlobalMixin };\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n","import { Point } from '../../../maths/point/Point';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\nexport interface ToLocalGlobalMixin\n{\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\nexport const toLocalGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global position of the container.\n     * @param point - The optional point to write the global value to.\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - The updated point.\n     * @memberof scene.Container#\n     */\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    /**\n     * Calculates the global position of the container.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     * @memberof scene.Container#\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.apply(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    },\n\n    /**\n     * Calculates the local position of the container relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The Container to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     * @memberof scene.Container#\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.applyInverse(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    }\n} as Container;\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\n\n\"use strict\";\nclass RenderGroup {\n  constructor() {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    this.gcTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    this.textureNeedsUpdate = true;\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    this.isCachedAsTexture = false;\n    this._matrixDirty = 7;\n  }\n  init(root) {\n    this.root = root;\n    if (root._onRender)\n      this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      child._updateFlags = 15;\n      this.addChild(child);\n    }\n  }\n  enableCacheAsTexture(options = {}) {\n    this.textureOptions = options;\n    this.isCachedAsTexture = true;\n    this.textureNeedsUpdate = true;\n  }\n  disableCacheAsTexture() {\n    this.isCachedAsTexture = false;\n    if (this.texture) {\n      TexturePool.returnTexture(this.texture);\n      this.texture = null;\n    }\n  }\n  updateCacheTexture() {\n    this.textureNeedsUpdate = true;\n  }\n  reset() {\n    this.renderGroupChildren.length = 0;\n    for (const i in this.childrenToUpdate) {\n      const childrenAtDepth = this.childrenToUpdate[i];\n      childrenAtDepth.list.fill(null);\n      childrenAtDepth.index = 0;\n    }\n    this.childrenRenderablesToUpdate.index = 0;\n    this.childrenRenderablesToUpdate.list.fill(null);\n    this.root = null;\n    this.updateTick = 0;\n    this.structureDidChange = true;\n    this._onRenderContainers.length = 0;\n    this.renderGroupParent = null;\n    this.disableCacheAsTexture();\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender)\n      this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  updateRenderable(renderable) {\n    if (renderable.globalDisplayStatus < 7)\n      return;\n    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n    renderable.didViewUpdate = false;\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender(renderer) {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender(renderer);\n    }\n  }\n  destroy() {\n    this.disableCacheAsTexture();\n    this.renderGroupParent = null;\n    this.root = null;\n    this.childrenRenderablesToUpdate = null;\n    this.childrenToUpdate = null;\n    this.renderGroupChildren = null;\n    this._onRenderContainers = null;\n    this.instructionSet = null;\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup)\n      return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  invalidateMatrices() {\n    this._matrixDirty = 7;\n  }\n  /**\n   * Returns the inverse of the world transform matrix.\n   * @returns {Matrix} The inverse of the world transform matrix.\n   */\n  get inverseWorldTransform() {\n    if ((this._matrixDirty & 1) === 0)\n      return this._inverseWorldTransform;\n    this._matrixDirty &= ~1;\n    this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());\n    return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();\n  }\n  /**\n   * Returns the inverse of the texture offset transform matrix.\n   * @returns {Matrix} The inverse of the texture offset transform matrix.\n   */\n  get textureOffsetInverseTransform() {\n    if ((this._matrixDirty & 2) === 0)\n      return this._textureOffsetInverseTransform;\n    this._matrixDirty &= ~2;\n    this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());\n    return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(\n      -this._textureBounds.x,\n      -this._textureBounds.y\n    );\n  }\n  /**\n   * Returns the inverse of the parent texture transform matrix.\n   * This is used to properly transform coordinates when rendering into cached textures.\n   * @returns {Matrix} The inverse of the parent texture transform matrix.\n   */\n  get inverseParentTextureTransform() {\n    if ((this._matrixDirty & 4) === 0)\n      return this._inverseParentTextureTransform;\n    this._matrixDirty &= ~4;\n    const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n    if (parentCacheAsTexture) {\n      this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());\n      return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(\n        -parentCacheAsTexture._textureBounds.x,\n        -parentCacheAsTexture._textureBounds.y\n      );\n    }\n    return this.worldTransform;\n  }\n  /**\n   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n   * or null if no parent is cached as texture.\n   */\n  get cacheToLocalTransform() {\n    if (!this._parentCacheAsTextureRenderGroup)\n      return null;\n    return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n  }\n}\n\nexport { RenderGroup };\n//# sourceMappingURL=RenderGroup.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer } from '../../rendering/renderers/types';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BatchableSprite } from '../sprite/BatchableSprite';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Bounds } from './bounds/Bounds';\nimport type { Container } from './Container';\n\n/**\n * Options for caching a container as a texture.\n * @memberof rendering\n * @see {@link RenderGroup#textureOptions}\n */\nexport interface CacheAsTextureOptions\n{\n    /**\n     * If true, the texture will be antialiased. This smooths out the edges of the texture.\n     * @default false\n     */\n    antialias?: boolean;\n    /**\n     * The resolution of the texture. A higher resolution means a sharper texture but uses more memory.\n     * By default the resolution is 1 which is the same as the rendererers resolution.\n     */\n    resolution?: number;\n}\n\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @memberof rendering\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n    public gcTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    public textureNeedsUpdate = true;\n\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    public isCachedAsTexture = false;\n\n    /**\n     * The texture used for caching the container. this is only set if isCachedAsTexture is true.\n     * It can only be accessed after a render pass.\n     * @type {Texture | undefined}\n     */\n    public texture?: Texture;\n\n    /**\n     * The bounds of the cached texture.\n     * @type {Bounds | undefined}\n     * @ignore\n     */\n    public _textureBounds?: Bounds;\n\n    /**\n     * The options for caching the container as a texture.\n     * @type {CacheAsTextureOptions}\n     */\n    public textureOptions: CacheAsTextureOptions;\n\n    /**\n     *  holds a reference to the batchable render sprite\n     *  @ignore\n     */\n    public _batchableRenderGroup: BatchableSprite;\n\n    /**\n     * Holds a reference to the closest parent RenderGroup that has isCachedAsTexture enabled.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @type {RenderGroup | null}\n     * @ignore\n     */\n    public _parentCacheAsTextureRenderGroup: RenderGroup;\n\n    private _inverseWorldTransform: Matrix;\n    private _textureOffsetInverseTransform: Matrix;\n    private _inverseParentTextureTransform: Matrix;\n\n    private _matrixDirty = 0b111;\n\n    public init(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            // make sure the children are all updated on the first pass..\n            child._updateFlags = 0b1111;\n\n            this.addChild(child);\n        }\n    }\n\n    public enableCacheAsTexture(options: CacheAsTextureOptions = {}): void\n    {\n        this.textureOptions = options;\n        this.isCachedAsTexture = true;\n        this.textureNeedsUpdate = true;\n    }\n\n    public disableCacheAsTexture(): void\n    {\n        this.isCachedAsTexture = false;\n        if (this.texture)\n        {\n            TexturePool.returnTexture(this.texture);\n            this.texture = null;\n        }\n    }\n\n    public updateCacheTexture(): void\n    {\n        this.textureNeedsUpdate = true;\n    }\n\n    public reset()\n    {\n        this.renderGroupChildren.length = 0;\n\n        for (const i in this.childrenToUpdate)\n        {\n            const childrenAtDepth = this.childrenToUpdate[i];\n\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n\n        this.disableCacheAsTexture();\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    public updateRenderable(renderable: ViewContainer)\n    {\n        if (renderable.globalDisplayStatus < 0b111) return;\n        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n        renderable.didViewUpdate = false;\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender(renderer: Renderer)\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender(renderer);\n        }\n    }\n\n    public destroy()\n    {\n        this.disableCacheAsTexture();\n\n        this.renderGroupParent = null;\n        this.root = null;\n        (this.childrenRenderablesToUpdate as any) = null;\n        (this.childrenToUpdate as any) = null;\n        (this.renderGroupChildren as any) = null;\n        (this._onRenderContainers as any) = null;\n        this.instructionSet = null;\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    public invalidateMatrices()\n    {\n        this._matrixDirty = 0b111;\n    }\n\n    /**\n     * Returns the inverse of the world transform matrix.\n     * @returns {Matrix} The inverse of the world transform matrix.\n     */\n    public get inverseWorldTransform()\n    {\n        if ((this._matrixDirty & 0b001) === 0) return this._inverseWorldTransform;\n\n        this._matrixDirty &= ~0b001;\n\n        // TODO - add dirty flag\n        this._inverseWorldTransform ||= new Matrix();\n\n        return this._inverseWorldTransform\n            .copyFrom(this.worldTransform)\n            .invert();\n    }\n\n    /**\n     * Returns the inverse of the texture offset transform matrix.\n     * @returns {Matrix} The inverse of the texture offset transform matrix.\n     */\n    public get textureOffsetInverseTransform()\n    {\n        if ((this._matrixDirty & 0b010) === 0) return this._textureOffsetInverseTransform;\n\n        this._matrixDirty &= ~0b010;\n\n        this._textureOffsetInverseTransform ||= new Matrix();\n\n        // TODO shared.. bad!\n        return this._textureOffsetInverseTransform\n            .copyFrom(this.inverseWorldTransform)\n            .translate(\n                -this._textureBounds.x,\n                -this._textureBounds.y\n            );\n    }\n\n    /**\n     * Returns the inverse of the parent texture transform matrix.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @returns {Matrix} The inverse of the parent texture transform matrix.\n     */\n    public get inverseParentTextureTransform()\n    {\n        if ((this._matrixDirty & 0b100) === 0) return this._inverseParentTextureTransform;\n\n        this._matrixDirty &= ~0b100;\n\n        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n\n        if (parentCacheAsTexture)\n        {\n            this._inverseParentTextureTransform ||= new Matrix();\n\n            // Get relative transform by removing parent's world transform\n            return this._inverseParentTextureTransform\n                .copyFrom(this.worldTransform)\n                .prepend(parentCacheAsTexture.inverseWorldTransform)\n                // Offset by texture bounds\n                .translate(\n                    -parentCacheAsTexture._textureBounds.x,\n                    -parentCacheAsTexture._textureBounds.y\n                );\n        }\n\n        return this.worldTransform;\n    }\n\n    /**\n     * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n     * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n     * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n     * or null if no parent is cached as texture.\n     */\n    public get cacheToLocalTransform()\n    {\n        if (!this._parentCacheAsTextureRenderGroup) return null;\n\n        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n    }\n}\n","import { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = uid(\"instructionSet\");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n    this.renderables = [];\n    /** used by the garbage collector to track when the instruction set was last used */\n    this.gcTick = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, [\"type\", \"action\"]);\n  }\n}\n\nexport { InstructionSet };\n//# sourceMappingURL=InstructionSet.mjs.map\n","import { uid } from '../../../../utils/data/uid';\n\nimport type { Renderable } from '../Renderable';\nimport type { Instruction } from './Instruction';\n\n/**\n * A set of instructions that can be executed by the renderer.\n * Basically wraps an array, but with some extra properties that help the renderer\n * to keep things nice and optimised.\n *\n * Note:\n * InstructionSet.instructions contains all the instructions, but does not resize (for performance).\n * So for the true length of the instructions you need to use InstructionSet.instructionSize\n * @memberof rendering\n */\nexport class InstructionSet\n{\n    /** a unique id for this instruction set used through the renderer */\n    public readonly uid: number = uid('instructionSet');\n    /** the array of instructions */\n    public readonly instructions: Instruction[] = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    public instructionSize = 0;\n    /** allows for access to the render pipes of the renderer */\n    public renderPipes: any;\n\n    public renderables: Renderable[] = [];\n    /** used by the garbage collector to track when the instruction set was last used */\n    public gcTick = 0;\n\n    /** reset the instruction set so it can be reused set size back to 0 */\n    public reset()\n    {\n        this.instructionSize = 0;\n    }\n\n    /**\n     * Add an instruction to the set\n     * @param instruction - add an instruction to the set\n     */\n    public add(instruction: Instruction)\n    {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n\n    /**\n     * Log the instructions to the console (for debugging)\n     * @internal\n     * @ignore\n     */\n    public log()\n    {\n        this.instructions.length = this.instructionSize;\n        // eslint-disable-next-line no-console\n        console.table(this.instructions, ['type', 'action']);\n    }\n}\n","import { nextPow2 } from '../../../../maths/misc/pow2.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: false\n    });\n    return new Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = nextPow2(po2Width);\n    po2Height = nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexport { TexturePool, TexturePoolClass };\n//# sourceMappingURL=TexturePool.mjs.map\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: false,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","\"use strict\";\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\nexport { assignWithIgnore };\n//# sourceMappingURL=assignWithIgnore.mjs.map\n","/**\n * Assigns properties from one object to another, using an optional array of property names to ignore.\n * @param target - The target object to assign properties to.\n * @param options - The object to assign properties from.\n * @param ignore - An object of property names to ignore ({ propToIgnore: true }).\n */\nexport function assignWithIgnore<T extends Record<string, any>>(\n    target: T,\n    options: T,\n    ignore: Record<string, boolean> = {}\n)\n{\n    for (const key in options)\n    {\n        if (!ignore[key] && options[key] !== undefined)\n        {\n            target[key] = options[key];\n        }\n    }\n}\n","import { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\nexport { addMaskBounds };\n//# sourceMappingURL=addMaskBounds.mjs.map\n","import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds.mjs';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = boundsPool.get();\n  mask.measurable = true;\n  const tempMatrix = matrixPool.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  getLocalBounds(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixPool.return(tempMatrix);\n  boundsPool.return(boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    warn(\"Mask bounds, renderable is not inside the root container\");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\nexport { addMaskLocalBounds, getMatrixRelativeToParent };\n//# sourceMappingURL=addMaskLocalBounds.mjs.map\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nexport function getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"colorMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === \"number\";\n  }\n}\nColorMask.extension = ExtensionType.MaskEffect;\n\nexport { ColorMask };\n//# sourceMappingURL=ColorMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Container } from '../../../scene/container/Container.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"stencilMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container;\n  }\n}\nStencilMask.extension = ExtensionType.MaskEffect;\n\nexport { StencilMask };\n//# sourceMappingURL=StencilMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass CanvasSource extends TextureSource {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = DOMAdapter.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoDensity = options.autoDensity;\n    this.resizeCanvas();\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n  /**\n   * Returns the 2D rendering context for the canvas.\n   * Caches the context after creating it.\n   * @returns The 2D rendering context of the canvas.\n   */\n  get context2D() {\n    return this._context2D || (this._context2D = this.resource.getContext(\"2d\"));\n  }\n}\nCanvasSource.extension = ExtensionType.TextureSource;\n\nexport { CanvasSource };\n//# sourceMappingURL=CanvasSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /** should the canvas be resized to preserve its screen width and height regardless of the resolution of the renderer */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    private _context2D: CanvasRenderingContext2D;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        this.resizeCanvas();\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n\n    /**\n     * Returns the 2D rendering context for the canvas.\n     * Caches the context after creating it.\n     * @returns The 2D rendering context of the canvas.\n     */\n    get context2D(): CanvasRenderingContext2D\n    {\n        return this._context2D || (this._context2D = this.resource.getContext('2d') as CanvasRenderingContext2D);\n    }\n}\n","import { BrowserAdapter } from '../environment-browser/BrowserAdapter.mjs';\n\n\"use strict\";\nlet currentAdapter = BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\nexport { DOMAdapter };\n//# sourceMappingURL=adapter.mjs.map\n","import { BrowserAdapter } from '../environment-browser/BrowserAdapter';\n\nimport type { ICanvas } from './canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from './canvas/ICanvasRenderingContext2D';\n\n/**\n * PixiJS supports multiple environments including browsers, Web Workers, and Node.js.\n * The environment is auto-detected by default using the {@link environment.autoDetectEnvironment} function.\n *\n * The {@link environment.Adapter} interface provides a way to abstract away the differences between\n * these environments. PixiJS uses the {@link environment.BrowserAdapter} by default.\n *\n * However you can manually set the environment using the {@link environment.DOMAdapter} singleton, for example to\n * use Pixi within a WebWorker.\n * ```js\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * ```\n * @namespace environment\n */\n\n/**\n * This interface describes all the DOM dependent calls that Pixi makes throughout its codebase.\n * Implementations of this interface can be used to make sure Pixi will work in any environment,\n * such as browser, Web Workers, and Node.js.\n * @memberof environment\n */\nexport interface Adapter\n{\n    /** Returns a canvas object that can be used to create a webgl context. */\n    createCanvas: (width?: number, height?: number) => ICanvas;\n    /** Returns a 2D rendering context. */\n    getCanvasRenderingContext2D: () => { prototype: ICanvasRenderingContext2D; };\n    /** Returns a WebGL rendering context. */\n    getWebGLRenderingContext: () => typeof WebGLRenderingContext;\n    /** Returns a partial implementation of the browsers window.navigator */\n    getNavigator: () => { userAgent: string, gpu: GPU | null };\n    /** Returns the current base URL For browser environments this is either the document.baseURI or window.location.href */\n    getBaseUrl: () => string;\n    /** Return the font face set if available */\n    getFontFaceSet: () => FontFaceSet | null;\n    /** Returns a Response object that has been fetched from the given URL. */\n    fetch: (url: RequestInfo, options?: RequestInit) => Promise<Response>;\n    /** Returns Document object that has been parsed from the given XML string. */\n    parseXML: (xml: string) => Document;\n}\n\nlet currentAdapter: Adapter = BrowserAdapter;\n\n/**\n * The DOMAdapter is a singleton that allows PixiJS to perform DOM operations, such as creating a canvas.\n * This allows PixiJS to be used in any environment, such as a web browser, Web Worker, or Node.js.\n * It uses the {@link environment.Adapter} interface to abstract away the differences between these environments\n * and uses the {@link environment.BrowserAdapter} by default.\n *\n * It has two methods: `get():Adapter` and `set(adapter: Adapter)`.\n *\n * Defaults to the {@link environment.BrowserAdapter}.\n * @example\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * @memberof environment\n */\nexport const DOMAdapter = {\n    /**\n     * Returns the current adapter.\n     * @returns {environment.Adapter} The current adapter.\n     */\n    get(): Adapter\n    {\n        return currentAdapter;\n    },\n    /**\n     * Sets the current adapter.\n     * @param adapter - The new adapter.\n     */\n    set(adapter: Adapter): void\n    {\n        currentAdapter = adapter;\n    },\n};\n","\"use strict\";\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, \"text/xml\");\n  }\n};\n\nexport { BrowserAdapter };\n//# sourceMappingURL=BrowserAdapter.mjs.map\n","import { type Adapter } from '../environment/adapter';\n\n/**\n * This is an implementation of the {@link environment.Adapter} interface.\n * It can be used to make Pixi work in the browser.\n * @memberof environment\n * @property {Function} createCanvas - Creates a canvas element of the given size.\n * This canvas is created using the browser's native canvas element.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL for browser environments this is either\n * the document.baseURI or window.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n */\nexport const BrowserAdapter = {\n    createCanvas: (width: number, height: number): HTMLCanvasElement =>\n    {\n        const canvas = document.createElement('canvas');\n\n        canvas.width = width;\n        canvas.height = height;\n\n        return canvas;\n    },\n    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n    getWebGLRenderingContext: () => WebGLRenderingContext,\n    getNavigator: () => navigator,\n    getBaseUrl: () => (document.baseURI ?? window.location.href),\n    getFontFaceSet: () => document.fonts,\n    fetch: (url: RequestInfo, options?: RequestInit) => fetch(url, options),\n    parseXML: (xml: string) =>\n    {\n        const parser = new DOMParser();\n\n        return parser.parseFromString(xml, 'text/xml');\n    },\n} as Adapter;\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass ImageSource extends TextureSource {\n  constructor(options) {\n    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {\n      const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);\n      options.resource = canvas;\n      warn(\"ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.\");\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n}\nImageSource.extension = ExtensionType.TextureSource;\n\nexport { ImageSource };\n//# sourceMappingURL=ImageSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement))\n        {\n            const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);\n            options.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.');\n            // #endif\n        }\n\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap)\n        || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../../../ticker/Ticker.mjs';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nconst _VideoSource = class _VideoSource extends TextureSource {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = \"video\";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart);\n    source.addEventListener(\"pause\", this._onPlayStop);\n    source.addEventListener(\"seeked\", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener(\"canplay\", this._onCanPlay);\n      }\n      source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await detectVideoAlphaMode();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener(\"error\", this._onError, true);\n    this.emit(\"error\", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener(\"play\", this._onPlayStart);\n      source.removeEventListener(\"pause\", this._onPlayStop);\n      source.removeEventListener(\"seeked\", this._onSeeked);\n      source.removeEventListener(\"canplay\", this._onCanPlay);\n      source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          Ticker.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          Ticker.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        Ticker.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;\n  }\n};\n_VideoSource.extension = ExtensionType.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ...TextureSource.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nlet VideoSource = _VideoSource;\n\nexport { VideoSource };\n//# sourceMappingURL=VideoSource.mjs.map\n","// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\ntype VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @memberof rendering\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\nexport interface VideoResourceOptionsElement\n{\n    src: string;\n    mime: string;\n}\n\n/**\n * A source for video-based textures.\n * @memberof rendering\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement);\n    }\n}\n","import { UPDATE_PRIORITY } from './const.mjs';\nimport { TickerListener } from './TickerListener.mjs';\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\nexport { Ticker };\n//# sourceMappingURL=Ticker.mjs.map\n","import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * ```js\n * ticker.add(() => {\n *    // do something every frame\n * });\n * ```\n * @memberof ticker\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * {@link ticker.Ticker|Tickers} provide periodic callbacks based on the system clock.\n * Your game update logic will generally be run in response to a tick once per frame.\n * You can have multiple tickers in use at one time.\n * ```js\n * import { Ticker } from 'pixi.js';\n *\n * const callback = (ticker: Ticker) => {\n *    // do something on the next animation frame\n * };\n *\n * // create a ticker\n * const ticker = new Ticker();\n *\n * // register the callback and start the ticker\n * ticker.add(callback);\n * ticker.start();\n * ```\n *\n * You can always use the {@link ticker.Ticker.shared|shared} ticker that Pixi renders with by default.\n * ```js\n * Ticker.shared.add(callback);\n * ```\n * @namespace ticker\n */\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n *\n * This class is composed around listeners meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary, e.g. When the ticker is started and the emitter has listeners.\n * @class\n * @memberof ticker\n */\nexport class Ticker\n{\n    /**\n     * Target frames per millisecond.\n     * @static\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    public autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    public deltaTime = 1;\n    /**\n     * Scalar time elapsed in milliseconds from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link ticker.Ticker#deltaTime|deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public elapsedMS: number;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     */\n    public lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     * @private\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     * @private\n     */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     * @private\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events. Calls continuously unless\n     * it is removed or the ticker is stopped.\n     * @param fn - The listener function to be added for updates\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only execute once.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list\n     * @readonly\n     * @member {number}\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n     * the current {@link ticker.Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link ticker.Ticker#speed|speed}, which is specific\n     * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @member {number}\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @member {number}\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @member {number}\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoResource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link BasePrepare} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n","\"use strict\";\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\nexport { UPDATE_PRIORITY };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link ticker.Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @static\n * @enum {number}\n * @memberof ticker\n */\nexport enum UPDATE_PRIORITY\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link BasePrepare} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n","\"use strict\";\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\nexport { TickerListener };\n//# sourceMappingURL=TickerListener.mjs.map\n","import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n","\"use strict\";\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement(\"canvas\");\n    const gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement(\"video\");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = \"anonymous\";\n      video2.preload = \"auto\";\n      video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n      video2.load();\n    });\n    if (!video) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n  })());\n  return promise;\n}\n\nexport { detectVideoAlphaMode };\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n","import type { ALPHA_MODES } from '../../rendering/renderers/shared/texture/const';\n\nlet promise: Promise<ALPHA_MODES> | undefined;\n\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @memberof utils\n * @function detectVideoAlphaMode\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport async function detectVideoAlphaMode(): Promise<ALPHA_MODES>\n{\n    promise ??= (async () =>\n    {\n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const video = await new Promise<HTMLVideoElement | null>((resolve) =>\n        {\n            const video = document.createElement('video');\n\n            video.onloadeddata = () => resolve(video);\n            video.onerror = () => resolve(null);\n            video.autoplay = false;\n            video.crossOrigin = 'anonymous';\n            video.preload = 'auto';\n            // eslint-disable-next-line max-len\n            video.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=';\n            video.load();\n        });\n\n        if (!video)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        const framebuffer = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            texture,\n            0\n        );\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n\n        const pixel = new Uint8Array(4);\n\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n        return pixel[0] <= pixel[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload';\n    })();\n\n    return promise;\n}\n","import { Cache } from '../../../../../assets/cache/Cache.mjs';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from '../sources/TextureSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst sources = [];\nextensions.handleByList(ExtensionType.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  return textureSourceFrom(options);\n}\nfunction textureSourceFrom(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && Cache.has(resource)) {\n    return Cache.get(resource);\n  }\n  const texture = new Texture({ source: textureSourceFrom(opts) });\n  texture.on(\"destroy\", () => {\n    if (Cache.has(resource)) {\n      Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === \"string\") {\n    return Cache.get(id);\n  } else if (id instanceof TextureSource) {\n    return new Texture({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n\nexport { autoDetectSource, resourceToTexture, textureFrom };\n//# sourceMappingURL=textureFrom.mjs.map\n","import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer | ICanvas): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions\n  | CanvasSourceOptions;\n\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n */\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    return textureSourceFrom(options);\n}\n\n/**\n * Creates a texture source from the options provided\n * @param options - The options to create the texture source from. This can be\n */\nfunction textureSourceFrom(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: textureSourceFrom(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\n\n\"use strict\";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        warn(\"[Cache] already has key:\", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\nexport { Cache };\n//# sourceMappingURL=Cache.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSpritesheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @example\n * import { Cache } from 'pixi.js';\n *\n * Cache.set('bunny', bunnyTexture);\n * @class Cache\n * @memberof assets\n */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: any | any[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n","\"use strict\";\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === \"string\" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\nexport { convertToList };\n//# sourceMappingURL=convertToList.mjs.map\n","export const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { spritesheetAsset } from './spritesheetAsset.mjs';\n\n\"use strict\";\nextensions.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { spritesheetAsset } from './spritesheetAsset';\n\nextensions.add(spritesheetAsset);\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser.mjs';\nimport { Resolver } from '../assets/resolver/Resolver.mjs';\nimport { copySearchParams } from '../assets/utils/copySearchParams.mjs';\nimport { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { path } from '../utils/path.mjs';\nimport { Spritesheet } from './Spritesheet.mjs';\n\n\"use strict\";\nconst validImages = [\n  \"jpg\",\n  \"png\",\n  \"jpeg\",\n  \"avif\",\n  \"webp\",\n  \"basis\",\n  \"etc2\",\n  \"bc7\",\n  \"bc6h\",\n  \"bc5\",\n  \"bc4\",\n  \"bc3\",\n  \"bc2\",\n  \"bc1\",\n  \"eac\",\n  \"astc\"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: ExtensionType.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    extension: {\n      type: ExtensionType.ResolveParser,\n      name: \"resolveSpritesheet\"\n    },\n    test: (value) => {\n      const tempURL = value.split(\"?\")[0];\n      const split = tempURL.split(\".\");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === \"json\" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(\".\");\n      return {\n        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: \"spritesheetLoader\",\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal,\n      name: \"spritesheetLoader\"\n    },\n    async testParse(asset, options) {\n      return path.extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename,\n        // if user need to use custom filename (not from jsonFile.meta.image)\n        textureOptions\n        // if user need to set texture options on texture\n      } = options?.data ?? {};\n      let basePath = path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      let texture;\n      if (imageTexture instanceof Texture) {\n        texture = imageTexture;\n      } else {\n        const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([{ src: imagePath, data: textureOptions }]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet(\n        texture.source,\n        asset\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== \"string\") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    async unload(spritesheet, _resolvedAsset, loader) {\n      await loader.unload(spritesheet.textureSource._sourceOrigin);\n      spritesheet.destroy(false);\n    }\n  }\n};\n\nexport { spritesheetAsset };\n//# sourceMappingURL=spritesheetAsset.mjs.map\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser';\nimport { Resolver } from '../assets/resolver/Resolver';\nimport { copySearchParams } from '../assets/utils/copySearchParams';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { path } from '../utils/path';\nimport { Spritesheet } from './Spritesheet';\n\nimport type { AssetExtensionAdvanced } from '../assets/AssetExtension';\nimport type { Loader } from '../assets/loader/Loader';\nimport type { ResolvedAsset } from '../assets/types';\nimport type { TextureSourceOptions } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { SpritesheetData } from './Spritesheet';\n\nexport interface SpriteSheetJson extends SpritesheetData\n{\n    meta: {\n        image: string;\n        scale: string;\n        related_multi_packs?: string[];\n    };\n}\n\nconst validImages = ['jpg', 'png', 'jpeg', 'avif', 'webp',\n    'basis', 'etc2', 'bc7', 'bc6h', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac', 'astc'];\n\nfunction getCacheableAssets(keys: string[], asset: Spritesheet, ignoreMultiPack: boolean)\n{\n    const out: Record<string, any> = {};\n\n    keys.forEach((key: string) =>\n    {\n        out[key] = asset;\n    });\n\n    Object.keys(asset.textures).forEach((key) =>\n    {\n        out[key] = asset.textures[key];\n    });\n\n    if (!ignoreMultiPack)\n    {\n        const basePath = path.dirname(keys[0]);\n\n        asset.linkedSheets.forEach((item: Spritesheet, i) =>\n        {\n            const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n\n            Object.assign(out, out2);\n        });\n    }\n\n    return out;\n}\n\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *         textureOptions: {\n *             scaleMode: \"nearest\"\n *         }\n *     }\n * })\n * @type {AssetExtension}\n * @memberof assets\n */\nexport const spritesheetAsset = {\n    extension: ExtensionType.Asset,\n    /** Handle the caching of the related Spritesheet Textures */\n    cache: {\n        test: (asset: Spritesheet) => asset instanceof Spritesheet,\n        getCacheableAssets: (keys: string[], asset: Spritesheet) => getCacheableAssets(keys, asset, false),\n    },\n    /** Resolve the resolution of the asset. */\n    resolver: {\n        extension: {\n            type: ExtensionType.ResolveParser,\n            name: 'resolveSpritesheet',\n        },\n        test: (value: string): boolean =>\n        {\n            const tempURL = value.split('?')[0];\n            const split = tempURL.split('.');\n            const extension = split.pop();\n            const format = split.pop();\n\n            return extension === 'json' && validImages.includes(format);\n        },\n        parse: (value: string) =>\n        {\n            const split = value.split('.');\n\n            return {\n                resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n                format: split[split.length - 2],\n                src: value,\n            };\n        },\n    },\n    /**\n     * Loader plugin that parses sprite sheets!\n     * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n     * If it is, we load the spritesheets image and parse the data into Spritesheet\n     * All textures in the sprite sheet are then added to the cache\n     */\n    loader: {\n        name: 'spritesheetLoader',\n\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n            name: 'spritesheetLoader',\n        },\n\n        async testParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>\n        {\n            return (path.extname(options.src).toLowerCase() === '.json' && !!asset.frames);\n        },\n\n        async parse(\n            asset: SpriteSheetJson,\n            options: ResolvedAsset<{\n                texture?: Texture,\n                imageFilename?: string,\n                ignoreMultiPack?: boolean,\n                textureOptions?: TextureSourceOptions\n            }>,\n            loader?: Loader\n        ): Promise<Spritesheet>\n        {\n            const {\n                texture: imageTexture, // if user need to use preloaded texture\n                imageFilename, // if user need to use custom filename (not from jsonFile.meta.image)\n                textureOptions // if user need to set texture options on texture\n            } = options?.data ?? {};\n\n            let basePath = path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== (basePath.length - 1))\n            {\n                basePath += '/';\n            }\n\n            let texture: Texture;\n\n            if (imageTexture instanceof Texture)\n            {\n                texture = imageTexture;\n            }\n            else\n            {\n                const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n\n                const assets = await loader.load<Texture>([{ src: imagePath, data: textureOptions }]);\n\n                texture = assets[imagePath];\n            }\n\n            const spritesheet = new Spritesheet(\n                texture.source,\n                asset,\n            );\n\n            await spritesheet.parse();\n\n            // Check and add the multi atlas\n            // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n            const multiPacks = asset?.meta?.related_multi_packs;\n\n            if (Array.isArray(multiPacks))\n            {\n                const promises: Promise<Spritesheet<SpriteSheetJson>>[] = [];\n\n                for (const item of multiPacks)\n                {\n                    if (typeof item !== 'string')\n                    {\n                        continue;\n                    }\n\n                    let itemUrl = basePath + item;\n\n                    // Check if the file wasn't already added as multipack\n                    if (options.data?.ignoreMultiPack)\n                    {\n                        continue;\n                    }\n\n                    itemUrl = copySearchParams(itemUrl, options.src);\n\n                    promises.push(loader.load<Spritesheet<SpriteSheetJson>>({\n                        src: itemUrl,\n                        data: {\n                            ignoreMultiPack: true,\n                        }\n                    }));\n                }\n\n                const res = await Promise.all(promises);\n\n                spritesheet.linkedSheets = res;\n                res.forEach((item) =>\n                {\n                    item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => (sp !== item)));\n                });\n            }\n\n            return spritesheet;\n        },\n\n        async unload(spritesheet: Spritesheet, _resolvedAsset, loader)\n        {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n\n            spritesheet.destroy(false);\n        },\n    }\n} satisfies AssetExtensionAdvanced<SpriteSheetJson, Spritesheet, Spritesheet, Spritesheet>;\n","\"use strict\";\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n  LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n  LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\nexport { LoaderParserPriority };\n//# sourceMappingURL=LoaderParser.mjs.map\n","import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @enum {number}\n */\nexport enum LoaderParserPriority\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/** A more verbose version of the LoaderParser, allowing you to set the loaded, parsed, and unloaded asset separately */\nexport interface LoaderParserAdvanced<\n    ASSET = any,\n    PARSED_ASSET = ASSET,\n    UNLOAD_ASSET = ASSET,\n    META_DATA = any,\n    CONFIG = Record<string, any>\n>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /** The name of the parser (this can be used when specifying loadParser in a ResolvedAsset) */\n    name: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<ASSET | T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<PARSED_ASSET | T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: UNLOAD_ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void> | void;\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @memberof assets\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n    extends LoaderParserAdvanced<ASSET, ASSET, ASSET, META_DATA, CONFIG> {}\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { createStringVariations } from '../utils/createStringVariations.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = convertToList(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = convertToList(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = convertToList(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[i];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\nexport { Resolver, getUrlExtension };\n//# sourceMappingURL=Resolver.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @memberof assets\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @static\n     * @name RETINA_PREFIX\n     * @type {RegExp}\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let { data, format, loadParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        loadParser = src.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[i];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n\n        return formattedAsset;\n    }\n}\n\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n","import { DOMAdapter } from '../environment/adapter.mjs';\n\n\"use strict\";\nfunction assertPath(path2) {\n  if (typeof path2 !== \"string\") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split(\"?\")[0];\n  return re.split(\"#\")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), \"g\"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = \"\";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += \"/..\";\n          } else {\n            res = \"..\";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, \"\\\\\", \"/\");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith(\"blob:\");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return \"\";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith(\"/\")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = \"\";\n    const isAbsolute = path2.startsWith(\"/\");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith(\"/\");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += \"/\";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith(\"/\");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return \".\";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? \"\";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return \"//\";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = \"\";\n    if (path2.startsWith(\"/\"))\n      root = \"/\";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf(\"/\", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith(\"/\"))\n        root += \"/\";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return \"\";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return \"\";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return \"\";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = \"\";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  joinExtensions: [\".html\"]\n};\n\nexport { path };\n//# sourceMappingURL=path.mjs.map\n","import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @memberof utils\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @see {@link utils.Path}\n * @memberof utils\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n","\"use strict\";\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(\",\");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\nexport { createStringVariations };\n//# sourceMappingURL=createStringVariations.mjs.map\n","function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n","\"use strict\";\nconst isSingleItem = (item) => !Array.isArray(item);\n\nexport { isSingleItem };\n//# sourceMappingURL=isSingleItem.mjs.map\n","/**\n * Checks if the given value is an array.\n * @param item - The item to test\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n","\"use strict\";\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split(\"?\")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\nexport { copySearchParams };\n//# sourceMappingURL=copySearchParams.mjs.map\n","/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n","import { Rectangle } from '../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\nexport { Spritesheet };\n//# sourceMappingURL=Spritesheet.mjs.map\n","import { Rectangle } from '../maths/shapes/Rectangle';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @memberof assets\n */\n\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @memberof assets\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @memberof assets\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /** The maximum number of Textures to build per process. */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to the source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite|Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite|AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport '../../../../utils/utils.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { SystemRunner } from './SystemRunner.mjs';\nimport EventEmitter from 'eventemitter3';\n\n\"use strict\";\nconst defaultRunners = [\n  \"init\",\n  \"destroy\",\n  \"contextChange\",\n  \"resolutionChange\",\n  \"resetState\",\n  \"renderEnd\",\n  \"renderStart\",\n  \"render\",\n  \"update\",\n  \"postrender\",\n  \"prerender\"\n];\nconst _AbstractRenderer = class _AbstractRenderer extends EventEmitter {\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  constructor(config) {\n    super();\n    this.runners = /* @__PURE__ */ Object.create(null);\n    this.renderPipes = /* @__PURE__ */ Object.create(null);\n    this._initOptions = {};\n    this._systemsHash = /* @__PURE__ */ Object.create(null);\n    this.type = config.type;\n    this.name = config.name;\n    this.config = config;\n    const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];\n    this._addRunners(...combinedRunners);\n    this._unsafeEvalCheck();\n  }\n  /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */\n  async init(options = {}) {\n    const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n    await loadEnvironmentExtensions(skip);\n    this._addSystems(this.config.systems);\n    this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n    for (const systemName in this._systemsHash) {\n      const system = this._systemsHash[systemName];\n      const defaultSystemOptions = system.constructor.defaultOptions;\n      options = { ...defaultSystemOptions, ...options };\n    }\n    options = { ..._AbstractRenderer.defaultOptions, ...options };\n    this._roundPixels = options.roundPixels ? 1 : 0;\n    for (let i = 0; i < this.runners.init.items.length; i++) {\n      await this.runners.init.items[i].init(options);\n    }\n    this._initOptions = options;\n  }\n  render(args, deprecated) {\n    let options = args;\n    if (options instanceof Container) {\n      options = { container: options };\n      if (deprecated) {\n        deprecation(v8_0_0, \"passing a second argument is deprecated, please use render options instead\");\n        options.target = deprecated.renderTexture;\n      }\n    }\n    options.target || (options.target = this.view.renderTarget);\n    if (options.target === this.view.renderTarget) {\n      this._lastObjectRendered = options.container;\n      options.clearColor ?? (options.clearColor = this.background.colorRgba);\n      options.clear ?? (options.clear = this.background.clearBeforeRender);\n    }\n    if (options.clearColor) {\n      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n      options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n    }\n    if (!options.transform) {\n      options.container.updateLocalTransform();\n      options.transform = options.container.localTransform;\n    }\n    options.container.enableRenderGroup();\n    this.runners.prerender.emit(options);\n    this.runners.renderStart.emit(options);\n    this.runners.render.emit(options);\n    this.runners.renderEnd.emit(options);\n    this.runners.postrender.emit(options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    const previousResolution = this.view.resolution;\n    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.emit(\"resize\", this.view.screen.width, this.view.screen.height, this.view.resolution);\n    if (resolution !== void 0 && resolution !== previousResolution) {\n      this.runners.resolutionChange.emit(resolution);\n    }\n  }\n  clear(options = {}) {\n    const renderer = this;\n    options.target || (options.target = renderer.renderTarget.renderTarget);\n    options.clearColor || (options.clearColor = this.background.colorRgba);\n    options.clear ?? (options.clear = CLEAR.ALL);\n    const { clear, clearColor, target } = options;\n    Color.shared.setValue(clearColor ?? this.background.colorRgba);\n    renderer.renderTarget.clear(target, clear, Color.shared.toArray());\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.view.resolution;\n  }\n  set resolution(value) {\n    this.view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this.view.texture.frame.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this.view.texture.frame.height;\n  }\n  // NOTE: this was `view` in v7\n  /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */\n  get canvas() {\n    return this.view.canvas;\n  }\n  /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */\n  get lastObjectRendered() {\n    return this._lastObjectRendered;\n  }\n  /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */\n  get renderingToScreen() {\n    const renderer = this;\n    return renderer.renderTarget.renderingToScreen;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */\n  get screen() {\n    return this.view.screen;\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  _addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new SystemRunner(runnerId);\n    });\n  }\n  _addSystems(systems) {\n    let i;\n    for (i in systems) {\n      const val = systems[i];\n      this._addSystem(val.value, val.name);\n    }\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn't collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  _addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name \"${name}\" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  _addPipes(pipes, pipeAdaptors) {\n    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {\n      acc[adaptor.name] = adaptor.value;\n      return acc;\n    }, {});\n    pipes.forEach((pipe) => {\n      const PipeClass = pipe.value;\n      const name = pipe.name;\n      const Adaptor = adaptors[name];\n      this.renderPipes[name] = new PipeClass(\n        this,\n        Adaptor ? new Adaptor() : null\n      );\n    });\n  }\n  destroy(options = false) {\n    this.runners.destroy.items.reverse();\n    this.runners.destroy.emit(options);\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = null;\n    this.renderPipes = null;\n  }\n  /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */\n  generateTexture(options) {\n    return this.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   * @ignore\n   */\n  _unsafeEvalCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  /**\n   * Resets the rendering state of the renderer.\n   * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n   * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n   * render will reset all internal caches and ensure it executes correctly.\n   *\n   * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n   * ```js\n   * // Reset Three.js state\n   * threeRenderer.resetState();\n   *\n   * // Render a Three.js scene\n   * threeRenderer.render(threeScene, threeCamera);\n   *\n   * // Reset PixiJS state since Three.js modified the WebGL context\n   * pixiRenderer.resetState();\n   *\n   * // Now render Pixi content\n   * pixiRenderer.render(pixiScene);\n   * ```\n   */\n  resetState() {\n    this.runners.resetState.emit();\n  }\n};\n/** The default options for the renderer. */\n_AbstractRenderer.defaultOptions = {\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */\n  resolution: 1,\n  /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat: false,\n  /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */\n  roundPixels: false\n};\nlet AbstractRenderer = _AbstractRenderer;\n\nexport { AbstractRenderer };\n//# sourceMappingURL=AbstractRenderer.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment';\nimport { Container } from '../../../../scene/container/Container';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { EventEmitter } from '../../../../utils/utils';\nimport { CLEAR } from '../../gl/const';\nimport { SystemRunner } from './SystemRunner';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { Renderer } from '../../types';\nimport type { BackgroundSystem } from '../background/BackgroundSystem';\nimport type { GenerateTextureOptions, GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport type { PipeConstructor } from '../instructions/RenderPipe';\nimport type { RenderSurface } from '../renderTarget/RenderTargetSystem';\nimport type { Texture } from '../texture/Texture';\nimport type { ViewSystem, ViewSystemDestroyOptions } from '../view/ViewSystem';\nimport type { SharedRendererOptions } from './SharedSystems';\nimport type { System, SystemConstructor } from './System';\n\nexport interface RendererConfig\n{\n    type: number;\n    name: string;\n    runners?: string[];\n    systems: {name: string, value: SystemConstructor}[];\n    renderPipes: {name: string, value: PipeConstructor}[];\n    renderPipeAdaptors: {name: string, value: any}[];\n}\n\n/**\n * The options for rendering a view.\n * @memberof rendering\n */\nexport interface RenderOptions extends ClearOptions\n{\n    /** The container to render. */\n    container: Container;\n    /** the transform to apply to the container. */\n    transform?: Matrix;\n}\n\n/**\n * The options for clearing the render target.\n * @memberof rendering\n */\nexport interface ClearOptions\n{\n    /**\n     * The render target to render. if this target is a canvas and  you are using the WebGL renderer,\n     * please ensure you have set `multiView` to `true` on renderer.\n     */\n    target?: RenderSurface;\n    /** The color to clear with. */\n    clearColor?: ColorSource;\n    /** The clear mode to use. */\n    clear?: CLEAR_OR_BOOL\n}\n\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions>;\n\nconst defaultRunners = [\n    'init',\n    'destroy',\n    'contextChange',\n    'resolutionChange',\n    'resetState',\n    'renderEnd',\n    'renderStart',\n    'render',\n    'update',\n    'postrender',\n    'prerender'\n] as const;\n\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {[key in DefaultRunners]: SystemRunner} & {\n    [K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n\n/* eslint-disable max-len */\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@linkrendering.WebGLRenderer}\n * or {@link rendering.WebGPURenderer}.\n * Alternatively, you can also use {@link rendering.autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link rendering.BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link events.EventSystem}           | This manages UI events.                                                       |\n * | {@link accessibility.AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.RenderGroupSystem} | This manages the what what we are rendering to (eg - canvas or texture)   |\n * | {@link rendering.GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link rendering.TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link rendering.GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link rendering.FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link rendering.PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link rendering.ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @memberof rendering\n * @property {rendering.HelloSystem} hello - HelloSystem instance.\n * @property {rendering.RenderGroupSystem} renderGroup - RenderGroupSystem instance.\n * @property {rendering.TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {rendering.FilterSystem} filter - FilterSystem instance.\n * @property {rendering.GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {rendering.TextureSystem} texture - TextureSystem instance.\n * @property {rendering.EventSystem} events - EventSystem instance.\n * @property {rendering.ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {rendering.PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {rendering.AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\n/* eslint-enable max-len */\nexport class AbstractRenderer<\n    PIPES, OPTIONS extends SharedRendererOptions, CANVAS extends ICanvas = HTMLCanvasElement\n> extends EventEmitter<{resize: [screenWidth: number, screenHeight: number, resolution: number]}>\n{\n    /** The default options for the renderer. */\n    public static defaultOptions = {\n        /**\n         * Default resolution / device pixel ratio of the renderer.\n         * @default 1\n         */\n        resolution: 1,\n        /**\n         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n         * performance issues when using WebGL.\n         *\n         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n         * driver version blacklisted by the\n         * browser.\n         *\n         * If your application requires high performance rendering, you may wish to set this to false.\n         * We recommend one of two options if you decide to set this flag to false:\n         *\n         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n         *    not supported.\n         *\n         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n         *    device & browser combination does not support high performance WebGL.\n         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n         * @default false\n         */\n        failIfMajorPerformanceCaveat: false,\n        /**\n         * Should round pixels be forced when rendering?\n         * @default false\n         */\n        roundPixels: false\n    };\n\n    public readonly type: number;\n    /** The name of the renderer. */\n    public readonly name: string;\n\n    public _roundPixels: 0 | 1;\n\n    public readonly runners: Runners = Object.create(null) as Runners;\n    public readonly renderPipes = Object.create(null) as PIPES;\n    /** The view system manages the main canvas that is attached to the DOM */\n    public view!: ViewSystem;\n    /** The background system manages the background color and alpha of the main view. */\n    public background: BackgroundSystem;\n    /** System that manages the generation of textures from the renderer */\n    public textureGenerator: GenerateTextureSystem;\n\n    protected _initOptions: OPTIONS = {} as OPTIONS;\n    protected config: RendererConfig;\n\n    private _systemsHash: Record<string, System> = Object.create(null);\n    private _lastObjectRendered: Container;\n\n    /**\n     * Set up a system with a collection of SystemClasses and runners.\n     * Systems are attached dynamically to this class when added.\n     * @param config - the config for the system manager\n     */\n    constructor(config: RendererConfig)\n    {\n        super();\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n\n        const combinedRunners = [...defaultRunners, ...(this.config.runners ?? [])];\n\n        this._addRunners(...combinedRunners);\n        // Validation check that this environment support `new Function`\n        this._unsafeEvalCheck();\n    }\n\n    /**\n     * Initialize the renderer.\n     * @param options - The options to use to create the renderer.\n     */\n    public async init(options: Partial<OPTIONS> = {})\n    {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n\n        await loadEnvironmentExtensions(skip);\n\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n\n        // loop through all systems...\n        for (const systemName in this._systemsHash)\n        {\n            const system = this._systemsHash[systemName];\n\n            const defaultSystemOptions = (system.constructor as any).defaultOptions;\n\n            options = { ...defaultSystemOptions, ...options };\n        }\n\n        options = { ...AbstractRenderer.defaultOptions, ...options };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n\n        // await emits..\n        for (let i = 0; i < this.runners.init.items.length; i++)\n        {\n            await this.runners.init.items[i].init(options);\n        }\n\n        // store options\n        this._initOptions = options as OPTIONS;\n    }\n\n    /**\n     * Renders the object to its view.\n     * @param options - The options to render with.\n     * @param options.container - The container to render.\n     * @param [options.target] - The target to render to.\n     */\n    public render(options: RenderOptions | Container): void;\n    /** @deprecated since 8.0.0 */\n    public render(container: Container, options: {renderTexture: any}): void;\n    public render(args: RenderOptions | Container, deprecated?: {renderTexture: any}): void\n    {\n        let options = args;\n\n        if (options instanceof Container)\n        {\n            options = { container: options };\n\n            if (deprecated)\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'passing a second argument is deprecated, please use render options instead');\n                // #endif\n\n                options.target = deprecated.renderTexture;\n            }\n        }\n\n        options.target ||= this.view.renderTarget;\n\n        // TODO: we should eventually fix events so that it can handle multiple canvas elements\n        if (options.target === this.view.renderTarget)\n        {\n            // TODO get rid of this\n            this._lastObjectRendered = options.container;\n\n            options.clearColor ??= this.background.colorRgba;\n            options.clear ??= this.background.clearBeforeRender;\n        }\n\n        if (options.clearColor)\n        {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n\n            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n        }\n\n        if (!options.transform)\n        {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n\n        // lets ensure this object is a render group so we can render it!\n        // the renderer only likes to render - render groups.\n        options.container.enableRenderGroup();\n\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n\n    /**\n     * Resizes the WebGL view to the specified width and height.\n     * @param desiredScreenWidth - The desired width of the screen.\n     * @param desiredScreenHeight - The desired height of the screen.\n     * @param resolution - The resolution / device pixel ratio of the renderer.\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void\n    {\n        const previousResolution = this.view.resolution;\n\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit('resize', this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== undefined && resolution !== previousResolution)\n        {\n            this.runners.resolutionChange.emit(resolution);\n        }\n    }\n\n    public clear(options: ClearOptions = {}): void\n    {\n        // override!\n        const renderer = this as unknown as Renderer;\n\n        options.target ||= renderer.renderTarget.renderTarget;\n        options.clearColor ||= this.background.colorRgba;\n        options.clear ??= CLEAR.ALL;\n\n        const { clear, clearColor, target } = options;\n\n        Color.shared.setValue(clearColor ?? this.background.colorRgba);\n\n        renderer.renderTarget.clear(target, clear, Color.shared.toArray() as RgbaArray);\n    }\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.view.resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n\n    /**\n     * Same as view.width, actual number of pixels in the canvas by horizontal.\n     * @member {number}\n     * @readonly\n     * @default 800\n     */\n    get width(): number\n    {\n        return this.view.texture.frame.width;\n    }\n\n    /**\n     * Same as view.height, actual number of pixels in the canvas by vertical.\n     * @default 600\n     */\n    get height(): number\n    {\n        return this.view.texture.frame.height;\n    }\n\n    // NOTE: this was `view` in v7\n    /**\n     * The canvas element that everything is drawn to.\n     * @type {environment.ICanvas}\n     */\n    get canvas(): CANVAS\n    {\n        return this.view.canvas as CANVAS;\n    }\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    get lastObjectRendered(): Container\n    {\n        return this._lastObjectRendered;\n    }\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    get renderingToScreen(): boolean\n    {\n        const renderer = this as unknown as Renderer;\n\n        return renderer.renderTarget.renderingToScreen;\n    }\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    get screen(): Rectangle\n    {\n        return this.view.screen;\n    }\n\n    /**\n     * Create a bunch of runners based of a collection of ids\n     * @param runnerIds - the runner ids to add\n     */\n    private _addRunners(...runnerIds: string[]): void\n    {\n        runnerIds.forEach((runnerId) =>\n        {\n            this.runners[runnerId] = new SystemRunner(runnerId);\n        });\n    }\n\n    private _addSystems(systems: RendererConfig['systems']): void\n    {\n        let i: keyof typeof systems;\n\n        for (i in systems)\n        {\n            const val = systems[i];\n\n            this._addSystem(val.value, val.name);\n        }\n    }\n\n    /**\n     * Add a new system to the renderer.\n     * @param ClassRef - Class reference\n     * @param name - Property name for system, if not specified\n     *        will use a static `name` property on the class itself. This\n     *        name will be assigned as s property on the Renderer so make\n     *        sure it doesn't collide with properties on Renderer.\n     * @returns Return instance of renderer\n     */\n    private _addSystem(ClassRef: SystemConstructor, name: string): this\n    {\n        const system = new ClassRef(this as unknown as Renderer);\n\n        if ((this as any)[name])\n        {\n            throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        }\n\n        (this as any)[name] = system;\n\n        this._systemsHash[name] = system;\n\n        for (const i in this.runners)\n        {\n            this.runners[i].add(system);\n        }\n\n        return this;\n    }\n\n    private _addPipes(pipes: RendererConfig['renderPipes'], pipeAdaptors: RendererConfig['renderPipeAdaptors']): void\n    {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor) =>\n        {\n            acc[adaptor.name] = adaptor.value;\n\n            return acc;\n        }, {} as Record<string, any>);\n\n        pipes.forEach((pipe) =>\n        {\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n\n            const Adaptor = adaptors[name];\n\n            // sorry typescript..\n            (this.renderPipes as any)[name] = new PipeClass(\n                this as unknown as Renderer,\n                Adaptor ? new Adaptor() : null\n            );\n        });\n    }\n\n    public destroy(options: RendererDestroyOptions = false): void\n    {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n\n        // destroy all runners\n        Object.values(this.runners).forEach((runner) =>\n        {\n            runner.destroy();\n        });\n\n        this._systemsHash = null;\n\n        // destroy all pipes\n        (this.renderPipes as null) = null;\n    }\n\n    /**\n     * Generate a texture from a container.\n     * @param options - options or container target to use when generating the texture\n     * @returns a texture\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        return this.textureGenerator.generateTexture(options);\n    }\n\n    /**\n     * Whether the renderer will round coordinates to whole pixels when rendering.\n     * Can be overridden on a per scene item basis.\n     */\n    get roundPixels(): boolean\n    {\n        return !!this._roundPixels;\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     * @ignore\n     */\n    public _unsafeEvalCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n               + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n    /**\n     * Resets the rendering state of the renderer.\n     * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n     * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n     * render will reset all internal caches and ensure it executes correctly.\n     *\n     * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n     * ```js\n     * // Reset Three.js state\n     * threeRenderer.resetState();\n     *\n     * // Render a Three.js scene\n     * threeRenderer.render(threeScene, threeCamera);\n     *\n     * // Reset PixiJS state since Three.js modified the WebGL context\n     * pixiRenderer.resetState();\n     *\n     * // Now render Pixi content\n     * pixiRenderer.render(pixiScene);\n     * ```\n     */\n    public resetState(): void\n    {\n        this.runners.resetState.emit();\n    }\n}\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst environments = [];\nextensions.handleByNamedList(ExtensionType.Environment, environments);\nasync function loadEnvironmentExtensions(skip) {\n  if (skip)\n    return;\n  for (let i = 0; i < environments.length; i++) {\n    const env = environments[i];\n    if (env.value.test()) {\n      await env.value.load();\n      return;\n    }\n  }\n}\nasync function autoDetectEnvironment(add) {\n  return loadEnvironmentExtensions(!add);\n}\n\nexport { autoDetectEnvironment, loadEnvironmentExtensions };\n//# sourceMappingURL=autoDetectEnvironment.mjs.map\n","import { extensions, ExtensionType } from '../extensions/Extensions';\n\nconst environments: { name: string; value: { test: () => boolean; load: () => Promise<boolean> } }[] = [];\n\nextensions.handleByNamedList(ExtensionType.Environment, environments);\n\n/**\n * Automatically detects the environment and loads the appropriate extensions.\n * @param skip - whether to skip loading the default extensions\n */\nexport async function loadEnvironmentExtensions(skip: boolean): Promise<void>\n{\n    if (skip) return;\n\n    for (let i = 0; i < environments.length; i++)\n    {\n        const env = environments[i];\n\n        if (env.value.test())\n        {\n            await env.value.load();\n\n            return;\n        }\n    }\n}\n\n/**\n * @param add - whether to add the default imports to the bundle\n * @deprecated since 8.1.6. Use `loadEnvironmentExtensions` instead\n */\nexport async function autoDetectEnvironment(add: boolean): Promise<void>\n{\n    return loadEnvironmentExtensions(!add);\n}\n","\"use strict\";\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === \"boolean\") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = func({ a: \"b\" }, \"a\", \"b\") === true;\n  } catch (_e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\nexport { unsafeEvalSupported };\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n","// Cache the result to prevent running this over and over\nlet unsafeEval: boolean;\n\n/**\n * Not all platforms allow to generate function code (e.g., `new Function`).\n * this provides the platform-level detection.\n * @private\n * @returns {boolean} `true` if `new Function` is supported.\n */\nexport function unsafeEvalSupported(): boolean\n{\n    if (typeof unsafeEval === 'boolean')\n    {\n        return unsafeEval;\n    }\n\n    try\n    {\n        /* eslint-disable no-new-func */\n        const func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');\n        /* eslint-enable no-new-func */\n\n        unsafeEval = func({ a: 'b' }, 'a', 'b') === true;\n    }\n    catch (_e)\n    {\n        unsafeEval = false;\n    }\n\n    return unsafeEval;\n}\n","\"use strict\";\nvar CLEAR = /* @__PURE__ */ ((CLEAR2) => {\n  CLEAR2[CLEAR2[\"NONE\"] = 0] = \"NONE\";\n  CLEAR2[CLEAR2[\"COLOR\"] = 16384] = \"COLOR\";\n  CLEAR2[CLEAR2[\"STENCIL\"] = 1024] = \"STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH\"] = 256] = \"DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_DEPTH\"] = 16640] = \"COLOR_DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_STENCIL\"] = 17408] = \"COLOR_STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH_STENCIL\"] = 1280] = \"DEPTH_STENCIL\";\n  CLEAR2[CLEAR2[\"ALL\"] = 17664] = \"ALL\";\n  return CLEAR2;\n})(CLEAR || {});\n\nexport { CLEAR };\n//# sourceMappingURL=const.mjs.map\n","export enum CLEAR\n{\n    NONE = 0,\n    COLOR = 16384,\n    STENCIL = 1024,\n    DEPTH = 256,\n\n    COLOR_DEPTH = COLOR | DEPTH,\n    COLOR_STENCIL = COLOR | STENCIL,\n    DEPTH_STENCIL = DEPTH | STENCIL,\n    ALL = COLOR | DEPTH | STENCIL,\n\n}\n\n/** Used for clearing render textures. true is the same as `ALL` false is the same as `NONE` */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n","\"use strict\";\nclass SystemRunner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n  }\n  /* jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /* jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    const { name, items } = this;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    return this;\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    if (item[this._name]) {\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    this.items.length = 0;\n    return this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\n\nexport { SystemRunner };\n//# sourceMappingURL=SystemRunner.mjs.map\n","/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @memberof rendering\n */\nexport class SystemRunner\n{\n    public items: any[];\n    private _name: string;\n\n    /**\n     * @param name - The function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name: string)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /* jsdoc/check-param-names */\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - (optional) parameters to pass to each listener\n     */\n    /* jsdoc/check-param-names */\n    public emit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown,\n        a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this\n    {\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```\n     * import { Runner } from 'pixi.js';\n     *\n     * const complete = new Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     * @param {any} item - The object that will be listening.\n     */\n    public add(item: unknown): this\n    {\n        if ((item as any)[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listener that you would like to remove.\n     */\n    public remove(item: unknown): this\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    public contains(item: unknown): boolean\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /** Remove all listeners from the Runner */\n    public removeAll(): this\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /** Remove all references, don't use after this. */\n    public destroy(): void\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     * @readonly\n     */\n    public get empty(): boolean\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     * @readonly\n     */\n    public get name(): string\n    {\n        return this._name;\n    }\n}\n","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = Promise.all([load(\"gyKa4\"), load(\"fqXAI\")]).then(() => parcelRequire('hfuCN'));","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = Promise.all([load(\"gyKa4\"), load(\"dgumL\")]).then(() => parcelRequire('c8FrZ'));","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { VERSION } from '../const.mjs';\n\n\"use strict\";\nclass ApplicationInitHook {\n  static init() {\n    globalThis.__PIXI_APP_INIT__?.(this, VERSION);\n  }\n  static destroy() {\n  }\n}\n/** @ignore */\nApplicationInitHook.extension = ExtensionType.Application;\nclass RendererInitHook {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  init() {\n    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nRendererInitHook.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"initHook\",\n  priority: -10\n};\n\nexport { ApplicationInitHook, RendererInitHook };\n//# sourceMappingURL=globalHooks.mjs.map\n","import { type ExtensionMetadata, ExtensionType } from '../../extensions/Extensions';\nimport { VERSION } from '../const';\n\nimport type { Application } from '../../app/Application';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\n\ndeclare global\n{\n    /* eslint-disable no-var */\n    var __PIXI_APP_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    var __PIXI_RENDERER_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    /* eslint-enable no-var */\n}\n\n/**\n * Calls global __PIXI_APP_INIT__ hook with the application instance, after the application is initialized.\n * @memberof app\n */\nexport class ApplicationInitHook\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    public static init(): void\n    {\n        globalThis.__PIXI_APP_INIT__?.(this as unknown as Application, VERSION);\n    }\n    public static destroy(): void\n    {\n        // nothing to do\n    }\n}\n\n/**\n * Calls global __PIXI_RENDERER_INIT__ hook with the renderer instance, after the renderer is initialized.\n * @memberof rendering\n */\nexport class RendererInitHook implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'initHook',\n        priority: -10,\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n    public init(): void\n    {\n        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);\n    }\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","export { default as EventEmitter } from 'eventemitter3';\n\n\"use strict\";\nconst DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\nconst VERSION = \"8.7.2\";\n\nexport { DATA_URI, VERSION };\n//# sourceMappingURL=const.mjs.map\n","import EventEmitter from 'eventemitter3';\n\n/**\n * Regexp for data URI.\n * Based on: {@link https://github.com/ragingwind/data-uri-regex}\n * @static\n * @type {RegExp}\n * @default /(?:^data:image\\/([\\w+]+);(?:[\\w=]+|charset=[\\w-]+)?(?:;base64)?,)/i\n * @example\n * import { DATA_URI } from 'pixi.js';\n *\n * DATA_URI.test('data:image/png;base64,foobar'); // => true\n * @memberof utils\n */\nexport const DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n// export the event emitter so we can use it in external modules\nexport { EventEmitter };\n\n/** The current version of PixiJS. This is automatically replaced by the build process. */\nexport const VERSION = '$_VERSION';\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { DynamicBitmapFont } from './DynamicBitmapFont.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nlet fontCount = 0;\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [[\"0\", \"9\"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[\" \", \"~\"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill && !style._stroke) {\n      fontFamilyKey += style._fill.fill.styleKey;\n      overrideFill = false;\n    } else if (style._stroke || style.dropShadow) {\n      let key = style.styleKey;\n      key = key.substring(0, key.lastIndexOf(\"-\"));\n      fontFamilyKey = `${key}-bitmap`;\n      overrideFill = false;\n    }\n    if (!Cache.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fontCount++;\n      if (fontCount > 50) {\n        warn(\"BitmapText\", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n      }\n      fnt.once(\"destroy\", () => {\n        fontCount--;\n        Cache.remove(fontFamilyKey);\n      });\n      Cache.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  getLayout(text, style, trimEnd = true) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  measureText(text, style, trimEnd = true) {\n    return this.getLayout(text, style, trimEnd);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === \"string\") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      deprecation(v8_0_0, \"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})\");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error(\"[BitmapFontManager] Property `name` is required.\");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(\"\"));\n    Cache.set(`${name}-bitmap`, font);\n    font.once(\"destroy\", () => Cache.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache.get(cacheKey);\n    if (font) {\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\nexport { BitmapFontManager };\n//# sourceMappingURL=BitmapFontManager.mjs.map\n","import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\nlet fontCount = 0;\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill && !style._stroke)\n        {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        }\n        else if (style._stroke || style.dropShadow)\n        {\n            // if there is a stoke, we need to use the style key as this the font generated cannot be tinted\n            // due to the fact the font has at least two colors.\n            let key = style.styleKey;\n\n            // remove the font size..\n            key = key.substring(0, key.lastIndexOf('-'));\n\n            fontFamilyKey = `${key}-bitmap`;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fontCount++;\n\n            // warn users if they have created too many dynamic fonts\n            if (fontCount > 50)\n            {\n                // eslint-disable-next-line max-len\n                warn('BitmapText', `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            }\n\n            fnt.once('destroy', () =>\n            {\n                fontCount--;\n                Cache.remove(fontFamilyKey);\n            });\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public getLayout(text: string, style: TextStyle, trimEnd: boolean = true): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public measureText(\n        text: string,\n        style: TextStyle,\n        trimEnd: boolean = true\n    ): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style, trimEnd);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient.mjs';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern.mjs';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext.mjs';\nimport { toFillStyle, toStrokeStyle } from '../graphics/shared/utils/convertFillInputToFillStyle.mjs';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey.mjs';\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends EventEmitter {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = this._createProxy({ ..._TextStyle.defaultDropShadow, ...value });\n    } else {\n      this._dropShadow = value ? this._createProxy({ ..._TextStyle.defaultDropShadow }) : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value.toLowerCase();\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    if (this._isFillStyle(value)) {\n      this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () => {\n        this._fill = toFillStyle(\n          { ...this._originalFill },\n          GraphicsContext.defaultFillStyle\n        );\n      });\n    }\n    this._fill = toFillStyle(\n      value === 0 ? \"black\" : value,\n      GraphicsContext.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    if (this._isFillStyle(value)) {\n      this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () => {\n        this._stroke = toStrokeStyle(\n          { ...this._originalStroke },\n          GraphicsContext.defaultStrokeStyle\n        );\n      });\n    }\n    this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = generateTextStyleKey(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n  _createProxy(value, cb) {\n    return new Proxy(value, {\n      set: (target, property, newValue) => {\n        target[property] = newValue;\n        cb?.(property, newValue);\n        this.update();\n        return true;\n      }\n    });\n  }\n  _isFillStyle(value) {\n    return (value ?? null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n  color: \"black\",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  align: \"left\",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: \"black\",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: \"Arial\",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  fontStyle: \"normal\",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */\n  fontVariant: \"normal\",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  fontWeight: \"normal\",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  textBaseline: \"alphabetic\",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  whiteSpace: \"pre\",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness !== void 0) {\n    deprecation(v8_0_0, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    let obj = {};\n    if (Color.isColorLike(color)) {\n      obj.color = color;\n    } else if (color instanceof FillGradient || color instanceof FillPattern) {\n      obj.fill = color;\n    } else if (Object.hasOwnProperty.call(color, \"color\") || Object.hasOwnProperty.call(color, \"fill\")) {\n      obj = color;\n    } else {\n      throw new Error(\"Invalid stroke value.\");\n    }\n    style.stroke = {\n      ...obj,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fillGradientStops)) {\n    deprecation(v8_0_0, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    let fontSize;\n    if (style.fontSize == null) {\n      style.fontSize = TextStyle.defaultTextStyle.fontSize;\n    } else if (typeof style.fontSize === \"string\") {\n      fontSize = parseInt(style.fontSize, 10);\n    } else {\n      fontSize = style.fontSize;\n    }\n    const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);\n    const fills = oldStyle.fillGradientStops.map((color) => Color.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = index / (fills.length - 1);\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\nexport { TextStyle };\n//# sourceMappingURL=TextStyle.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport {\n    toFillStyle,\n    toStrokeStyle\n} from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n    StrokeStyle\n} from '../graphics/shared/FillTypes';\n\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n// eslint-disable-next-line max-len\nexport type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * A collection of text related classes.\n * @namespace text\n */\n\n/**\n * A drop shadow effect.\n * @memberof text\n */\nexport type TextDropShadow = {\n    /** Set alpha for the drop shadow  */\n    alpha: number;\n    /** Set a angle of the drop shadow */\n    angle: number;\n    /** Set a shadow blur radius */\n    blur: number;\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n    color: ColorSource;\n    /** Set a distance of the drop shadow */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances.\n * ```js\n * const textStyle = new TextStyle({\n *    fontSize: 12,\n *    fill: 'black',\n * });\n * ```\n * @see {@link text.TextStyle}\n * @memberof text\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align?: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs `wordWrap` to be set to `true` */\n    breakWords?: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill?: FillInput;\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    fontFamily?: string | string[];\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    fontSize?: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke?: StrokeInput;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline?: TextStyleTextBaseline;\n    trim?: boolean,\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n}\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @memberof text\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /** The default drop shadow settings */\n    public static defaultDropShadow: TextDropShadow = {\n        /** Set alpha for the drop shadow */\n        alpha: 1,\n        /** Set a angle of the drop shadow */\n        angle: Math.PI / 6,\n        /** Set a shadow blur radius */\n        blur: 0,\n        /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n        color: 'black',\n        /** Set a distance of the drop shadow */\n        distance: 5,\n    };\n\n    /** The default text style settings */\n    public static defaultTextStyle: TextStyleOptions = {\n        /**\n         * See {@link TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link TextStyle.dropShadow} */\n        dropShadow:  null,\n        /**\n         * See {@link TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link TextStyle.fontSize}\n         * @type {number|string}\n         */\n        fontSize: 26,\n        /**\n         * See {@link TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link TextStyle.leading} */\n        leading: 0,\n        /** See {@link TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link TextStyle.lineHeight} */\n        lineHeight: 0,\n        /** See {@link TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: null,\n        /**\n         * See {@link TextStyle.textBaseline}\n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillInput;\n\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: StrokeInput;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n\n    private _padding: number;\n\n    protected _styleKey: string;\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = this._createProxy({ ...TextStyle.defaultDropShadow, ...value });\n        }\n        else\n        {\n            this._dropShadow = value ? this._createProxy({ ...TextStyle.defaultDropShadow }) : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle)\n    {\n        this._fontStyle = value.toLowerCase() as TextStyleFontStyle;\n        this.update();\n    }\n    /**\n     * The font variant.\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n    get fill(): FillInput\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillInput)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () =>\n            {\n                this._fill = toFillStyle(\n                    { ...this._originalFill as FillStyle },\n                    GraphicsContext.defaultFillStyle\n                );\n            });\n        }\n\n        this._fill = toFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): StrokeInput\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: StrokeInput)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () =>\n            {\n                this._stroke = toStrokeStyle(\n                    { ...this._originalStroke as StrokeStyle },\n                    GraphicsContext.defaultStrokeStyle\n                );\n            });\n        }\n\n        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    protected _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this);\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._styleKey = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    get styleKey()\n    {\n        return this._styleKey || this._generateKey();\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n        });\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n\n    private _createProxy<T extends object>(value: T, cb?: (property: string, newValue: any) => void): T\n    {\n        return new Proxy<T>(value, {\n            set: (target, property, newValue) =>\n            {\n                target[property as keyof T] = newValue;\n                cb?.(property as string, newValue);\n                this.update();\n\n                return true;\n            }\n        });\n    }\n\n    private _isFillStyle(value: FillInput): value is FillStyle\n    {\n        return ((value ?? null) !== null\n            && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern));\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as TextStyleOptions & {\n        dropShadowAlpha?: number;\n        dropShadowAngle?: number;\n        dropShadowBlur?: number;\n        dropShadowColor?: number;\n        dropShadowDistance?: number;\n        fillGradientStops?: number[];\n        strokeThickness?: number;\n    };\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n        let obj: FillStyle = {};\n\n        // handles stroke: 0x0, stroke: { r: 0, g: 0, b: 0, a: 0 } stroke: new Color(0x0)\n        if (Color.isColorLike(color as ColorSource))\n        {\n            obj.color = color as ColorSource;\n        }\n        // handles stroke: new FillGradient()\n        else if (color instanceof FillGradient || color instanceof FillPattern)\n        {\n            obj.fill = color as FillGradient | FillPattern;\n        }\n        // handles stroke: { color: 0x0 } or stroke: { fill: new FillGradient() }\n        else if (Object.hasOwnProperty.call(color, 'color') || Object.hasOwnProperty.call(color, 'fill'))\n        {\n            obj = color as FillStyle;\n        }\n        else\n        {\n            throw new Error('Invalid stroke value.');\n        }\n\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fillGradientStops))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        let fontSize: number;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style.fontSize == null)\n        {\n            style.fontSize = TextStyle.defaultTextStyle.fontSize;\n        }\n        else if (typeof style.fontSize === 'string')\n        {\n            // eg '34px' to number\n            fontSize = parseInt(style.fontSize as string, 10);\n        }\n        else\n        {\n            fontSize = style.fontSize as number;\n        }\n\n        const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);\n\n        const fills: number[] = oldStyle.fillGradientStops\n            .map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fills.forEach((number, index) =>\n        {\n            const ratio = index / (fills.length - 1);\n\n            gradientFill.addColorStop(ratio, number);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n","import { Color } from '../../../../color/Color.mjs';\nimport { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    /** unique id for this fill gradient */\n    this.uid = uid(\"fillGradient\");\n    this.type = \"linear\";\n    this.gradientStops = [];\n    this._styleKey = null;\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n    this._styleKey = null;\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    if (this.texture)\n      return;\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext(\"2d\");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new Texture({\n      source: new ImageSource({\n        resource: canvas,\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"repeat\"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new Matrix();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey) {\n      return this._styleKey;\n    }\n    const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join(\"-\");\n    const texture = this.texture.uid;\n    const transform = this.transform.toArray().join(\"-\");\n    return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\nexport { FillGradient };\n//# sourceMappingURL=FillGradient.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { ColorSource } from '../../../../color/Color';\n\nexport type GradientType = 'linear' | 'radial';\n\n// export type GradientSource =\n//     string // CSS gradient string: 'linear-gradient(...)'\n//     | IGradientOptions // Gradient options: { x0, y0, x1, y1, ...}\n//     | Gradient; // class Gradient itself\n\nexport interface LinearGradientFillStyle\n{\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    colors: number[];\n    stops: number[];\n}\n\nexport class FillGradient implements CanvasGradient\n{\n    public static defaultTextureSize = 256;\n\n    /** unique id for this fill gradient */\n    public readonly uid: number = uid('fillGradient');\n    public readonly type: GradientType = 'linear';\n\n    public x0: number;\n    public y0: number;\n    public x1: number;\n    public y1: number;\n\n    public texture: Texture;\n    public transform: Matrix;\n    public gradientStops: Array<{ offset: number, color: string }> = [];\n\n    private _styleKey: string | null = null;\n\n    constructor(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.x0 = x0;\n        this.y0 = y0;\n\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n        this._styleKey = null;\n\n        return this;\n    }\n\n    // TODO move to the system!\n    public buildLinearGradient(): void\n    {\n        if (this.texture) return;\n\n        const defaultSize = FillGradient.defaultTextureSize;\n\n        const { gradientStops } = this;\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n\n        const ctx = canvas.getContext('2d');\n\n        const gradient = ctx.createLinearGradient(0, 0, FillGradient.defaultTextureSize, 1);\n\n        for (let i = 0; i < gradientStops.length; i++)\n        {\n            const stop = gradientStops[i];\n\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'repeat',\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const { x0, y0, x1, y1 } = this;\n\n        const m = new Matrix();\n\n        // get angle\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n\n        const angle = Math.atan2(dy, dx);\n\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n\n        this.transform = m;\n        this._styleKey = null;\n    }\n\n    public get styleKey(): string\n    {\n        if (this._styleKey)\n        {\n            return this._styleKey;\n        }\n\n        const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join('-');\n        const texture = this.texture.uid;\n        const transform = this.transform.toArray().join('-');\n\n        return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: \"repeat\",\n    addressModeV: \"repeat\"\n  },\n  \"repeat-x\": {\n    addressModeU: \"repeat\",\n    addressModeV: \"clamp-to-edge\"\n  },\n  \"repeat-y\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"repeat\"\n  },\n  \"no-repeat\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"clamp-to-edge\"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    /** unique id for this fill pattern */\n    this.uid = uid(\"fillPattern\");\n    this.transform = new Matrix();\n    this._styleKey = null;\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey)\n      return this._styleKey;\n    this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join(\"-\")}`;\n    return this._styleKey;\n  }\n}\n\nexport { FillPattern };\n//# sourceMappingURL=FillPattern.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\nexport class FillPattern implements CanvasPattern\n{\n    /** unique id for this fill pattern */\n    public readonly uid: number = uid('fillPattern');\n    public texture: Texture;\n    public transform = new Matrix();\n\n    private _styleKey: string | null = null;\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        this._styleKey = null;\n    }\n\n    public get styleKey(): string\n    {\n        if (this._styleKey) return this._styleKey;\n\n        this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join('-')}`;\n\n        return this._styleKey;\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../../color/Color.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\nimport { GraphicsPath } from './path/GraphicsPath.mjs';\nimport { SVGParser } from './svg/SVGParser.mjs';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle.mjs';\n\n\"use strict\";\nconst tmpPoint = new Point();\nconst tempMatrix = new Matrix();\nconst _GraphicsContext = class _GraphicsContext extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /** unique id for this graphics context */\n    this.uid = uid(\"graphicsContext\");\n    this.dirty = true;\n    this.batchMode = \"auto\";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = toFillStyle(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = toStrokeStyle(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = toFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: \"texture\",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === \"number\") {\n        deprecation(v8_0_0, \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: \"fill\",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = toStrokeStyle(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: \"stroke\",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this._activePath.clear();\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit(\"update\", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === \"fill\") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === \"texture\") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === \"stroke\") {\n        const data = instruction.data;\n        const alignment = data.style.alignment;\n        const outerPadding = data.style.width * (1 - alignment);\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - outerPadding,\n          _bounds.minY - outerPadding,\n          _bounds.maxX + outerPadding,\n          _bounds.maxY + outerPadding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === \"fill\") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          const strokeStyle = style;\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: \"butt\",\n  /** The line join style to use. */\n  join: \"miter\",\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null,\n  /** If the stroke is a pixel line. */\n  pixelLine: false\n};\nlet GraphicsContext = _GraphicsContext;\n\nexport { GraphicsContext };\n//# sourceMappingURL=GraphicsContext.mjs.map\n","/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillInput, StrokeInput } from './FillTypes';\nimport type { RoundedPoint } from './path/roundShape';\n\nconst tmpPoint = new Point();\n\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @memberof scene\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** If the stroke is a pixel line. */\n        pixelLine: false,\n    };\n\n    /** unique id for this graphics context */\n    public readonly uid: number = uid('graphicsContext');\n    public dirty = true;\n    public batchMode: BatchMode = 'auto';\n    public instructions: GraphicsInstructions[] = [];\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillInput)\n    {\n        this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillInput)\n    {\n        this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillInput): this\n    {\n        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: StrokeInput): this\n    {\n        this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture, tint, and dimensions.\n     * If only a texture is provided, it uses the texture's width and height for drawing. Additional parameters allow for specifying\n     * a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint: ColorSource): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number, dw: number, dh: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillInput, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: StrokeInput): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = toStrokeStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        if (this.dirty) return;\n\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const alignment = data.style.alignment;\n\n                const outerPadding = (data.style.width * (1 - alignment));\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - outerPadding,\n                    _bounds.minY - outerPadding,\n                    _bounds.maxX + outerPadding,\n                    _bounds.maxY + outerPadding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    const strokeStyle = (style as ConvertedStrokeStyle);\n\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n     * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath.mjs';\nimport { ShapePath } from './ShapePath.mjs';\n\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    /** unique id for this graphics path */\n    this.uid = uid(\"graphicsPath\");\n    this._dirty = true;\n    if (typeof instructions === \"string\") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: \"addPath\", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: \"arc\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: \"arcTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: \"arcToSvg\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: \"bezierCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: \"bezierCurveTo\", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: \"closePath\", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: \"ellipse\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: \"lineTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: \"moveTo\", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: \"quadraticCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: \"quadraticCurveTo\", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: \"rect\", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: \"circle\", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: \"roundRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: \"poly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: \"regularPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: \"roundPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: \"roundShape\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: \"filletRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: \"chamferRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius || (innerRadius = radius / 2);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\nexport { GraphicsPath };\n//# sourceMappingURL=GraphicsPath.mjs.map\n","import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    /** unique id for this graphics path */\n    public readonly uid: number = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     */\n    constructor(instructions?: string | PathInstruction[])\n    {\n        if (typeof instructions === 'string')\n        {\n            SVGToGraphicsPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius ||= radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n","import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case \"M\":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"m\":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"H\":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"h\":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"V\":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"v\":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"L\":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"l\":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"C\":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case \"c\":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case \"S\":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"s\":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"Q\":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"q\":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"T\":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"t\":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"A\":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"a\":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"Z\":\n      case \"z\":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        warn(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== \"Z\" && type !== \"z\") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\nexport { SVGToGraphicsPath };\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n","import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n// TODO optimise and cache the paths?\nexport function SVGToGraphicsPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    const commands = parse(svgPath);\n\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    let lastX = 0;\n    let lastY = 0;\n\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0];\n        const data = command; // alias for 1-based referencing\n\n        switch (type)\n        {\n            case 'M':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm':\n\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H':\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h':\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V':\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v':\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C':\n\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2],\n                    data[3], data[4],\n                    lastX, lastY\n                );\n                break;\n            case 'c':\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                    lastX + data[5], lastY + data[6]\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 's':\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 'q':\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4]\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 't':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 'A':\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'a':\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'Z':\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n","\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","import { Circle } from '../../../../maths/shapes/Circle.mjs';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse.mjs';\nimport { Polygon } from '../../../../maths/shapes/Polygon.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle.mjs';\nimport { Bounds } from '../../../container/bounds/Bounds.mjs';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier.mjs';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic.mjs';\nimport { buildArc } from '../buildCommands/buildArc.mjs';\nimport { buildArcTo } from '../buildCommands/buildArcTo.mjs';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg.mjs';\nimport { roundedShapeQuadraticCurve, roundedShapeArc } from './roundShape.mjs';\n\n\"use strict\";\nconst tempRectangle = new Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = startAngle - i * delta;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (lastShape.transform && !lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\nexport { ShapePath };\n//# sourceMappingURL=ShapePath.mjs.map\n","// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: { shape: ShapePrimitive, transform?: Matrix }[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n            // build out the path points\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = startAngle - (i * delta);\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    this.type = \"circle\";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width, alignment = 0.5) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const radius = this.radius;\n    const outerWidth = (1 - alignment) * width;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance <= radius + outerWidth && distance > radius - (width - outerWidth);\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\nexport { Circle };\n//# sourceMappingURL=Circle.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @memberof maths\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     *  @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance\n     * @returns A copy of the Circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public strokeContains(x: number, y: number, width: number, alignment: number = 0.5): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const radius = this.radius;\n        const outerWidth = (1 - alignment) * width;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance <= radius + outerWidth && distance > radius - (width - outerWidth));\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @param circle - The circle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @param circle - The circle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    this.type = \"ellipse\";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const strokeOuterWidth = strokeWidth * (1 - alignment);\n    const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n    const innerHorizontal = halfWidth - strokeInnerWidth;\n    const innerVertical = halfHeight - strokeInnerWidth;\n    const outerHorizontal = halfWidth + strokeOuterWidth;\n    const outerVertical = halfHeight + strokeOuterWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);\n    const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.x = this.x - this.halfWidth;\n    out.y = this.y - this.halfHeight;\n    out.width = this.halfWidth * 2;\n    out.height = this.halfHeight * 2;\n    return out;\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\nexport { Ellipse };\n//# sourceMappingURL=Ellipse.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * ```js\n * import { Ellipse } from 'pixi.js';\n *\n * const ellipse = new Ellipse(0, 0, 20, 10); // 40x20 rectangle\n * const isPointInEllipse = ellipse.contains(0, 0); // true\n * ```\n * @memberof maths\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance\n     * @returns {Ellipse} A copy of the ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const strokeOuterWidth = strokeWidth * (1 - alignment);\n        const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n\n        const innerHorizontal = halfWidth - strokeInnerWidth;\n        const innerVertical = halfHeight - strokeInnerWidth;\n\n        const outerHorizontal = halfWidth + strokeOuterWidth;\n        const outerVertical = halfHeight + strokeOuterWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerHorizontal * innerHorizontal))\n            + ((normalizedY * normalizedY) / (innerVertical * innerVertical));\n\n        const outerEllipse = ((normalizedX * normalizedX) / (outerHorizontal * outerHorizontal))\n            + ((normalizedY * normalizedY) / (outerVertical * outerVertical));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @param ellipse - The ellipse to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @param ellipse - The ellipse to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment.mjs';\nimport { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    this.type = \"polygon\";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== \"number\") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const strokeWidthSquared = strokeWidth * strokeWidth;\n    const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n    const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSquared = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      const sign = Math.sign((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1));\n      if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, \"\")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\nexport { Polygon };\n//# sourceMappingURL=Polygon.mjs.map\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * A class to define a shape via user defined coordinates.\n *\n *\n * `Polygon` can accept the following different constructor arguments:\n * - An array of `Point` objects\n * - An array of coordinate pairs\n *\n *\n * These can be passed as a single array, or as a sequence of arguments.\n * ```js\n * import { Polygon } from 'pixi.js';\n *\n * // create a polygon object from an array of points, or an array of coordinate pairs\n * const polygon1 = new Polygon([ new Point(0, 0), new Point(0, 100), new Point(100, 100) ]);\n * const polygon2 = new Polygon([ 0, 0, 0, 100, 100, 100 ]);\n *\n * // or create a polygon object from a sequence of points, or coordinate pairs\n * const polygon3 = new Polygon(new Point(0, 0), new Point(0, 100), new Point(100, 100));\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n * ```\n * @memberof maths\n */\nexport class Polygon implements ShapePrimitive\n{\n    /** An array of the points of this polygon. */\n    public points: number[];\n\n    /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @returns - A copy of the polygon.\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this polygon.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this polygon\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment = 0.5): boolean\n    {\n        const strokeWidthSquared = strokeWidth * strokeWidth;\n        const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n        const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSquared = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            const sign = Math.sign(((x2 - x1) * (y - y1)) - ((y2 - y1) * (x - x1)));\n\n            if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @param polygon - The polygon to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @param polygon - The polygon to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon\n     * @readonly\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon\n     * @readonly\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the first X coordinate of the polygon\n     * @readonly\n     */\n    get x(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n    /**\n     * Get the first Y coordinate of the polygon\n     * @readonly\n     */\n    get y(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n}\n\n","\"use strict\";\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\nexport { squaredDistanceToLineSegment };\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n","export function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    this.type = \"roundedRectangle\";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth, alignment = 0.5) {\n    const { x, y, width, height, radius } = this;\n    const strokeWidthOuter = strokeWidth * (1 - alignment);\n    const strokeWidthInner = strokeWidth - strokeWidthOuter;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(\n        pX,\n        pY,\n        innerX,\n        innerY,\n        radius,\n        strokeWidthInner,\n        strokeWidthOuter\n      ) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(\n        pX,\n        pY,\n        rightBound - radius,\n        innerY,\n        radius,\n        strokeWidthInner,\n        strokeWidthOuter\n      ) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(\n        pX,\n        pY,\n        rightBound - radius,\n        bottomBound - radius,\n        radius,\n        strokeWidthInner,\n        strokeWidthOuter\n      ) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(\n        pX,\n        pY,\n        innerX,\n        bottomBound - radius,\n        radius,\n        strokeWidthInner,\n        strokeWidthOuter\n      )\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\nexport { RoundedRectangle };\n//# sourceMappingURL=RoundedRectangle.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    strokeWidthInner: number,\n    strokeWidthOuter: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;\n};\n\n/**\n * The `RoundedRectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`, including a `radius` property that\n * defines the radius of the rounded corners.\n * @memberof maths\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    public readonly type = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @returns - A copy of the rounded rectangle.\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                    || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner)\n            || (pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner)\n            || (pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveBezier };\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n","// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher.mjs';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { buildContextBatches } from './utils/buildContextBatches.mjs';\n\n\"use strict\";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.batcher = new DefaultBatcher();\n    this.instructions = new InstructionSet();\n  }\n  init() {\n    this.instructions.reset();\n  }\n  /**\n   * @deprecated since version 8.0.0\n   * Use `batcher.geometry` instead.\n   * @see {Batcher#geometry}\n   */\n  get geometry() {\n    deprecation(v8_3_4, \"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.\");\n    return this.batcher.geometry;\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor(renderer) {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    renderer.renderableGC.addManagedHash(this, \"_gpuContextHash\");\n    renderer.renderableGC.addManagedHash(this, \"_graphicsDataContextHash\");\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === \"no-batch\") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === \"auto\") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _initContextRenderData(context) {\n    const graphicsData = BigPool.get(GraphicsContextRenderData);\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = graphicsData.batcher;\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = batcher.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    gpuContext.context = context;\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        BigPool.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        BigPool.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const i in this._gpuContextHash) {\n      if (this._gpuContextHash[i]) {\n        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n      }\n    }\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem };\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public batcher: Batcher = new DefaultBatcher();\n    public instructions = new InstructionSet();\n\n    public init()\n    {\n        this.instructions.reset();\n    }\n\n    /**\n     * @deprecated since version 8.0.0\n     * Use `batcher.geometry` instead.\n     * @see {Batcher#geometry}\n     */\n    get geometry()\n    {\n        // #if _DEBUG\n        deprecation(v8_3_4, 'GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.');\n        // #endif\n\n        return this.batcher.geometry;\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @memberof rendering\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @memberof rendering\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        renderer.renderableGC.addManagedHash(this, '_gpuContextHash');\n        renderer.renderableGC.addManagedHash(this, '_graphicsDataContextHash');\n    }\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    // Context management functions\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData);// ();\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = graphicsData.batcher;\n\n        // TODO we can pool buffers here eventually..\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = batcher.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n\n        for (const i in this._gpuContextHash)\n        {\n            if (this._gpuContextHash[i])\n            {\n                this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n            }\n        }\n    }\n}\n","import { BindGroup } from '../../renderers/gpu/shader/BindGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\n\n\"use strict\";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 2166136261;\n  for (let i = 0; i < size; i++) {\n    uid ^= textures[i].uid;\n    uid = Math.imul(uid, 16777619);\n    uid >>>= 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\nlet maxTextures = 0;\nfunction generateTextureBatchBindGroup(textures, size, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  if (!maxTextures)\n    maxTextures = getMaxTexturesPerBatch();\n  for (let i = 0; i < maxTextures; i++) {\n    const texture = i < size ? textures[i] : Texture.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new BindGroup(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\nexport { getTextureBatchBindGroup };\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n","import { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\n\nimport type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\nconst cachedGroups: Record<number, BindGroup> = {};\n\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number)\n{\n    let uid = 2166136261; // FNV-1a 32-bit offset basis\n\n    for (let i = 0; i < size; i++)\n    {\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n\n    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\n\nlet maxTextures = 0;\n\nfunction generateTextureBatchBindGroup(textures: TextureSource[], size: number, key: number): BindGroup\n{\n    const bindGroupResources: Record<string, any> = {};\n\n    let bindIndex = 0;\n\n    if (!maxTextures)maxTextures = getMaxTexturesPerBatch();\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        const texture = i < size ? textures[i] : Texture.EMPTY.source;\n\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n\n    // pad out with empty textures\n    const bindGroup = new BindGroup(bindGroupResources);\n\n    cachedGroups[key] = bindGroup;\n\n    return bindGroup;\n}\n\n","\"use strict\";\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join(\"|\");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    resource.on?.(\"change\", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\nexport { BindGroup };\n//# sourceMappingURL=BindGroup.mjs.map\n","import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n","import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext.mjs';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader.mjs';\n\n\"use strict\";\nlet maxTexturesPerBatchCache = null;\nfunction getMaxTexturesPerBatch() {\n  if (maxTexturesPerBatchCache)\n    return maxTexturesPerBatchCache;\n  const gl = getTestContext();\n  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n    maxTexturesPerBatchCache,\n    gl\n  );\n  gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n  return maxTexturesPerBatchCache;\n}\n\nexport { getMaxTexturesPerBatch };\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n","import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\n\n\"use strict\";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = DOMAdapter.get().createCanvas();\n    context = canvas.getContext(\"webgl\", {});\n  }\n  return context;\n}\n\nexport { getTestContext };\n//# sourceMappingURL=getTestContext.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n","\"use strict\";\nconst fragTemplate = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(\"\\n\");\nfunction generateIfTestSrc(maxIfs) {\n  let src = \"\";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += \"\\nelse \";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  try {\n    while (true) {\n      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n      gl.shaderSource(shader, fragmentSrc);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        maxIfs = maxIfs / 2 | 0;\n      } else {\n        break;\n      }\n    }\n  } finally {\n    gl.deleteShader(shader);\n  }\n  return maxIfs;\n}\n\nexport { checkMaxIfStatementsInShader };\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n","import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true)\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Batcher } from './Batcher.mjs';\nimport { BatchGeometry } from './BatchGeometry.mjs';\nimport { DefaultShader } from './DefaultShader.mjs';\n\n\"use strict\";\nlet defaultShader = null;\nconst _DefaultBatcher = class _DefaultBatcher extends Batcher {\n  constructor() {\n    super(...arguments);\n    this.geometry = new BatchGeometry();\n    this.shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));\n    this.name = _DefaultBatcher.extension.name;\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    this.vertexSize = 6;\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n   * @param element - The DefaultBatchableMeshElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packAttributes(element, float32View, uint32View, index, textureId) {\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const { positions, uvs } = element;\n    const argb = element.color;\n    const offset = element.attributeOffset;\n    const end = offset + element.attributeSize;\n    for (let i = offset; i < end; i++) {\n      const i2 = i * 2;\n      const x = positions[i2];\n      const y = positions[i2 + 1];\n      float32View[index++] = a * x + c * y + tx;\n      float32View[index++] = d * y + b * x + ty;\n      float32View[index++] = uvs[i2];\n      float32View[index++] = uvs[i2 + 1];\n      uint32View[index++] = argb;\n      uint32View[index++] = textureIdAndRound;\n    }\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n   * @param element - The DefaultBatchableQuadElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packQuadAttributes(element, float32View, uint32View, index, textureId) {\n    const texture = element.texture;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = element.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = element.color;\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n};\n/** @ignore */\n_DefaultBatcher.extension = {\n  type: [\n    ExtensionType.Batcher\n  ],\n  name: \"default\"\n};\nlet DefaultBatcher = _DefaultBatcher;\n\nexport { DefaultBatcher };\n//# sourceMappingURL=DefaultBatcher.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Batcher } from './Batcher';\nimport { BatchGeometry } from './BatchGeometry';\nimport { DefaultShader } from './DefaultShader';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { BatchableMeshElement, BatchableQuadElement } from './Batcher';\n\nlet defaultShader: Shader = null;\n\n/**\n * Represents the common elements for default batch rendering.\n * This interface defines the properties that are used by the DefaultBatcher\n * to render elements efficiently in a batch.\n * @memberof rendering\n */\nexport interface DefaultBatchElements\n{\n    /**\n     * The color of the element that will be multiplied with the texture color.\n     * This is typically represented as a 32-bit integer in RGBA format.\n     */\n    color: number;\n\n    /**\n     * Determines whether the element should be rounded to the nearest pixel.\n     * - 0: No rounding (default)\n     * - 1: Round to nearest pixel\n     * This can help with visual consistency, especially for pixel art styles.\n     */\n    roundPixels: 0 | 1;\n\n    /**\n     * The transform matrix of the element.\n     * This matrix represents the position, scale, rotation, and skew of the element.\n     */\n    transform: Matrix;\n}\n\n/**\n * Represents a batchable quad element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableQuadElement extends BatchableQuadElement, DefaultBatchElements {}\n\n/**\n * Represents a batchable mesh element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableMeshElement extends BatchableMeshElement, DefaultBatchElements {}\n\n/**\n * The default batcher is used to batch quads and meshes. This batcher will batch the following elements:\n * - tints\n * - roundPixels\n * - texture\n * - transform\n * @memberof rendering\n */\nexport class DefaultBatcher extends Batcher\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.Batcher,\n        ],\n        name: 'default',\n    } as const;\n\n    public geometry = new BatchGeometry();\n    public shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));\n\n    public name = DefaultBatcher.extension.name;\n\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    public vertexSize = 6;\n\n    /**\n     * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n     * @param element - The DefaultBatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packAttributes(\n        element: DefaultBatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const { positions, uvs } = element;\n\n        const argb = element.color;\n\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n\n        for (let i = offset; i < end; i++)\n        {\n            const i2 = i * 2;\n\n            const x = positions[i2];\n            const y = positions[(i2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (d * y) + (b * x) + ty;\n\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[(i2) + 1];\n\n            uint32View[index++] = argb;\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n     * @param element - The DefaultBatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packQuadAttributes(\n        element: DefaultBatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const texture = element.texture;\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = element.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = element.color;\n\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n}\n\n","import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray();\n    this.blendMode = \"normal\";\n    this.topology = \"triangle-strip\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    /** unique id for this batcher */\n    this.uid = uid(\"batcher\");\n    /** Indicates whether the batch data has been modified and needs updating. */\n    this.dirty = true;\n    /** The current index of the batch being processed. */\n    this.batchIndex = 0;\n    /** An array of all batches created during the current rendering process. */\n    this.batches = [];\n    this._elements = [];\n    _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n    this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n    this.indexBuffer = new Uint16Array(indicesInitialSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject._indexStart = this.indexSize;\n    batchableObject._attributeStart = this.attributeSize;\n    batchableObject._batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.attributeSize * this.vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject._textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    const attributeBuffer = this.attributeBuffer;\n    if (batchableObject.packAsQuad) {\n      this.packQuadAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    } else {\n      this.packAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    }\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart])\n      return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    let topology = firstElement.topology;\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const indexBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n      if (source._batchTick === BATCH_TICK && !breakRequired) {\n        element._textureId = source._textureBindLocation;\n        size += element.indexSize;\n        if (element.packAsQuad) {\n          this.packQuadAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packQuadIndex(\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        } else {\n          this.packAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packIndex(\n            element,\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        }\n        element._batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || breakRequired) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          topology,\n          instructionSet,\n          action\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        topology = element.topology;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        ++BATCH_TICK;\n      }\n      element._textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element._batch = batch;\n      size += element.indexSize;\n      if (element.packAsQuad) {\n        this.packQuadAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packQuadIndex(\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      } else {\n        this.packAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packIndex(\n          element,\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      }\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        topology,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.topology = topology;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  packQuadIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  packIndex(element, indexBuffer, index, indicesOffset) {\n    const indices = element.indices;\n    const size = element.indexSize;\n    const indexOffset = element.indexOffset;\n    const attributeOffset = element.attributeOffset;\n    for (let i = 0; i < size; i++) {\n      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n    }\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i]._batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  maxTextures: null,\n  attributesInitialSize: 4,\n  indicesInitialSize: 6\n};\nlet Batcher = _Batcher;\n\nexport { Batch, Batcher };\n//# sourceMappingURL=Batcher.mjs.map\n","import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BoundsData } from '../../../scene/container/bounds/Bounds';\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { Topology } from '../../renderers/shared/geometry/const';\nimport type { Geometry, IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n    public topology: Topology = 'triangle-strip';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\n\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @memberof rendering\n */\nexport interface BatchableElement\n{\n    /**\n     * The name of the batcher to use. Must be registered.\n     * @type {string}\n     */\n    batcherName: string;\n\n    /**\n     * The texture to be used for rendering.\n     * @type {Texture}\n     */\n    texture: Texture;\n\n    /**\n     * The blend mode to be applied.\n     * @type {BLEND_MODES}\n     */\n    blendMode: BLEND_MODES;\n\n    /**\n     * The size of the index data.\n     * @type {number}\n     */\n    indexSize: number;\n\n    /**\n     * The size of the attribute data.\n     * @type {number}\n     */\n    attributeSize: number;\n\n    /**\n     * The topology to be used for rendering.\n     * @type {Topology}\n     */\n    topology: Topology\n\n    /**\n     * Whether the element should be packed as a quad for better performance.\n     * @type {boolean}\n     */\n    packAsQuad: boolean;\n\n    /**\n     * The texture ID, stored for efficient updating.\n     * @type {number}\n     * @private\n     */\n    _textureId: number;\n\n    /**\n     * The starting position in the attribute buffer.\n     * @type {number}\n     * @private\n     */\n    _attributeStart: number;\n\n    /**\n     * The starting position in the index buffer.\n     * @type {number}\n     * @private\n     */\n    _indexStart: number;\n\n    /**\n     * Reference to the batcher.\n     * @type {Batcher}\n     * @private\n     */\n    _batcher: Batcher;\n\n    /**\n     * Reference to the batch.\n     * @type {Batch}\n     * @private\n     */\n    _batch: Batch;\n\n}\n\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableQuadElement extends BatchableElement\n{\n    /**\n     * Indicates that this element should be packed as a quad.\n     * @type {true}\n     */\n    packAsQuad: true;\n\n    /**\n     * The size of the attribute data for this quad element.\n     * @type {4}\n     */\n    attributeSize: 4;\n\n    /**\n     * The size of the index data for this quad element.\n     * @type {6}\n     */\n    indexSize: 6;\n\n    /**\n     * The bounds data for this quad element.\n     * @type {BoundsData}\n     */\n    bounds: BoundsData;\n}\n\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableMeshElement extends BatchableElement\n{\n    /**\n     * The UV coordinates of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    uvs: number[] | Float32Array;\n\n    /**\n     * The vertex positions of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    positions: number[] | Float32Array;\n\n    /**\n     * The indices of the mesh.\n     * @type {number[] | Uint16Array | Uint32Array}\n     */\n    indices: number[] | Uint16Array | Uint32Array;\n\n    /**\n     * The offset in the index buffer.\n     * @type {number}\n     */\n    indexOffset: number;\n\n    /**\n     * The offset in the attribute buffer.\n     * @type {number}\n     */\n    attributeOffset: number;\n\n    /**\n     * Indicates that this element should not be packed as a quad.\n     * @type {false}\n     */\n    packAsQuad: false;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @memberof rendering\n */\nexport interface BatcherOptions\n{\n    /** The maximum number of textures per batch. */\n    maxTextures?: number;\n    attributesInitialSize?: number;\n    indicesInitialSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @memberof rendering\n */\nexport abstract class Batcher\n{\n    public static defaultOptions: Partial<BatcherOptions> = {\n        maxTextures: null,\n        attributesInitialSize: 4,\n        indicesInitialSize: 6,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n\n    /** The buffer containing attribute data for all elements in the batch. */\n    public attributeBuffer: ViewableBuffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    /** The current size of the attribute data in the batch. */\n    public attributeSize: number;\n\n    /** The current size of the index data in the batch. */\n    public indexSize: number;\n\n    /** The total number of elements currently in the batch. */\n    public elementSize: number;\n\n    /** The starting index of elements in the current batch. */\n    public elementStart: number;\n\n    /** Indicates whether the batch data has been modified and needs updating. */\n    public dirty = true;\n\n    /** The current index of the batch being processed. */\n    public batchIndex = 0;\n\n    /** An array of all batches created during the current rendering process. */\n    public batches: Batch[] = [];\n\n    private _elements: BatchableElement[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    /** The name of the batcher. Must be implemented by subclasses. */\n    public abstract name: string;\n    /** The vertex size of the batcher. Must be implemented by subclasses. */\n    protected abstract vertexSize: number;\n\n    /** The geometry used by this batcher. Must be implemented by subclasses. */\n    public abstract geometry: Geometry;\n\n    /**\n     * The shader used by this batcher. Must be implemented by subclasses.\n     * this can be shared by multiple batchers of the same type.\n     */\n    public abstract shader: Shader;\n\n    /**\n     * Packs the attributes of a BatchableMeshElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packAttributes(\n        element: BatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    /**\n     * Packs the attributes of a BatchableQuadElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packQuadAttributes(\n        element: BatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    constructor(options: BatcherOptions = {})\n    {\n        Batcher.defaultOptions.maxTextures = Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableElement)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.attributeSize) * this.vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean\n    {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableElement)\n    {\n        this.dirty = true;\n\n        const attributeBuffer = this.attributeBuffer;\n\n        if (batchableObject.packAsQuad)\n        {\n            this.packQuadAttributes(\n                batchableObject as BatchableQuadElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n        else\n        {\n            this.packAttributes(\n                batchableObject as BatchableMeshElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n        let topology = firstElement.topology;\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n\n            if (source._batchTick === BATCH_TICK && !breakRequired)\n            {\n                element._textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n\n                if (element.packAsQuad)\n                {\n                    this.packQuadAttributes(\n                        element as BatchableQuadElement,\n                        f32, u32,\n                        element._attributeStart, element._textureId\n                    );\n                    this.packQuadIndex(\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n                else\n                {\n                    this.packAttributes(\n                        element as BatchableMeshElement,\n                        f32, u32,\n                        element._attributeStart,\n                        element._textureId\n                    );\n                    this.packIndex(\n                        element as BatchableMeshElement,\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n\n                element._batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || breakRequired)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    topology,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n                topology = element.topology;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n\n            size += element.indexSize;\n\n            if (element.packAsQuad)\n            {\n                this.packQuadAttributes(\n                    element as BatchableQuadElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n                this.packQuadIndex(\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n            else\n            {\n                this.packAttributes(element as BatchableMeshElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n\n                this.packIndex(\n                    element as BatchableMeshElement,\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                topology,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        topology: Topology,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.topology = topology;\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public packQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public packIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n\n        for (let i = 0; i < size; i++)\n        {\n            indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n        }\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i]._batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n","\"use strict\";\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\n\nexport { ViewableBuffer };\n//# sourceMappingURL=ViewableBuffer.mjs.map\n","type TypedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @memberof utils\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n","\"use strict\";\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\nexport { fastCopy };\n//# sourceMappingURL=fastCopy.mjs.map\n","/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n","import { BLEND_TO_NPM } from './const.mjs';\n\n\"use strict\";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === \"no-premultiply-alpha\") {\n    return BLEND_TO_NPM[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\nexport { getAdjustedBlendModeBlend };\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n","import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n","\"use strict\";\nconst BLEND_TO_NPM = {\n  normal: \"normal-npm\",\n  add: \"add-npm\",\n  screen: \"screen-npm\"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n  STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"INVERSE_MASK_ACTIVE\"] = 3] = \"INVERSE_MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 4] = \"RENDERING_MASK_REMOVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 5] = \"NONE\";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\nexport { BLEND_TO_NPM, STENCIL_MODES };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Various blend modes supported by Pixi\n * @memberof filters\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @memberof rendering\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @memberof rendering\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    INVERSE_MASK_ACTIVE = 3,\n    RENDERING_MASK_REMOVE = 4,\n    NONE = 5,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @memberof rendering\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n","\"use strict\";\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\nexport { BatchTextureArray };\n//# sourceMappingURL=BatchTextureArray.mjs.map\n","import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @memberof rendering\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n","import { Buffer } from '../../renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry.mjs';\n\n\"use strict\";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer({\n      data: placeHolderBufferData,\n      label: \"attribute-batch-buffer\",\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer({\n      data: placeHolderIndexData,\n      label: \"index-batch-buffer\",\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 0\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: \"unorm8x4\",\n          stride,\n          offset: 4 * 4\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: \"uint16x2\",\n          stride,\n          offset: 5 * 4\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\nexport { BatchGeometry };\n//# sourceMappingURL=BatchGeometry.mjs.map\n","import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { BufferUsage } from './const.mjs';\n\n\"use strict\";\nclass Buffer extends EventEmitter {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"buffer\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    this._dataInt32 = null;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size ?? (size = data?.byteLength);\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  get dataInt32() {\n    if (!this._dataInt32) {\n      this._dataInt32 = new Int32Array(this.data.buffer);\n    }\n    return this._dataInt32;\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & BufferUsage.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= BufferUsage.STATIC;\n    } else {\n      this.descriptor.usage &= ~BufferUsage.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit(\"update\", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    this._dataInt32 = null;\n    if (!oldData || oldData.length !== value.length) {\n      if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit(\"update\", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = uid(\"resource\");\n        this.emit(\"change\", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit(\"update\", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit(\"update\", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { Buffer };\n//# sourceMappingURL=Buffer.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/** All the various typed arrays that exist in js */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/** Options for creating a buffer */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link rendering.BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @memberof rendering\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     * @ignore\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateID = 1;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    private _dataInt32: Int32Array = null;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size ??= (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    get dataInt32()\n    {\n        if (!this._dataInt32)\n        {\n            this._dataInt32 = new Int32Array((this.data as any).buffer);\n        }\n\n        return this._dataInt32;\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n        this._dataInt32 = null;\n\n        // Event handling\n        if (!oldData || oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n","\"use strict\";\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n  BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n  BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n  BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n  BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n  BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n  BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n  BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n  BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n  BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n  BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n  return BufferUsage2;\n})(BufferUsage || {});\n\nexport { BufferUsage };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @memberof rendering\n */\nexport enum BufferUsage\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer.mjs';\nimport { getGeometryBounds } from './utils/getGeometryBounds.mjs';\n\n\"use strict\";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends EventEmitter {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options = {}) {\n    super();\n    /** The unique id of the geometry. */\n    this.uid = uid(\"geometry\");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n    const { attributes, indexBuffer, topology } = options;\n    this.buffers = [];\n    this.attributes = {};\n    if (attributes) {\n      for (const i in attributes) {\n        this.addAttribute(i, attributes[i]);\n      }\n    }\n    this.instanceCount = options.instanceCount ?? 1;\n    if (indexBuffer) {\n      this.addIndex(indexBuffer);\n    }\n    this.topology = topology || \"triangle-list\";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /**\n   * Adds an attribute to the geometry.\n   * @param name - The name of the attribute to add.\n   * @param attributeOption - The attribute option to add.\n   */\n  addAttribute(name, attributeOption) {\n    const attribute = ensureIsAttribute(attributeOption);\n    const bufferIndex = this.buffers.indexOf(attribute.buffer);\n    if (bufferIndex === -1) {\n      this.buffers.push(attribute.buffer);\n      attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n      attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n    }\n    this.attributes[name] = attribute;\n  }\n  /**\n   * Adds an index buffer to the geometry.\n   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n   */\n  addIndex(indexBuffer) {\n    this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n    this.buffers.push(this.indexBuffer);\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, \"aPosition\", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\nexport { Geometry };\n//# sourceMappingURL=Geometry.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @memberof rendering\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** the stride of the data in the buffer - in bytes*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 - in bytes*/\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /**\n     * the starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n    /**\n     * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n     * issue a warning if one of the attributes has divisor set.\n     */\n    divisor?: number;\n}\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link rendering.Attribute} but allows for the buffer to be a typed or number array\n * @memberof rendering\n */\ntype AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @memberof rendering\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes?: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @memberof rendering\n * @class\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor = {})\n    {\n        super();\n\n        const { attributes, indexBuffer, topology } = options;\n\n        this.buffers = [];\n\n        this.attributes = {};\n\n        if (attributes)\n        {\n            for (const i in attributes)\n            {\n                this.addAttribute(i, attributes[i]);\n            }\n        }\n\n        this.instanceCount = options.instanceCount ?? 1;\n\n        if (indexBuffer)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Adds an attribute to the geometry.\n     * @param name - The name of the attribute to add.\n     * @param attributeOption - The attribute option to add.\n     */\n    public addAttribute(name: string, attributeOption: AttributeOption): void\n    {\n        const attribute = ensureIsAttribute(attributeOption);\n\n        const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(attribute.buffer);\n\n            // two events here - one for a resize (new buffer change)\n            // and one for an update (existing buffer change)\n            attribute.buffer.on('update', this.onBufferUpdate, this);\n            attribute.buffer.on('change', this.onBufferUpdate, this);\n        }\n        this.attributes[name] = attribute;\n    }\n\n    /**\n     * Adds an index buffer to the geometry.\n     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n     */\n    public addIndex(indexBuffer: Buffer | TypedArray | number[]): void\n    {\n        this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n        this.buffers.push(this.indexBuffer);\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n","import { Buffer } from '../../buffer/Buffer.mjs';\nimport { BufferUsage } from '../../buffer/const.mjs';\n\n\"use strict\";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer)) {\n    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n      }\n    }\n    buffer = new Buffer({\n      data: buffer,\n      label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n      usage\n    });\n  }\n  return buffer;\n}\n\nexport { ensureIsBuffer };\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n","import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @memberof rendering\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n","\"use strict\";\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\nexport { getGeometryBounds };\n//# sourceMappingURL=getGeometryBounds.mjs.map\n","import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n","import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram.mjs';\nimport { colorBitGl, colorBit } from '../../high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBitGl, generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBitGl, roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../renderers/shared/shader/Shader.mjs';\n\n\"use strict\";\nclass DefaultShader extends Shader {\n  constructor(maxTextures) {\n    const glProgram = compileHighShaderGlProgram({\n      name: \"batch\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        roundPixelsBitGl\n      ]\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"batch\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(maxTextures),\n        roundPixelsBit\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n}\n\nexport { DefaultShader };\n//# sourceMappingURL=DefaultShader.mjs.map\n","import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../renderers/shared/shader/Shader';\n\n/**\n * DefaultShader is a specialized shader class designed for batch rendering.\n * It extends the base Shader class and provides functionality for handling\n * color, texture batching, and pixel rounding in both WebGL and WebGPU contexts.\n *\n * It is used by the default batcher\n * @extends Shader\n * @memberof rendering\n */\nexport class DefaultShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'batch',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                roundPixelsBitGl,\n            ]\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                roundPixelsBit,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision.mjs';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines.mjs';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision.mjs';\nimport { insertVersion } from './program/preprocessors/insertVersion.mjs';\nimport { setProgramName } from './program/preprocessors/setProgramName.mjs';\nimport { stripVersion } from './program/preprocessors/stripVersion.mjs';\n\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion,\n  // adds precision string if not already present\n  ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines,\n  // add the program name to the shader\n  setProgramName,\n  // add the version string to the shader header\n  insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\n\nexport { GlProgram };\n//# sourceMappingURL=GlProgram.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n\n    transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n","\"use strict\";\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\nexport { createIdFromString };\n//# sourceMappingURL=createIdFromString.mjs.map\n","const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n","import { getTestContext } from './getTestContext.mjs';\n\n\"use strict\";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = \"mediump\";\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\nexport { getMaxFragmentPrecision };\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n","import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n","\"use strict\";\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace(\"out vec4 finalColor;\", \"\");\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\nexport { addProgramDefines };\n//# sourceMappingURL=addProgramDefines.mjs.map\n","export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n","\"use strict\";\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") {\n      precision = \"mediump\";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\n\nexport { ensurePrecision };\n//# sourceMappingURL=ensurePrecision.mjs.map\n","import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n","\"use strict\";\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\nexport { insertVersion };\n//# sourceMappingURL=insertVersion.mjs.map\n","export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n","\"use strict\";\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, \"-\");\n  name += isFragment ? \"-fragment\" : \"-vertex\";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf(\"#define SHADER_NAME\") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\nexport { setProgramName };\n//# sourceMappingURL=setProgramName.mjs.map\n","const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n","\"use strict\";\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace(\"#version 300 es\", \"\");\n}\n\nexport { stripVersion };\n//# sourceMappingURL=stripVersion.mjs.map\n","export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram.mjs';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups.mjs';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups.mjs';\nimport { generateLayoutHash } from './utils/generateLayoutHash.mjs';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates.mjs';\n\n\"use strict\";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /**\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._attributeLocationsKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\n\nexport { GpuProgram };\n//# sourceMappingURL=GpuProgram.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\nexport { extractAttributesFromGpuProgram };\n//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n","\"use strict\";\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\nexport { getAttributeInfoFromFormat };\n//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map\n","import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n","\"use strict\";\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === \"<uniform>\",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(\":\");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\nexport { extractStructAndGroups };\n//# sourceMappingURL=extractStructAndGroups.mjs.map\n","export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n","import { ShaderStage } from '../../../shared/shader/const.mjs';\n\n\"use strict\";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n        buffer: {\n          type: \"uniform\"\n        }\n      });\n    } else if (group.type === \"sampler\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        sampler: {\n          type: \"filtering\"\n        }\n      });\n    } else if (group.type === \"texture_2d\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: \"float\",\n          viewDimension: \"2d\",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\nexport { generateGpuLayoutGroups };\n//# sourceMappingURL=generateGpuLayoutGroups.mjs.map\n","import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n","\"use strict\";\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n  ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n  ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n  return ShaderStage2;\n})(ShaderStage || {});\n\nexport { ShaderStage };\n//# sourceMappingURL=const.mjs.map\n","export enum ShaderStage\n{\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n","\"use strict\";\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\nexport { generateLayoutHash };\n//# sourceMappingURL=generateLayoutHash.mjs.map\n","import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n","\"use strict\";\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\nexport { removeStructAndGroupDuplicates };\n//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map\n","import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n            ${results\n                .sort()\n                .map((inValue) => ` ${extractVariableName(inValue)}`)\n                .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n        main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","import { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nconst batchSamplersUniformGroupHash = {};\nfunction getBatchSamplersUniformGroup(maxTextures) {\n  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n  if (batchSamplersUniformGroup)\n    return batchSamplersUniformGroup;\n  const sampleValues = new Int32Array(maxTextures);\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n  }, { isStatic: true });\n  return batchSamplersUniformGroup;\n}\n\nexport { getBatchSamplersUniformGroup };\n//# sourceMappingURL=getBatchSamplersUniformGroup.mjs.map\n","import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { createIdFromString } from '../utils/createIdFromString.mjs';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES } from './types.mjs';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue.mjs';\n\n\"use strict\";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /** used internally to know if a uniform group was used in the last render pass */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"uniform\");\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    this._resourceType = \"uniformGroup\";\n    /** the resource id used internally by the renderer to build bind group keys */\n    this._resourceId = uid(\"resource\");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    this._dirtyId = 0;\n    // implementing the interface - UniformGroup are not destroyed\n    this.destroyed = false;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      if (!UNIFORM_TYPES_MAP[uniformData.type]) {\n        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(\", \")}`);\n      }\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = createIdFromString(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join(\"-\"), \"uniform-group\");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\nexport { UniformGroup };\n//# sourceMappingURL=UniformGroup.mjs.map\n","import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n","\"use strict\";\nconst UNIFORM_TYPES_VALUES = [\n  \"f32\",\n  \"i32\",\n  \"vec2<f32>\",\n  \"vec3<f32>\",\n  \"vec4<f32>\",\n  \"mat2x2<f32>\",\n  \"mat3x3<f32>\",\n  \"mat4x4<f32>\",\n  \"mat3x2<f32>\",\n  \"mat4x2<f32>\",\n  \"mat2x3<f32>\",\n  \"mat4x3<f32>\",\n  \"mat2x4<f32>\",\n  \"mat3x4<f32>\",\n  \"vec2<i32>\",\n  \"vec3<i32>\",\n  \"vec4<i32>\"\n];\nconst UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {\n  acc[type] = true;\n  return acc;\n}, {});\n\nexport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES };\n//# sourceMappingURL=types.mjs.map\n","// TODO add more types as required\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>',\n    'vec2<i32>',\n    'vec3<i32>',\n    'vec4<i32>',\n] as const;\n\n/** useful for checking if a type is supported - a map of supported types with a true value. */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n","\"use strict\";\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case \"f32\":\n      return 0;\n    case \"vec2<f32>\":\n      return new Float32Array(2 * size);\n    case \"vec3<f32>\":\n      return new Float32Array(3 * size);\n    case \"vec4<f32>\":\n      return new Float32Array(4 * size);\n    case \"mat2x2<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3x3<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4x4<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexport { getDefaultUniformValue };\n//# sourceMappingURL=getDefaultUniformValue.mjs.map\n","/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /** A unique identifier for the shader */\n    this.uid = uid(\"shader\");\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      groups = {};\n      groupMap = {};\n      if (gpuProgram) {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      let bindTick = 0;\n      for (const i in resources) {\n        if (nameHash[i])\n          continue;\n        if (!groups[99]) {\n          groups[99] = new BindGroup();\n          this._ownedBindGroups.push(groups[99]);\n        }\n        nameHash[i] = { group: 99, binding: bindTick, name: i };\n        groupMap[99] = groupMap[99] || {};\n        groupMap[99][bindTick] = i;\n        bindTick++;\n      }\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexport { Shader };\n//# sourceMappingURL=Shader.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\nimport { uid } from '~/utils/data/uid';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** A unique identifier for the shader */\n    public readonly uid: number = uid('shader');\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","\"use strict\";\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\n\nexport { RendererType };\n//# sourceMappingURL=types.mjs.map\n","import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\n/**\n * @memberof rendering\n * @extends rendering.WebGLRenderer\n * @extends rendering.WebGPURenderer\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * @extends rendering.WebGLOptions\n * @extends rendering.WebGPUOptions\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { BigPool } from '../../../../utils/pool/PoolGroup.mjs';\nimport { BatchableGraphics } from '../BatchableGraphics.mjs';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle.mjs';\nimport { buildLine } from '../buildCommands/buildLine.mjs';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { triangulateWithHoles } from './triangulateWithHoles.mjs';\n\n\"use strict\";\nconst shapeBuilders = {};\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\nconst tempRect = new Rectangle();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = shapeBuilders.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = BigPool.get(BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.attributeOffset = vertOffset;\n  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.baseColor = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = shapeBuilders[shape.type];\n    let topology = \"triangle-list\";\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      if (!lineStyle.pixelLine) {\n        buildLine(points, lineStyle, false, close, vertices, indices);\n      } else {\n        buildPixelLine(points, close, vertices, indices);\n        topology = \"line-list\";\n      }\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.WHITE) {\n      const textureMatrix = style.matrix;\n      if (textureMatrix) {\n        if (matrix) {\n          textureMatrix.append(matrix.clone().invert());\n        }\n        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n      }\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.baseColor = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    graphicsBatch.topology = topology;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = shapeBuilders[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\nexport { buildContextBatches, shapeBuilders };\n//# sourceMappingURL=buildContextBatches.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { Topology } from '../../../../rendering/renderers/shared/geometry/const';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { GraphicsPath } from '../path/GraphicsPath';\nimport type { ShapePath } from '../path/ShapePath';\n\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            }\n\n            addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    hole: GraphicsPath,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = shapeBuilders[shape.type];\n        let topology: Topology = 'triangle-list';\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (hole && lastIndex === i)\n            {\n                if (lastIndex !== 0)\n                {\n                    console.warn('[Pixi Graphics] only the last shape have be cut out');\n                }\n\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(hole.shapePath);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            if (!lineStyle.pixelLine)\n            {\n                buildLine(points, lineStyle, false, close, vertices, indices);\n            }\n            else\n            {\n                buildPixelLine(points, close, vertices, indices);\n                topology = 'line-list';\n            }\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = style.matrix;\n\n            if (textureMatrix)\n            {\n                // todo can prolly do this before calculating uvs..\n                if (matrix)\n                {\n                    textureMatrix.append(matrix.clone().invert());\n                }\n\n                buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n            }\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        graphicsBatch.topology = topology;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(shape: ShapePath)\n{\n    if (!shape) return [];\n\n    const holePrimitives = shape.shapePrimitives;\n\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n","\"use strict\";\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\nexport { buildSimpleUvs, buildUvs };\n//# sourceMappingURL=buildUvs.mjs.map\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @memberof rendering\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n","\"use strict\";\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset || (offset = 0);\n  stride || (stride = 2);\n  size || (size = vertices.length / stride - offset);\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\nexport { transformVertices };\n//# sourceMappingURL=transformVertices.mjs.map\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @memberof rendering\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset ||= 0;\n    stride ||= 2;\n    size ||= (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors.mjs';\n\n\"use strict\";\nconst identityMatrix = new Matrix();\nclass BatchableGraphics {\n  constructor() {\n    this.packAsQuad = false;\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    this.applyTransform = true;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n  }\n  get uvs() {\n    return this.geometryData.uvs;\n  }\n  get positions() {\n    return this.geometryData.vertices;\n  }\n  get indices() {\n    return this.geometryData.indices;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return \"normal\";\n  }\n  get color() {\n    const rgb = this.baseColor;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    const renderable = this.renderable;\n    if (renderable) {\n      return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);\n    }\n    return bgr + (this.alpha * 255 << 24);\n  }\n  get transform() {\n    return this.renderable?.groupTransform || identityMatrix;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.attributeOffset = this.attributeOffset;\n    gpuBuffer.attributeSize = this.attributeSize;\n    gpuBuffer.baseColor = this.baseColor;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n    gpuBuffer.topology = this.topology;\n  }\n  reset() {\n    this.applyTransform = true;\n    this.renderable = null;\n    this.topology = \"triangle-list\";\n  }\n}\n\nexport { BatchableGraphics };\n//# sourceMappingURL=BatchableGraphics.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors';\n\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\nconst identityMatrix = new Matrix();\n/**\n * A batchable graphics object.\n * @ignore\n */\n\nexport class BatchableGraphics implements DefaultBatchableMeshElement\n{\n    public readonly packAsQuad = false;\n    public batcherName = 'default';\n\n    public texture: Texture;\n\n    public topology: Topology = 'triangle-list';\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public attributeOffset: number;\n    public attributeSize: number;\n    public baseColor: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get uvs()\n    {\n        return this.geometryData.uvs;\n    }\n\n    get positions()\n    {\n        return this.geometryData.vertices;\n    }\n\n    get indices()\n    {\n        return this.geometryData.indices;\n    }\n\n    get blendMode()\n    {\n        if (this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n    get color()\n    {\n        const rgb = this.baseColor;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n        const renderable = this.renderable;\n\n        if (renderable)\n        {\n            return multiplyHexColors(bgr, renderable.groupColor)\n            + ((this.alpha * renderable.groupAlpha * 255) << 24);\n        }\n\n        return bgr + ((this.alpha * 255) << 24);\n    }\n\n    get transform()\n    {\n        return this.renderable?.groupTransform || identityMatrix;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.attributeOffset = this.attributeOffset;\n        gpuBuffer.attributeSize = this.attributeSize;\n\n        gpuBuffer.baseColor = this.baseColor;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n\n        gpuBuffer.topology = this.topology;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n        this.renderable = null;\n        this.topology = 'triangle-list';\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildCircle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"circle\"\n  },\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === \"circle\") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === \"ellipse\") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\nconst buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: \"ellipse\" } };\nconst buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: \"roundedRectangle\" } };\n\nexport { buildCircle, buildEllipse, buildRoundedRectangle };\n//# sourceMappingURL=buildCircle.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'circle',\n    },\n\n    build(shape: RoundedShape, points: number[])\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            return points;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return points;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return points;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return points;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n\nexport const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: 'ellipse' } };\nexport const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: 'roundedRectangle' } };\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { closePointEps, curveEps } from '../const.mjs';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints.mjs';\n\n\"use strict\";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point(points[0], points[1]);\n  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === \"round\") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === \"round\") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === \"round\") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\nexport { buildLine };\n//# sourceMappingURL=buildLine.mjs.map\n","import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeAttributes } from '../FillTypes';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param indices\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeAttributes,\n    flipAlignment: boolean,\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n","\"use strict\";\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\nexport { closePointEps, curveEps };\n//# sourceMappingURL=const.mjs.map\n","export type LineCap = 'butt' | 'round' | 'square';\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\nexport const closePointEps = 1e-4;\nexport const curveEps = 0.0001;\n","\"use strict\";\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\nexport { getOrientationOfPoints };\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n","export function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n","import { closePointEps } from '../const.mjs';\n\n\"use strict\";\nfunction buildPixelLine(points, closed, vertices, indices) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const fx = points[0];\n  const fy = points[1];\n  const lx = points[points.length - 2];\n  const ly = points[points.length - 1];\n  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;\n  const verts = vertices;\n  const length = points.length / 2;\n  const indexStart = verts.length / 2;\n  for (let i = 0; i < length; i++) {\n    verts.push(points[i * 2]);\n    verts.push(points[i * 2 + 1]);\n  }\n  for (let i = 0; i < length - 1; i++) {\n    indices.push(indexStart + i, indexStart + i + 1);\n  }\n  if (closePath) {\n    indices.push(indexStart + length - 1, indexStart);\n  }\n}\n\nexport { buildPixelLine };\n//# sourceMappingURL=buildPixelLine.mjs.map\n","import { closePointEps } from '../const';\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param closed\n * @param vertices\n * @param indices\n */\nexport function buildPixelLine(\n    points: number[],\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n\n    const fx = points[0];\n    const fy = points[1];\n\n    const lx = points[points.length - 2];\n\n    const ly = points[points.length - 1];\n\n    const closePath = closed || (Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps);\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    const indexStart = verts.length / 2;\n\n    for (let i = 0; i < length; i++)\n    {\n        verts.push(points[(i * 2)]);\n        verts.push(points[(i * 2) + 1]);\n    }\n\n    for (let i = 0; i < length - 1; i++)\n    {\n        indices.push(indexStart + i, indexStart + i + 1);\n    }\n\n    if (closePath)\n    {\n        indices.push(indexStart + length - 1, indexStart);\n    }\n}\n\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles.mjs';\n\n\"use strict\";\nconst emptyArray = [];\nconst buildPolygon = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"polygon\"\n  },\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\nexport { buildPolygon };\n//# sourceMappingURL=buildPolygon.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'polygon',\n    },\n\n    build(shape: Polygon, points: number[]): number[]\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n","import earcut from 'earcut';\n\n\"use strict\";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\nexport { triangulateWithHoles };\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n","import { default as earcut } from 'earcut';\n\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildRectangle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"rectangle\"\n  },\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildRectangle };\n//# sourceMappingURL=buildRectangle.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'rectangle',\n    },\n\n    build(shape: Rectangle, points: number[]): number[]\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return points;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildTriangle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"triangle\"\n  },\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildTriangle };\n//# sourceMappingURL=buildTriangle.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'triangle',\n    },\n\n    build(shape: Triangle, points: number[]): number[]\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (mAngleTolerance < curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveQuadratic };\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n","// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n","\"use strict\";\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\nexport { buildArc };\n//# sourceMappingURL=buildArc.mjs.map\n","export function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps ||= Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n","import { buildArc } from './buildArc.mjs';\n\n\"use strict\";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\nexport { buildArcTo };\n//# sourceMappingURL=buildArcTo.mjs.map\n","import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier.mjs';\n\n\"use strict\";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\nexport { buildArcToSvg };\n//# sourceMappingURL=buildArcToSvg.mjs.map\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n","\"use strict\";\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\nexport { roundedShapeArc, roundedShapeQuadraticCurve };\n//# sourceMappingURL=roundShape.mjs.map\n","import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { GraphicsPath } from '../path/GraphicsPath.mjs';\n\n\"use strict\";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === \"string\") {\n    const div = document.createElement(\"div\");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector(\"svg\");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case \"path\":\n      d = svg.getAttribute(\"d\");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"circle\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      r = parseFloatAttribute(svg, \"r\", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"rect\":\n      x = parseFloatAttribute(svg, \"x\", 0);\n      y = parseFloatAttribute(svg, \"y\", 0);\n      width = parseFloatAttribute(svg, \"width\", 0);\n      height = parseFloatAttribute(svg, \"height\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"ellipse\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"line\":\n      x1 = parseFloatAttribute(svg, \"x1\", 0);\n      y1 = parseFloatAttribute(svg, \"y1\", 0);\n      x2 = parseFloatAttribute(svg, \"x2\", 0);\n      y2 = parseFloatAttribute(svg, \"y2\", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polygon\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polyline\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"g\":\n    case \"svg\":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute(\"style\");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(\";\");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(\":\");\n      switch (key) {\n        case \"stroke\":\n          if (value !== \"none\") {\n            strokeStyle.color = Color.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case \"stroke-width\":\n          strokeStyle.width = Number(value);\n          break;\n        case \"fill\":\n          if (value !== \"none\") {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(value).toNumber();\n          }\n          break;\n        case \"fill-opacity\":\n          fillStyle.alpha = Number(value);\n          break;\n        case \"stroke-opacity\":\n          strokeStyle.alpha = Number(value);\n          break;\n        case \"opacity\":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute(\"stroke\");\n    if (stroke && stroke !== \"none\") {\n      useStroke = true;\n      strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, \"stroke-width\", 1);\n    }\n    const fill = svg.getAttribute(\"fill\");\n    if (fill && fill !== \"none\") {\n      useFill = true;\n      fillStyle.color = Color.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\nexport { SVGParser };\n//# sourceMappingURL=SVGParser.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillStyle, StrokeStyle } from '../FillTypes';\nimport type {\n    GraphicsContext,\n} from '../GraphicsContext';\n\ninterface Session\n{\n    context: GraphicsContext;\n    path: GraphicsPath;\n}\n\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    if (typeof svg === 'string')\n    {\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    const session = {\n        context: graphicsContext,\n        path: new GraphicsPath(),\n    };\n\n    renderChildren(svg, session, null, null);\n\n    return graphicsContext;\n}\n\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n            d = svg.getAttribute('d') as string;\n\n            graphicsPath = new GraphicsPath(d);\n\n            session.context.path(graphicsPath);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'circle':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            r = parseFloatAttribute(svg, 'r', 0);\n\n            session.context.ellipse(cx, cy, r, r);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'rect':\n            x = parseFloatAttribute(svg, 'x', 0);\n            y = parseFloatAttribute(svg, 'y', 0);\n\n            width = parseFloatAttribute(svg, 'width', 0);\n            height = parseFloatAttribute(svg, 'height', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'ellipse':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry); // , 0, Math.PI * 2);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'line':\n            x1 = parseFloatAttribute(svg, 'x1', 0);\n            y1 = parseFloatAttribute(svg, 'y1', 0);\n\n            x2 = parseFloatAttribute(svg, 'x2', 0);\n            y2 = parseFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, true);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, false);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        // children will cover these two..\n        case 'g':\n        case 'svg':\n            break;\n        default: {\n            // eslint-disable-next-line no-console\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n\nfunction parseFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n\nfunction parseStyle(svg: SVGElement): { strokeStyle: ConvertedStrokeStyle; fillStyle: ConvertedFillStyle }\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    let useFill = false;\n    let useStroke = false;\n\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i];\n\n            const [key, value] = stylePart.split(':');\n\n            switch (key)\n            {\n                case 'stroke':\n                    if (value !== 'none')\n                    {\n                        strokeStyle.color = Color.shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n\n                    break;\n                case 'stroke-width':\n                    strokeStyle.width = Number(value);\n                    break;\n                case 'fill':\n                    if (value !== 'none')\n                    {\n                        useFill = true;\n                        fillStyle.color = Color.shared.setValue(value).toNumber();\n                    }\n                    break;\n                case 'fill-opacity':\n                    fillStyle.alpha = Number(value);\n                    break;\n                case 'stroke-opacity':\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case 'opacity':\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    }\n    else\n    {\n        const stroke = svg.getAttribute('stroke');\n\n        if (stroke && stroke !== 'none')\n        {\n            useStroke = true;\n            strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n\n            strokeStyle.width = parseFloatAttribute(svg, 'stroke-width', 1);\n        }\n\n        const fill = svg.getAttribute('fill');\n\n        if (fill && fill !== 'none')\n        {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(fill).toNumber();\n        }\n    }\n\n    return {\n        strokeStyle: useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: useFill ? (fillStyle as ConvertedFillStyle) : null,\n    };\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\nimport { FillPattern } from '../fill/FillPattern.mjs';\n\n\"use strict\";\nfunction isColorLike(value) {\n  return Color.isColorLike(value);\n}\nfunction isFillPattern(value) {\n  return value instanceof FillPattern;\n}\nfunction isFillGradient(value) {\n  return value instanceof FillGradient;\n}\nfunction handleColorLike(fill, value, defaultStyle) {\n  const temp = Color.shared.setValue(value ?? 0);\n  fill.color = temp.toNumber();\n  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n  fill.texture = Texture.WHITE;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillPattern(fill, value, defaultStyle) {\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillGradient(fill, value, defaultStyle) {\n  value.buildLinearGradient();\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillObject(value, defaultStyle) {\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== Texture.WHITE) {\n      const m = style.matrix?.clone().invert() || new Matrix();\n      m.translate(style.texture.frame.x, style.texture.frame.y);\n      m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === \"clamp-to-edge\") {\n      sourceStyle.addressMode = \"repeat\";\n      sourceStyle.update();\n    }\n  }\n  const color = Color.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\nfunction toFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  const fill = {};\n  const objectStyle = value;\n  if (isColorLike(value)) {\n    return handleColorLike(fill, value, defaultStyle);\n  } else if (isFillPattern(value)) {\n    return handleFillPattern(fill, value, defaultStyle);\n  } else if (isFillGradient(value)) {\n    return handleFillGradient(fill, value, defaultStyle);\n  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {\n    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {\n    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n  }\n  return handleFillObject(objectStyle, defaultStyle);\n}\nfunction toStrokeStyle(value, defaultStyle) {\n  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n  const fill = toFillStyle(value, rest);\n  if (!fill) {\n    return null;\n  }\n  return {\n    width,\n    alignment,\n    miterLimit,\n    cap,\n    join,\n    pixelLine,\n    ...fill\n  };\n}\n\nexport { toFillStyle, toStrokeStyle };\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n} from '../FillTypes';\n\nfunction isColorLike(value: unknown): value is ColorSource\n{\n    return Color.isColorLike(value as ColorSource);\n}\n\nfunction isFillPattern(value: unknown): value is FillPattern\n{\n    return value instanceof FillPattern;\n}\n\nfunction isFillGradient(value: unknown): value is FillGradient\n{\n    return value instanceof FillGradient;\n}\n\n/**\n * Handles the case where the value is a ColorLike\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(0xff0000)\n * graphics.fill(new Color(0xff0000))\n * graphics.fill({ r: 255, g: 0, b: 0 })\n */\nfunction handleColorLike(\n    fill: FillStyle,\n    value: ColorSource,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    const temp = Color.shared.setValue(value ?? 0);\n\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = Texture.WHITE;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillPattern\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillPattern(0xff0000))\n */\nfunction handleFillPattern(\n    fill: FillStyle,\n    value: FillPattern,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillGradient\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillGradient(0, 0, 200, 0))\n */\nfunction handleFillGradient(\n    fill: FillStyle,\n    value: FillGradient,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    value.buildLinearGradient();\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is not a direct Pixi Color, PatternFill, or GradientFill but instead\n * an object with potentially `color`\n * @example\n * {\n *   color: new Color(0xff0000)\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * }\n * @param value\n * @param defaultStyle\n */\nfunction handleFillObject(value: FillStyle, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    const style = { ...defaultStyle, ...(value as FillStyle) };\n\n    if (style.texture)\n    {\n        if (style.texture !== Texture.WHITE)\n        {\n            const m = style.matrix?.clone().invert() || new Matrix();\n\n            m.translate(style.texture.frame.x, style.texture.frame.y);\n            m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n\n            style.matrix = m;\n        }\n\n        const sourceStyle = style.texture.source.style;\n\n        if (sourceStyle.addressMode === 'clamp-to-edge')\n        {\n            sourceStyle.addressMode = 'repeat';\n            sourceStyle.update();\n        }\n    }\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null; // todo: lets optimise this!\n\n    return style as ConvertedFillStyle;\n}\n\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(\n    value: T,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    const fill: ConvertedFillStyle = {} as ConvertedFillStyle;\n    const objectStyle = value as FillStyle;\n\n    if (isColorLike(value))\n    {\n        return handleColorLike(fill, value, defaultStyle);\n    }\n    else if (isFillPattern(value))\n    {\n        return handleFillPattern(fill, value, defaultStyle);\n    }\n    else if (isFillGradient(value))\n    {\n        return handleFillGradient(fill, value, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillPattern(objectStyle.fill))\n    {\n        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillGradient(objectStyle.fill))\n    {\n        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    }\n\n    return handleFillObject(objectStyle, defaultStyle);\n}\n\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle\n{\n    const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n    const fill = toFillStyle(value, rest);\n\n    if (!fill)\n    {\n        return null;\n    }\n\n    return {\n        width,\n        alignment,\n        miterLimit,\n        cap,\n        join,\n        pixelLine,\n        ...fill,\n    };\n}\n","import { Color } from '../../../color/Color.mjs';\n\n\"use strict\";\nconst valuesToIterateForKeys = [\n  \"align\",\n  \"breakWords\",\n  \"cssOverrides\",\n  \"fontVariant\",\n  \"fontWeight\",\n  \"leading\",\n  \"letterSpacing\",\n  \"lineHeight\",\n  \"padding\",\n  \"textBaseline\",\n  \"trim\",\n  \"whiteSpace\",\n  \"wordWrap\",\n  \"wordWrapWidth\",\n  \"fontFamily\",\n  \"fontStyle\",\n  \"fontSize\"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = `_${valuesToIterateForKeys[i]}`;\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  index = addDropShadowKey(style.dropShadow, key, index);\n  return key.join(\"-\");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.styleKey;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\nfunction addDropShadowKey(dropShadow, key, index) {\n  if (!dropShadow)\n    return index;\n  key[index++] = dropShadow.alpha;\n  key[index++] = dropShadow.angle;\n  key[index++] = dropShadow.blur;\n  key[index++] = dropShadow.distance;\n  key[index++] = Color.shared.setValue(dropShadow.color).toNumber();\n  return index;\n}\n\nexport { generateTextStyleKey };\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { HTMLTextStyle } from '../../text-html/HTMLTextStyle';\nimport type { TextStyle } from '../TextStyle';\n\nconst valuesToIterateForKeys: Partial<keyof TextStyle | keyof HTMLTextStyle>[] = [\n    'align',\n    'breakWords',\n    'cssOverrides',\n    'fontVariant',\n    'fontWeight',\n    'leading',\n    'letterSpacing',\n    'lineHeight',\n    'padding',\n    'textBaseline',\n    'trim',\n    'whiteSpace',\n    'wordWrap',\n    'wordWrapWidth',\n    'fontFamily',\n    'fontStyle',\n    'fontSize',\n] as const;\n\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n */\nexport function generateTextStyleKey(style: TextStyle): string\n{\n    const key = [];\n\n    let index = 0;\n\n    for (let i = 0; i < valuesToIterateForKeys.length; i++)\n    {\n        const prop = `_${valuesToIterateForKeys[i]}`;\n\n        key[index++] = style[prop as keyof typeof style];\n    }\n\n    index = addFillStyleKey(style._fill, key as string[], index);\n    index = addStokeStyleKey(style._stroke, key as string[], index);\n    index = addDropShadowKey(style.dropShadow, key as string[], index);\n\n    return key.join('-');\n}\n\nfunction addFillStyleKey(fillStyle: ConvertedFillStyle, key: (number | string)[], index: number)\n{\n    if (!fillStyle) return index;\n\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = fillStyle.fill?.styleKey;\n\n    return index;\n}\n\nfunction addStokeStyleKey(strokeStyle: ConvertedStrokeStyle, key: (number | string)[], index: number)\n{\n    if (!strokeStyle) return index;\n\n    index = addFillStyleKey(strokeStyle, key, index);\n\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n\n    return index;\n}\n\nfunction addDropShadowKey(dropShadow: TextStyle['dropShadow'], key: (number | string)[], index: number)\n{\n    if (!dropShadow) return index;\n\n    key[index++] = dropShadow.alpha;\n    key[index++] = dropShadow.angle;\n    key[index++] = dropShadow.blur;\n    key[index++] = dropShadow.distance;\n    key[index++] = Color.shared.setValue(dropShadow.color).toNumber();\n\n    return index;\n}\n","import { Color } from '../../color/Color.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nconst _DynamicBitmapFont = class _DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 0;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = { ..._DynamicBitmapFont.defaultOptions, ...options };\n    this._textureSize = dynamicOptions.textureSize;\n    this._mipmap = dynamicOptions.mipmap;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture.WHITE;\n      style._fill.fill = null;\n    }\n    this.applyFillAsTint = dynamicOptions.overrideFill;\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = fontStringFromTextStyle(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    const maxTextureWidth = canvas.width / this.resolution;\n    const maxTextureHeight = canvas.height / this.resolution;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = metrics.width * fontScale;\n      const textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n      const height = metrics.height * fontScale;\n      const paddedWidth = textureGlyphWidth + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > maxTextureWidth) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > maxTextureHeight) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n      this._textureSize,\n      this._textureSize,\n      textureResolution\n    );\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture({\n      source: new ImageSource({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        autoGenerateMipmaps: this._mipmap\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = fontStringFromTextStyle(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = getCanvasFillStyle(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = getCanvasFillStyle(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = \"black\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n};\n_DynamicBitmapFont.defaultOptions = {\n  textureSize: 512,\n  style: new TextStyle(),\n  mipmap: true\n};\nlet DynamicBitmapFont = _DynamicBitmapFont;\n\nexport { DynamicBitmapFont };\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > maxTextureWidth)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > maxTextureHeight)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { nextPow2 } from '../../../../maths/misc/pow2.mjs';\n\n\"use strict\";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext(\"2d\");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = nextPow2(minWidth);\n    minHeight = nextPow2(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    canvasAndContext.context.clearRect(0, 0, width, height);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\nexport { CanvasPool, CanvasPoolClass };\n//# sourceMappingURL=CanvasPool.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        canvasAndContext.context.clearRect(0, 0, width, height);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\n\n\"use strict\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = fontStringFromTextStyle(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    const metrics = context.measureText(text);\n    let metricWidth = metrics.width;\n    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n    if (metricWidth > 0) {\n      if (useExperimentalLetterSpacing) {\n        metricWidth -= letterSpacing;\n        boundsWidth -= letterSpacing;\n      } else {\n        const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        metricWidth += val;\n        boundsWidth += val;\n      }\n    }\n    return Math.max(metricWidth, boundsWidth);\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== \"number\") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext(\"2d\", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = DOMAdapter.get().createCanvas();\n      } catch (_cx) {\n        canvas = DOMAdapter.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\nexport { CanvasTextMetrics };\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @memberof text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { CanvasTextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = CanvasTextMetrics.measureText('Your text', style);\n * @memberof text\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|ÉqÅ';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    private static readonly _measurementCache: Record<string, CanvasTextMetrics> = {};\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}:${style.styleKey}`;\n\n        // TODO - if we find this starts to go nuts with memory, we can remove the cache\n        // or instead just stick a usage tick that we increment each time we return it.\n        // if some are not used, we can just tidy them up!\n        if (CanvasTextMetrics._measurementCache[textKey]) return CanvasTextMetrics._measurementCache[textKey];\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // CanvasTextMetrics._measurementCache[textKey] = measurements;\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        const metrics = context.measureText(text);\n        let metricWidth = metrics.width;\n        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n\n        if (metricWidth > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                metricWidth -= letterSpacing;\n                boundsWidth -= letterSpacing;\n            }\n            else\n            {\n                const val = (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n\n                metricWidth += val;\n                boundsWidth += val;\n            }\n        }\n\n        // NOTE: this is a bit of a hack as metrics.width and the bounding box width do not measure the same thing\n        // We can't seem to exclusively use one or the other, so are taking the largest of the two\n        return Math.max(metricWidth, boundsWidth);\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convenience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (_cx)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n","\"use strict\";\nconst genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(\",\");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `\"${fontFamily}\"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\nexport { fontStringFromTextStyle };\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n","import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient.mjs';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern.mjs';\n\n\"use strict\";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {\n    return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, \"repeat\");\n    const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillPattern) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, \"repeat\");\n    const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillGradient) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === \"linear\") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  warn(\"FillStyle not recognised\", fillStyle);\n  return \"red\";\n}\n\nexport { getCanvasFillStyle };\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/FillTypes';\n\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D): string | CanvasGradient | CanvasPattern\n{\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n    }\n    else if (!fillStyle.fill)\n    {\n        // fancy set up...\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n\n        // create an inverted scale matrix..\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill;\n\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill;\n\n        if (fillGradient.type === 'linear')\n        {\n            const gradient = context.createLinearGradient(\n                fillGradient.x0,\n                fillGradient.y0,\n                fillGradient.x1,\n                fillGradient.y1\n            );\n\n            fillGradient.gradientStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n\n            return gradient;\n        }\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nclass AbstractBitmapFont extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = \"\";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: \"none\", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    this.applyFillAsTint = true;\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    deprecation(v8_0_0, \"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.\");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    deprecation(v8_0_0, \"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.\");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or \"none\".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.\");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.\");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture?.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\nexport { AbstractBitmapFont };\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    public applyFillAsTint = true;\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            // texture may not exist if the char is \" \", \\n, \\r, or \\t.\n            this.chars[i].texture?.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","\"use strict\";\nfunction resolveCharacters(chars) {\n  if (chars === \"\") {\n    return [];\n  }\n  if (typeof chars === \"string\") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error(\"[BitmapFont]: Invalid character delimiter.\");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  }\n  return result;\n}\n\nexport { resolveCharacters };\n//# sourceMappingURL=resolveCharacters.mjs.map\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","\"use strict\";\nfunction getBitmapTextLayout(chars, style, font, trimEnd) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    if (trimEnd) {\n      let lastChar = currentLine.chars[index];\n      while (lastChar === \" \") {\n        currentLine.width -= font.chars[lastChar].xAdvance;\n        lastChar = currentLine.chars[--index];\n      }\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[\" \"];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === \"center\") {\n    alignCenter(layoutData);\n  } else if (style.align === \"right\") {\n    alignRight(layoutData);\n  } else if (style.align === \"justify\") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\nexport { getBitmapTextLayout };\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(\n    chars: string[],\n    style: TextStyle,\n    font: AbstractBitmapFont<any>,\n    trimEnd: boolean\n): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n\n        if (trimEnd)\n        {\n            let lastChar = currentLine.chars[index];\n\n            while (lastChar === ' ')\n            {\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../../view/ViewContainer.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\n\n\"use strict\";\nclass Graphics extends ViewContainer {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    this.renderPipeId = \"graphics\";\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext();\n    } else {\n      this._context = context;\n    }\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off(\"update\", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Graphics objects do not need to update their bounds as the context handles this.\n   * @private\n   */\n  updateBounds() {\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    if (color !== void 0)\n      fillStyle.color = color;\n    if (alpha !== void 0)\n      fillStyle.alpha = alpha;\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n//# sourceMappingURL=Graphics.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer } from '../../view/ViewContainer';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends ViewContainer implements Instruction\n{\n    public override readonly renderPipeId: string = 'graphics';\n    public batched: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Graphics objects do not need to update their bounds as the context handles this.\n     * @private\n     */\n    protected updateBounds(): void { /** */ }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n     * pattern object, or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     * or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyle object for advanced fills.\n     * @param {FillInput} style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a\n     * complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n     * complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise\n     * (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction.\n     * If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified,\n     * the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        if (color !== undefined) fillStyle.color = color;\n        if (alpha !== undefined) fillStyle.alpha = alpha;\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","require('./helpers/bundle-manifest').register(new __parcel__URL__(\"\").toString(),JSON.parse(\"[\\\"5ZPII\\\",\\\"index.28167d82.js\\\",\\\"5nC1g\\\",\\\"browserAll.bfad46de.js\\\",\\\"d1bSR\\\",\\\"browserAll.7aacd795.js\\\",\\\"8rxSw\\\",\\\"webworkerAll.2a53aaf8.js\\\",\\\"fqXAI\\\",\\\"WebGPURenderer.f42d4328.js\\\",\\\"gyKa4\\\",\\\"WebGPURenderer.421fc519.js\\\",\\\"dgumL\\\",\\\"WebGLRenderer.6e2650a7.js\\\"]\"));","import { Application } from 'pixi.js';\r\nimport { Game } from './game';\r\n\r\n(async () =>\r\n{\r\n    // Create a new application\r\n    const app = new Application();\r\n\r\n    // Initialize the application\r\n    await app.init({ background: '#1099bb', resizeTo: document.body });\r\n\r\n    // Append the application canvas to the document body\r\n    document.body.appendChild(app.canvas);\r\n\r\n    const reelConfig = {\r\n        reel: 5,\r\n        row: 3,\r\n        reelWidth: 100,\r\n        symbolSize: 100,\r\n    }\r\n\r\n    const game = new Game(app ,reelConfig);\r\n    await game.init();\r\n})();","import { browserExt } from './environment-browser/browserExt.mjs';\nimport { webworkerExt } from './environment-webworker/webworkerExt.mjs';\nimport { extensions } from './extensions/Extensions.mjs';\nexport { ExtensionType, normalizeExtensionPriority } from './extensions/Extensions.mjs';\nimport './rendering/init.mjs';\nimport './spritesheet/init.mjs';\nimport './accessibility/index.mjs';\nimport './advanced-blend-modes/index.mjs';\nimport './app/index.mjs';\nimport './assets/index.mjs';\nimport './color/index.mjs';\nimport './compressed-textures/index.mjs';\nimport './culling/index.mjs';\nimport './environment/index.mjs';\nimport './environment-browser/index.mjs';\nimport './environment-webworker/index.mjs';\nimport './events/index.mjs';\nimport './extensions/index.mjs';\nimport './filters/index.mjs';\nimport './maths/index.mjs';\nimport './prepare/index.mjs';\nimport './rendering/index.mjs';\nimport './scene/index.mjs';\nimport './spritesheet/index.mjs';\nimport './ticker/index.mjs';\nimport './utils/index.mjs';\nexport { AccessibilitySystem } from './accessibility/AccessibilitySystem.mjs';\nexport { accessibilityTarget } from './accessibility/accessibilityTarget.mjs';\nexport { ColorBlend } from './advanced-blend-modes/ColorBlend.mjs';\nexport { ColorBurnBlend } from './advanced-blend-modes/ColorBurnBlend.mjs';\nexport { ColorDodgeBlend } from './advanced-blend-modes/ColorDodgeBlend.mjs';\nexport { DarkenBlend } from './advanced-blend-modes/DarkenBlend.mjs';\nexport { DifferenceBlend } from './advanced-blend-modes/DifferenceBlend.mjs';\nexport { DivideBlend } from './advanced-blend-modes/DivideBlend.mjs';\nexport { ExclusionBlend } from './advanced-blend-modes/ExclusionBlend.mjs';\nexport { HardLightBlend } from './advanced-blend-modes/HardLightBlend.mjs';\nexport { HardMixBlend } from './advanced-blend-modes/HardMixBlend.mjs';\nexport { LightenBlend } from './advanced-blend-modes/LightenBlend.mjs';\nexport { LinearBurnBlend } from './advanced-blend-modes/LinearBurnBlend.mjs';\nexport { LinearDodgeBlend } from './advanced-blend-modes/LinearDodgeBlend.mjs';\nexport { LinearLightBlend } from './advanced-blend-modes/LinearLightBlend.mjs';\nexport { LuminosityBlend } from './advanced-blend-modes/LuminosityBlend.mjs';\nexport { NegationBlend } from './advanced-blend-modes/NegationBlend.mjs';\nexport { OverlayBlend } from './advanced-blend-modes/OverlayBlend.mjs';\nexport { PinLightBlend } from './advanced-blend-modes/PinLightBlend.mjs';\nexport { SaturationBlend } from './advanced-blend-modes/SaturationBlend.mjs';\nexport { SoftLightBlend } from './advanced-blend-modes/SoftLightBlend.mjs';\nexport { SubtractBlend } from './advanced-blend-modes/SubtractBlend.mjs';\nexport { VividLightBlend } from './advanced-blend-modes/VividLightBlend.mjs';\nexport { Application } from './app/Application.mjs';\nexport { ResizePlugin } from './app/ResizePlugin.mjs';\nexport { TickerPlugin } from './app/TickerPlugin.mjs';\nexport { Assets, AssetsClass } from './assets/Assets.mjs';\nexport { BackgroundLoader } from './assets/BackgroundLoader.mjs';\nexport { Cache } from './assets/cache/Cache.mjs';\nexport { cacheTextureArray } from './assets/cache/parsers/cacheTextureArray.mjs';\nexport { detectAvif } from './assets/detections/parsers/detectAvif.mjs';\nexport { detectDefaults } from './assets/detections/parsers/detectDefaults.mjs';\nexport { detectMp4 } from './assets/detections/parsers/detectMp4.mjs';\nexport { detectOgv } from './assets/detections/parsers/detectOgv.mjs';\nexport { detectWebm } from './assets/detections/parsers/detectWebm.mjs';\nexport { detectWebp } from './assets/detections/parsers/detectWebp.mjs';\nexport { testImageFormat } from './assets/detections/utils/testImageFormat.mjs';\nexport { testVideoFormat } from './assets/detections/utils/testVideoFormat.mjs';\nexport { Loader } from './assets/loader/Loader.mjs';\nexport { LoaderParserPriority } from './assets/loader/parsers/LoaderParser.mjs';\nexport { loadJson } from './assets/loader/parsers/loadJson.mjs';\nexport { loadTxt } from './assets/loader/parsers/loadTxt.mjs';\nexport { getFontFamilyName, loadWebFont } from './assets/loader/parsers/loadWebFont.mjs';\nexport { loadSvg } from './assets/loader/parsers/textures/loadSVG.mjs';\nexport { loadImageBitmap, loadTextures } from './assets/loader/parsers/textures/loadTextures.mjs';\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo } from './assets/loader/parsers/textures/loadVideoTextures.mjs';\nexport { createTexture } from './assets/loader/parsers/textures/utils/createTexture.mjs';\nexport { WorkerManager } from './assets/loader/workers/WorkerManager.mjs';\nexport { resolveJsonUrl } from './assets/resolver/parsers/resolveJsonUrl.mjs';\nexport { resolveTextureUrl } from './assets/resolver/parsers/resolveTextureUrl.mjs';\nexport { Resolver, getUrlExtension } from './assets/resolver/Resolver.mjs';\nexport { checkDataUrl } from './assets/utils/checkDataUrl.mjs';\nexport { checkExtension } from './assets/utils/checkExtension.mjs';\nexport { convertToList } from './assets/utils/convertToList.mjs';\nexport { copySearchParams } from './assets/utils/copySearchParams.mjs';\nexport { createStringVariations } from './assets/utils/createStringVariations.mjs';\nexport { isSingleItem } from './assets/utils/isSingleItem.mjs';\nexport { Color } from './color/Color.mjs';\nexport { detectBasis } from './compressed-textures/basis/detectBasis.mjs';\nexport { loadBasis } from './compressed-textures/basis/loadBasis.mjs';\nexport { createLevelBuffers } from './compressed-textures/basis/utils/createLevelBuffers.mjs';\nexport { gpuFormatToBasisTranscoderFormat } from './compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs';\nexport { basisTranscoderUrls, setBasisTranscoderPath } from './compressed-textures/basis/utils/setBasisTranscoderPath.mjs';\nexport { loadBasisOnWorker } from './compressed-textures/basis/worker/loadBasisOnWorker.mjs';\nexport { D3D10_RESOURCE_DIMENSION, D3DFMT, DDS, DXGI_FORMAT, DXGI_TO_TEXTURE_FORMAT, FOURCC_TO_TEXTURE_FORMAT, TEXTURE_FORMAT_BLOCK_SIZE } from './compressed-textures/dds/const.mjs';\nexport { loadDDS } from './compressed-textures/dds/loadDDS.mjs';\nexport { parseDDS } from './compressed-textures/dds/parseDDS.mjs';\nexport { loadKTX } from './compressed-textures/ktx/loadKTX.mjs';\nexport { parseKTX } from './compressed-textures/ktx/parseKTX.mjs';\nexport { GL_INTERNAL_FORMAT, KTX } from './compressed-textures/ktx2/const.mjs';\nexport { loadKTX2 } from './compressed-textures/ktx2/loadKTX2.mjs';\nexport { convertFormatIfRequired } from './compressed-textures/ktx2/utils/convertFormatIfRequired.mjs';\nexport { createLevelBuffersFromKTX } from './compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs';\nexport { getTextureFormatFromKTXTexture } from './compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs';\nexport { glFormatToGPUFormat } from './compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs';\nexport { gpuFormatToKTXBasisTranscoderFormat } from './compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs';\nexport { ktxTranscoderUrls, setKTXTranscoderPath } from './compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs';\nexport { vkFormatToGPUFormat } from './compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs';\nexport { loadKTX2onWorker } from './compressed-textures/ktx2/worker/loadKTX2onWorker.mjs';\nexport { detectCompressed } from './compressed-textures/shared/detectCompressed.mjs';\nexport { resolveCompressedTextureUrl, validFormats } from './compressed-textures/shared/resolveCompressedTextureUrl.mjs';\nexport { Culler } from './culling/Culler.mjs';\nexport { CullerPlugin } from './culling/CullerPlugin.mjs';\nexport { cullingMixin } from './culling/cullingMixin.mjs';\nexport { DOMAdapter } from './environment/adapter.mjs';\nexport { autoDetectEnvironment, loadEnvironmentExtensions } from './environment/autoDetectEnvironment.mjs';\nexport { BrowserAdapter } from './environment-browser/BrowserAdapter.mjs';\nexport { WebWorkerAdapter } from './environment-webworker/WebWorkerAdapter.mjs';\nexport { EventBoundary } from './events/EventBoundary.mjs';\nexport { EventSystem } from './events/EventSystem.mjs';\nexport { EventsTicker } from './events/EventTicker.mjs';\nexport { FederatedEvent } from './events/FederatedEvent.mjs';\nexport { FederatedContainer } from './events/FederatedEventTarget.mjs';\nexport { FederatedMouseEvent } from './events/FederatedMouseEvent.mjs';\nexport { FederatedPointerEvent } from './events/FederatedPointerEvent.mjs';\nexport { FederatedWheelEvent } from './events/FederatedWheelEvent.mjs';\nexport { default as blendTemplateFrag } from './filters/blend-modes/blend-template.frag.mjs';\nexport { default as blendTemplateVert } from './filters/blend-modes/blend-template.vert.mjs';\nexport { default as blendTemplateWgsl } from './filters/blend-modes/blend-template.wgsl.mjs';\nexport { default as hslWgsl } from './filters/blend-modes/hsl.wgsl.mjs';\nexport { default as alphaFrag } from './filters/defaults/alpha/alpha.frag.mjs';\nexport { default as alphaWgsl } from './filters/defaults/alpha/alpha.wgsl.mjs';\nexport { default as blurTemplateWgsl } from './filters/defaults/blur/gpu/blur-template.wgsl.mjs';\nexport { default as colorMatrixFilterFrag } from './filters/defaults/color-matrix/colorMatrixFilter.frag.mjs';\nexport { default as colorMatrixFilterWgsl } from './filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs';\nexport { default as defaultFilterVert } from './filters/defaults/defaultFilter.vert.mjs';\nexport { default as displacementFrag } from './filters/defaults/displacement/displacement.frag.mjs';\nexport { default as displacementVert } from './filters/defaults/displacement/displacement.vert.mjs';\nexport { default as displacementWgsl } from './filters/defaults/displacement/displacement.wgsl.mjs';\nexport { default as noiseFrag } from './filters/defaults/noise/noise.frag.mjs';\nexport { default as noiseWgsl } from './filters/defaults/noise/noise.wgsl.mjs';\nexport { default as maskFrag } from './filters/mask/mask.frag.mjs';\nexport { default as maskVert } from './filters/mask/mask.vert.mjs';\nexport { default as maskWgsl } from './filters/mask/mask.wgsl.mjs';\nexport { BlendModeFilter } from './filters/blend-modes/BlendModeFilter.mjs';\nexport { hslgl } from './filters/blend-modes/hls/GLhls.mjs';\nexport { hslgpu } from './filters/blend-modes/hls/GPUhls.mjs';\nexport { AlphaFilter } from './filters/defaults/alpha/AlphaFilter.mjs';\nexport { BlurFilter } from './filters/defaults/blur/BlurFilter.mjs';\nexport { BlurFilterPass } from './filters/defaults/blur/BlurFilterPass.mjs';\nexport { GAUSSIAN_VALUES } from './filters/defaults/blur/const.mjs';\nexport { generateBlurFragSource } from './filters/defaults/blur/gl/generateBlurFragSource.mjs';\nexport { generateBlurGlProgram } from './filters/defaults/blur/gl/generateBlurGlProgram.mjs';\nexport { generateBlurVertSource } from './filters/defaults/blur/gl/generateBlurVertSource.mjs';\nexport { generateBlurProgram } from './filters/defaults/blur/gpu/generateBlurProgram.mjs';\nexport { ColorMatrixFilter } from './filters/defaults/color-matrix/ColorMatrixFilter.mjs';\nexport { DisplacementFilter } from './filters/defaults/displacement/DisplacementFilter.mjs';\nexport { NoiseFilter } from './filters/defaults/noise/NoiseFilter.mjs';\nexport { Filter } from './filters/Filter.mjs';\nexport { FilterEffect } from './filters/FilterEffect.mjs';\nexport { FilterPipe } from './filters/FilterPipe.mjs';\nexport { FilterSystem } from './filters/FilterSystem.mjs';\nexport { MaskFilter } from './filters/mask/MaskFilter.mjs';\nexport { groupD8 } from './maths/matrix/groupD8.mjs';\nexport { Matrix } from './maths/matrix/Matrix.mjs';\nexport { DEG_TO_RAD, PI_2, RAD_TO_DEG } from './maths/misc/const.mjs';\nexport { isPow2, log2, nextPow2 } from './maths/misc/pow2.mjs';\nexport { squaredDistanceToLineSegment } from './maths/misc/squaredDistanceToLineSegment.mjs';\nexport { ObservablePoint } from './maths/point/ObservablePoint.mjs';\nexport { Point } from './maths/point/Point.mjs';\nexport { pointInTriangle } from './maths/point/pointInTriangle.mjs';\nexport { Circle } from './maths/shapes/Circle.mjs';\nexport { Ellipse } from './maths/shapes/Ellipse.mjs';\nexport { Polygon } from './maths/shapes/Polygon.mjs';\nexport { Rectangle } from './maths/shapes/Rectangle.mjs';\nexport { RoundedRectangle } from './maths/shapes/RoundedRectangle.mjs';\nexport { Triangle } from './maths/shapes/Triangle.mjs';\nexport { PrepareBase } from './prepare/PrepareBase.mjs';\nexport { PrepareQueue } from './prepare/PrepareQueue.mjs';\nexport { PrepareSystem } from './prepare/PrepareSystem.mjs';\nexport { PrepareUpload } from './prepare/PrepareUpload.mjs';\nexport { GlBatchAdaptor } from './rendering/batcher/gl/GlBatchAdaptor.mjs';\nexport { checkMaxIfStatementsInShader } from './rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs';\nexport { getMaxTexturesPerBatch } from './rendering/batcher/gl/utils/maxRecommendedTextures.mjs';\nexport { generateGPULayout } from './rendering/batcher/gpu/generateGPULayout.mjs';\nexport { generateLayout } from './rendering/batcher/gpu/generateLayout.mjs';\nexport { getTextureBatchBindGroup } from './rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nexport { GpuBatchAdaptor } from './rendering/batcher/gpu/GpuBatchAdaptor.mjs';\nexport { Batch, Batcher } from './rendering/batcher/shared/Batcher.mjs';\nexport { BatcherPipe } from './rendering/batcher/shared/BatcherPipe.mjs';\nexport { BatchGeometry } from './rendering/batcher/shared/BatchGeometry.mjs';\nexport { BatchTextureArray } from './rendering/batcher/shared/BatchTextureArray.mjs';\nexport { DefaultBatcher } from './rendering/batcher/shared/DefaultBatcher.mjs';\nexport { DefaultShader } from './rendering/batcher/shared/DefaultShader.mjs';\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram } from './rendering/high-shader/compileHighShaderToProgram.mjs';\nexport { compileHighShader, compileHighShaderGl } from './rendering/high-shader/compiler/compileHighShader.mjs';\nexport { addBits } from './rendering/high-shader/compiler/utils/addBits.mjs';\nexport { compileHooks, findHooksRx } from './rendering/high-shader/compiler/utils/compileHooks.mjs';\nexport { compileInputs } from './rendering/high-shader/compiler/utils/compileInputs.mjs';\nexport { compileOutputs } from './rendering/high-shader/compiler/utils/compileOutputs.mjs';\nexport { formatShader } from './rendering/high-shader/compiler/utils/formatShader.mjs';\nexport { injectBits } from './rendering/high-shader/compiler/utils/injectBits.mjs';\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate } from './rendering/high-shader/defaultProgramTemplate.mjs';\nexport { colorBit, colorBitGl } from './rendering/high-shader/shader-bits/colorBit.mjs';\nexport { generateTextureBatchBit, generateTextureBatchBitGl } from './rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl } from './rendering/high-shader/shader-bits/globalUniformsBit.mjs';\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 } from './rendering/high-shader/shader-bits/localUniformBit.mjs';\nexport { roundPixelsBit, roundPixelsBitGl } from './rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nexport { textureBit, textureBitGl } from './rendering/high-shader/shader-bits/textureBit.mjs';\nexport { AlphaMask } from './rendering/mask/alpha/AlphaMask.mjs';\nexport { AlphaMaskPipe } from './rendering/mask/alpha/AlphaMaskPipe.mjs';\nexport { ColorMask } from './rendering/mask/color/ColorMask.mjs';\nexport { ColorMaskPipe } from './rendering/mask/color/ColorMaskPipe.mjs';\nexport { MaskEffectManager, MaskEffectManagerClass } from './rendering/mask/MaskEffectManager.mjs';\nexport { ScissorMask } from './rendering/mask/scissor/ScissorMask.mjs';\nexport { StencilMask } from './rendering/mask/stencil/StencilMask.mjs';\nexport { StencilMaskPipe } from './rendering/mask/stencil/StencilMaskPipe.mjs';\nexport { addMaskBounds } from './rendering/mask/utils/addMaskBounds.mjs';\nexport { addMaskLocalBounds, getMatrixRelativeToParent } from './rendering/mask/utils/addMaskLocalBounds.mjs';\nexport { autoDetectRenderer } from './rendering/renderers/autoDetectRenderer.mjs';\nexport { BUFFER_TYPE } from './rendering/renderers/gl/buffer/const.mjs';\nexport { GlBuffer } from './rendering/renderers/gl/buffer/GlBuffer.mjs';\nexport { GlBufferSystem } from './rendering/renderers/gl/buffer/GlBufferSystem.mjs';\nexport { CLEAR } from './rendering/renderers/gl/const.mjs';\nexport { GlContextSystem } from './rendering/renderers/gl/context/GlContextSystem.mjs';\nexport { GlGeometrySystem } from './rendering/renderers/gl/geometry/GlGeometrySystem.mjs';\nexport { getGlTypeFromFormat } from './rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs';\nexport { GlBackBufferSystem } from './rendering/renderers/gl/GlBackBufferSystem.mjs';\nexport { GlColorMaskSystem } from './rendering/renderers/gl/GlColorMaskSystem.mjs';\nexport { GlEncoderSystem } from './rendering/renderers/gl/GlEncoderSystem.mjs';\nexport { GlRenderTarget } from './rendering/renderers/gl/GlRenderTarget.mjs';\nexport { GlStencilSystem } from './rendering/renderers/gl/GlStencilSystem.mjs';\nexport { GlUboSystem } from './rendering/renderers/gl/GlUboSystem.mjs';\nexport { GlRenderTargetAdaptor } from './rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs';\nexport { GlRenderTargetSystem } from './rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs';\nexport { generateShaderSyncCode } from './rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs';\nexport { getBatchSamplersUniformGroup } from './rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nexport { GlProgram } from './rendering/renderers/gl/shader/GlProgram.mjs';\nexport { GlProgramData, IGLUniformData } from './rendering/renderers/gl/shader/GlProgramData.mjs';\nexport { GlShaderSystem } from './rendering/renderers/gl/shader/GlShaderSystem.mjs';\nexport { GlUniformGroupSystem } from './rendering/renderers/gl/shader/GlUniformGroupSystem.mjs';\nexport { migrateFragmentFromV7toV8 } from './rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs';\nexport { compileShader } from './rendering/renderers/gl/shader/program/compileShader.mjs';\nexport { defaultValue } from './rendering/renderers/gl/shader/program/defaultValue.mjs';\nexport { ensureAttributes } from './rendering/renderers/gl/shader/program/ensureAttributes.mjs';\nexport { extractAttributesFromGlProgram } from './rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs';\nexport { generateProgram } from './rendering/renderers/gl/shader/program/generateProgram.mjs';\nexport { getMaxFragmentPrecision } from './rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs';\nexport { getTestContext } from './rendering/renderers/gl/shader/program/getTestContext.mjs';\nexport { getUboData } from './rendering/renderers/gl/shader/program/getUboData.mjs';\nexport { getUniformData } from './rendering/renderers/gl/shader/program/getUniformData.mjs';\nexport { logProgramError } from './rendering/renderers/gl/shader/program/logProgramError.mjs';\nexport { mapSize } from './rendering/renderers/gl/shader/program/mapSize.mjs';\nexport { mapGlToVertexFormat, mapType } from './rendering/renderers/gl/shader/program/mapType.mjs';\nexport { addProgramDefines } from './rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs';\nexport { ensurePrecision } from './rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs';\nexport { insertVersion } from './rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs';\nexport { setProgramName } from './rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs';\nexport { stripVersion } from './rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs';\nexport { WGSL_TO_STD40_SIZE, createUboElementsSTD40 } from './rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs';\nexport { createUboSyncFunctionSTD40 } from './rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs';\nexport { generateArraySyncSTD40 } from './rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs';\nexport { generateUniformsSync } from './rendering/renderers/gl/shader/utils/generateUniformsSync.mjs';\nexport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs';\nexport { GlStateSystem } from './rendering/renderers/gl/state/GlStateSystem.mjs';\nexport { mapWebGLBlendModesToPixi } from './rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs';\nexport { GL_FORMATS, GL_TARGETS, GL_TYPES, GL_WRAP_MODES } from './rendering/renderers/gl/texture/const.mjs';\nexport { GlTexture } from './rendering/renderers/gl/texture/GlTexture.mjs';\nexport { GlTextureSystem } from './rendering/renderers/gl/texture/GlTextureSystem.mjs';\nexport { glUploadBufferImageResource } from './rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs';\nexport { glUploadCompressedTextureResource } from './rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs';\nexport { glUploadImageResource } from './rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs';\nexport { glUploadVideoResource } from './rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs';\nexport { applyStyleParams } from './rendering/renderers/gl/texture/utils/applyStyleParams.mjs';\nexport { getSupportedGlCompressedTextureFormats } from './rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs';\nexport { mapFormatToGlFormat } from './rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs';\nexport { mapFormatToGlInternalFormat } from './rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs';\nexport { mapFormatToGlType } from './rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs';\nexport { compareModeToGlCompare, mipmapScaleModeToGlFilter, scaleModeToGlFilter, wrapModeToGlAddress } from './rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs';\nexport { unpremultiplyAlpha } from './rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs';\nexport { WebGLRenderer } from './rendering/renderers/gl/WebGLRenderer.mjs';\nexport { BindGroupSystem } from './rendering/renderers/gpu/BindGroupSystem.mjs';\nexport { GpuBufferSystem } from './rendering/renderers/gpu/buffer/GpuBufferSystem.mjs';\nexport { GpuReadBuffer } from './rendering/renderers/gpu/buffer/GpuReadBuffer.mjs';\nexport { UboBatch } from './rendering/renderers/gpu/buffer/UboBatch.mjs';\nexport { GpuColorMaskSystem } from './rendering/renderers/gpu/GpuColorMaskSystem.mjs';\nexport { GpuDeviceSystem } from './rendering/renderers/gpu/GpuDeviceSystem.mjs';\nexport { GpuEncoderSystem } from './rendering/renderers/gpu/GpuEncoderSystem.mjs';\nexport { GpuStencilSystem } from './rendering/renderers/gpu/GpuStencilSystem.mjs';\nexport { GpuUboSystem } from './rendering/renderers/gpu/GpuUboSystem.mjs';\nexport { GpuUniformBatchPipe } from './rendering/renderers/gpu/GpuUniformBatchPipe.mjs';\nexport { PipelineSystem } from './rendering/renderers/gpu/pipeline/PipelineSystem.mjs';\nexport { calculateProjection } from './rendering/renderers/gpu/renderTarget/calculateProjection.mjs';\nexport { GpuRenderTarget } from './rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs';\nexport { GpuRenderTargetAdaptor } from './rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs';\nexport { GpuRenderTargetSystem } from './rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs';\nexport { BindGroup } from './rendering/renderers/gpu/shader/BindGroup.mjs';\nexport { GpuProgram } from './rendering/renderers/gpu/shader/GpuProgram.mjs';\nexport { GpuShaderSystem } from './rendering/renderers/gpu/shader/GpuShaderSystem.mjs';\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL } from './rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs';\nexport { createUboSyncFunctionWGSL } from './rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs';\nexport { extractAttributesFromGpuProgram } from './rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs';\nexport { extractStructAndGroups } from './rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs';\nexport { generateArraySyncWGSL } from './rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs';\nexport { generateGpuLayoutGroups } from './rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs';\nexport { generateLayoutHash } from './rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs';\nexport { removeStructAndGroupDuplicates } from './rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs';\nexport { GpuBlendModesToPixi } from './rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs';\nexport { GpuStateSystem } from './rendering/renderers/gpu/state/GpuStateSystem.mjs';\nexport { GpuStencilModesToPixi } from './rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs';\nexport { GpuTextureSystem } from './rendering/renderers/gpu/texture/GpuTextureSystem.mjs';\nexport { gpuUploadBufferImageResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs';\nexport { blockDataMap, gpuUploadCompressedTextureResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs';\nexport { gpuUploadImageResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs';\nexport { gpuUploadVideoResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs';\nexport { getSupportedGPUCompressedTextureFormats } from './rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs';\nexport { GpuMipmapGenerator } from './rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs';\nexport { WebGPURenderer } from './rendering/renderers/gpu/WebGPURenderer.mjs';\nexport { BackgroundSystem } from './rendering/renderers/shared/background/BackgroundSystem.mjs';\nexport { BlendModePipe } from './rendering/renderers/shared/blendModes/BlendModePipe.mjs';\nexport { Buffer } from './rendering/renderers/shared/buffer/Buffer.mjs';\nexport { BufferResource } from './rendering/renderers/shared/buffer/BufferResource.mjs';\nexport { BufferUsage } from './rendering/renderers/shared/buffer/const.mjs';\nexport { fastCopy } from './rendering/renderers/shared/buffer/utils/fastCopy.mjs';\nexport { ExtractSystem } from './rendering/renderers/shared/extract/ExtractSystem.mjs';\nexport { GenerateTextureSystem } from './rendering/renderers/shared/extract/GenerateTextureSystem.mjs';\nexport { DRAW_MODES } from './rendering/renderers/shared/geometry/const.mjs';\nexport { Geometry } from './rendering/renderers/shared/geometry/Geometry.mjs';\nexport { buildSimpleUvs, buildUvs } from './rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nexport { ensureIsBuffer } from './rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs';\nexport { getAttributeInfoFromFormat } from './rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nexport { getGeometryBounds } from './rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs';\nexport { transformVertices } from './rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nexport { InstructionSet } from './rendering/renderers/shared/instructions/InstructionSet.mjs';\nexport { GlobalUniformSystem } from './rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs';\nexport { isRenderingToScreen } from './rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs';\nexport { RenderTarget } from './rendering/renderers/shared/renderTarget/RenderTarget.mjs';\nexport { RenderTargetSystem } from './rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs';\nexport { viewportFromFrame } from './rendering/renderers/shared/renderTarget/viewportFromFrame.mjs';\nexport { SchedulerSystem } from './rendering/renderers/shared/SchedulerSystem.mjs';\nexport { ShaderStage } from './rendering/renderers/shared/shader/const.mjs';\nexport { Shader } from './rendering/renderers/shared/shader/Shader.mjs';\nexport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES } from './rendering/renderers/shared/shader/types.mjs';\nexport { UboSystem } from './rendering/renderers/shared/shader/UboSystem.mjs';\nexport { UniformGroup } from './rendering/renderers/shared/shader/UniformGroup.mjs';\nexport { createUboSyncFunction } from './rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs';\nexport { getDefaultUniformValue } from './rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs';\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL } from './rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs';\nexport { uniformParsers } from './rendering/renderers/shared/shader/utils/uniformParsers.mjs';\nexport { HelloSystem } from './rendering/renderers/shared/startup/HelloSystem.mjs';\nexport { BLEND_TO_NPM, STENCIL_MODES } from './rendering/renderers/shared/state/const.mjs';\nexport { getAdjustedBlendModeBlend } from './rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nexport { State } from './rendering/renderers/shared/state/State.mjs';\nexport { AbstractRenderer } from './rendering/renderers/shared/system/AbstractRenderer.mjs';\nexport { SharedRenderPipes, SharedSystems } from './rendering/renderers/shared/system/SharedSystems.mjs';\nexport { SystemRunner } from './rendering/renderers/shared/system/SystemRunner.mjs';\nexport { CanvasPool, CanvasPoolClass } from './rendering/renderers/shared/texture/CanvasPool.mjs';\nexport { DEPRECATED_SCALE_MODES, DEPRECATED_WRAP_MODES, MSAA_QUALITY, SCALE_MODES, WRAP_MODES } from './rendering/renderers/shared/texture/const.mjs';\nexport { RenderableGCSystem } from './rendering/renderers/shared/texture/RenderableGCSystem.mjs';\nexport { RenderTexture } from './rendering/renderers/shared/texture/RenderTexture.mjs';\nexport { BufferImageSource } from './rendering/renderers/shared/texture/sources/BufferImageSource.mjs';\nexport { CanvasSource } from './rendering/renderers/shared/texture/sources/CanvasSource.mjs';\nexport { CompressedSource } from './rendering/renderers/shared/texture/sources/CompressedSource.mjs';\nexport { ImageSource } from './rendering/renderers/shared/texture/sources/ImageSource.mjs';\nexport { TextureSource } from './rendering/renderers/shared/texture/sources/TextureSource.mjs';\nexport { VideoSource } from './rendering/renderers/shared/texture/sources/VideoSource.mjs';\nexport { Texture } from './rendering/renderers/shared/texture/Texture.mjs';\nexport { TextureGCSystem } from './rendering/renderers/shared/texture/TextureGCSystem.mjs';\nexport { TextureMatrix } from './rendering/renderers/shared/texture/TextureMatrix.mjs';\nexport { TexturePool, TexturePoolClass } from './rendering/renderers/shared/texture/TexturePool.mjs';\nexport { TextureStyle } from './rendering/renderers/shared/texture/TextureStyle.mjs';\nexport { TextureUvs } from './rendering/renderers/shared/texture/TextureUvs.mjs';\nexport { generateUID } from './rendering/renderers/shared/texture/utils/generateUID.mjs';\nexport { getCanvasTexture, hasCachedCanvasTexture } from './rendering/renderers/shared/texture/utils/getCanvasTexture.mjs';\nexport { getSupportedCompressedTextureFormats } from './rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs';\nexport { getSupportedTextureFormats, nonCompressedFormats } from './rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs';\nexport { autoDetectSource, resourceToTexture, textureFrom } from './rendering/renderers/shared/texture/utils/textureFrom.mjs';\nexport { createIdFromString } from './rendering/renderers/shared/utils/createIdFromString.mjs';\nexport { parseFunctionBody } from './rendering/renderers/shared/utils/parseFunctionBody.mjs';\nexport { ViewSystem } from './rendering/renderers/shared/view/ViewSystem.mjs';\nexport { RendererType } from './rendering/renderers/types.mjs';\nexport { default as particlesFrag } from './scene/particle-container/shared/shader/particles.frag.mjs';\nexport { default as particlesVert } from './scene/particle-container/shared/shader/particles.vert.mjs';\nexport { default as particlesWgsl } from './scene/particle-container/shared/shader/particles.wgsl.mjs';\nexport { Bounds } from './scene/container/bounds/Bounds.mjs';\nexport { getFastGlobalBounds } from './scene/container/bounds/getFastGlobalBounds.mjs';\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards } from './scene/container/bounds/getGlobalBounds.mjs';\nexport { getLocalBounds, getParent } from './scene/container/bounds/getLocalBounds.mjs';\nexport { getGlobalRenderableBounds } from './scene/container/bounds/getRenderableBounds.mjs';\nexport { boundsPool, matrixPool } from './scene/container/bounds/utils/matrixAndBoundsPool.mjs';\nexport { cacheAsTextureMixin } from './scene/container/container-mixins/cacheAsTextureMixin.mjs';\nexport { childrenHelperMixin } from './scene/container/container-mixins/childrenHelperMixin.mjs';\nexport { collectRenderablesMixin } from './scene/container/container-mixins/collectRenderablesMixin.mjs';\nexport { effectsMixin } from './scene/container/container-mixins/effectsMixin.mjs';\nexport { findMixin } from './scene/container/container-mixins/findMixin.mjs';\nexport { getFastGlobalBoundsMixin } from './scene/container/container-mixins/getFastGlobalBoundsMixin.mjs';\nexport { bgr2rgb, getGlobalMixin } from './scene/container/container-mixins/getGlobalMixin.mjs';\nexport { measureMixin } from './scene/container/container-mixins/measureMixin.mjs';\nexport { onRenderMixin } from './scene/container/container-mixins/onRenderMixin.mjs';\nexport { sortMixin } from './scene/container/container-mixins/sortMixin.mjs';\nexport { toLocalGlobalMixin } from './scene/container/container-mixins/toLocalGlobalMixin.mjs';\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE } from './scene/container/Container.mjs';\nexport { CustomRenderPipe } from './scene/container/CustomRenderPipe.mjs';\nexport { RenderContainer } from './scene/container/RenderContainer.mjs';\nexport { RenderGroup } from './scene/container/RenderGroup.mjs';\nexport { RenderGroupPipe } from './scene/container/RenderGroupPipe.mjs';\nexport { RenderGroupSystem } from './scene/container/RenderGroupSystem.mjs';\nexport { assignWithIgnore } from './scene/container/utils/assignWithIgnore.mjs';\nexport { checkChildrenDidChange } from './scene/container/utils/checkChildrenDidChange.mjs';\nexport { clearList } from './scene/container/utils/clearList.mjs';\nexport { collectAllRenderables } from './scene/container/utils/collectAllRenderables.mjs';\nexport { definedProps } from './scene/container/utils/definedProps.mjs';\nexport { executeInstructions } from './scene/container/utils/executeInstructions.mjs';\nexport { mixHexColors } from './scene/container/utils/mixHexColors.mjs';\nexport { multiplyColors } from './scene/container/utils/multiplyColors.mjs';\nexport { multiplyHexColors } from './scene/container/utils/multiplyHexColors.mjs';\nexport { updateLocalTransform } from './scene/container/utils/updateLocalTransform.mjs';\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren } from './scene/container/utils/updateRenderGroupTransforms.mjs';\nexport { updateWorldTransform } from './scene/container/utils/updateWorldTransform.mjs';\nexport { validateRenderables } from './scene/container/utils/validateRenderables.mjs';\nexport { GlGraphicsAdaptor } from './scene/graphics/gl/GlGraphicsAdaptor.mjs';\nexport { color32BitToUniform, colorToUniform } from './scene/graphics/gpu/colorToUniform.mjs';\nexport { GpuGraphicsAdaptor } from './scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nexport { BatchableGraphics } from './scene/graphics/shared/BatchableGraphics.mjs';\nexport { buildAdaptiveBezier } from './scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs';\nexport { buildAdaptiveQuadratic } from './scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs';\nexport { buildArc } from './scene/graphics/shared/buildCommands/buildArc.mjs';\nexport { buildArcTo } from './scene/graphics/shared/buildCommands/buildArcTo.mjs';\nexport { buildArcToSvg } from './scene/graphics/shared/buildCommands/buildArcToSvg.mjs';\nexport { buildCircle, buildEllipse, buildRoundedRectangle } from './scene/graphics/shared/buildCommands/buildCircle.mjs';\nexport { buildLine } from './scene/graphics/shared/buildCommands/buildLine.mjs';\nexport { buildPixelLine } from './scene/graphics/shared/buildCommands/buildPixelLine.mjs';\nexport { buildPolygon } from './scene/graphics/shared/buildCommands/buildPolygon.mjs';\nexport { buildRectangle } from './scene/graphics/shared/buildCommands/buildRectangle.mjs';\nexport { buildTriangle } from './scene/graphics/shared/buildCommands/buildTriangle.mjs';\nexport { closePointEps, curveEps } from './scene/graphics/shared/const.mjs';\nexport { FillGradient } from './scene/graphics/shared/fill/FillGradient.mjs';\nexport { FillPattern } from './scene/graphics/shared/fill/FillPattern.mjs';\nexport { Graphics } from './scene/graphics/shared/Graphics.mjs';\nexport { GraphicsContext } from './scene/graphics/shared/GraphicsContext.mjs';\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem } from './scene/graphics/shared/GraphicsContextSystem.mjs';\nexport { GraphicsPipe } from './scene/graphics/shared/GraphicsPipe.mjs';\nexport { GraphicsPath } from './scene/graphics/shared/path/GraphicsPath.mjs';\nexport { roundedShapeArc, roundedShapeQuadraticCurve } from './scene/graphics/shared/path/roundShape.mjs';\nexport { ShapePath } from './scene/graphics/shared/path/ShapePath.mjs';\nexport { SVGParser } from './scene/graphics/shared/svg/SVGParser.mjs';\nexport { SVGToGraphicsPath } from './scene/graphics/shared/svg/SVGToGraphicsPath.mjs';\nexport { buildContextBatches, shapeBuilders } from './scene/graphics/shared/utils/buildContextBatches.mjs';\nexport { buildGeometryFromPath } from './scene/graphics/shared/utils/buildGeometryFromPath.mjs';\nexport { toFillStyle, toStrokeStyle } from './scene/graphics/shared/utils/convertFillInputToFillStyle.mjs';\nexport { getOrientationOfPoints } from './scene/graphics/shared/utils/getOrientationOfPoints.mjs';\nexport { triangulateWithHoles } from './scene/graphics/shared/utils/triangulateWithHoles.mjs';\nexport { RenderLayer, RenderLayerClass } from './scene/layers/RenderLayer.mjs';\nexport { PerspectiveMesh } from './scene/mesh-perspective/PerspectiveMesh.mjs';\nexport { PerspectivePlaneGeometry } from './scene/mesh-perspective/PerspectivePlaneGeometry.mjs';\nexport { applyProjectiveTransformationToPlane } from './scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs';\nexport { compute2DProjection } from './scene/mesh-perspective/utils/compute2DProjections.mjs';\nexport { MeshPlane } from './scene/mesh-plane/MeshPlane.mjs';\nexport { PlaneGeometry } from './scene/mesh-plane/PlaneGeometry.mjs';\nexport { MeshRope } from './scene/mesh-simple/MeshRope.mjs';\nexport { MeshSimple } from './scene/mesh-simple/MeshSimple.mjs';\nexport { RopeGeometry } from './scene/mesh-simple/RopeGeometry.mjs';\nexport { GlMeshAdaptor } from './scene/mesh/gl/GlMeshAdaptor.mjs';\nexport { GpuMeshAdapter } from './scene/mesh/gpu/GpuMeshAdapter.mjs';\nexport { BatchableMesh } from './scene/mesh/shared/BatchableMesh.mjs';\nexport { getTextureDefaultMatrix } from './scene/mesh/shared/getTextureDefaultMatrix.mjs';\nexport { Mesh } from './scene/mesh/shared/Mesh.mjs';\nexport { MeshGeometry } from './scene/mesh/shared/MeshGeometry.mjs';\nexport { MeshPipe } from './scene/mesh/shared/MeshPipe.mjs';\nexport { GlParticleContainerAdaptor } from './scene/particle-container/gl/GlParticleContainerAdaptor.mjs';\nexport { GpuParticleContainerAdaptor } from './scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs';\nexport { GlParticleContainerPipe } from './scene/particle-container/shared/GlParticleContainerPipe.mjs';\nexport { GpuParticleContainerPipe } from './scene/particle-container/shared/GpuParticleContainerPipe.mjs';\nexport { Particle } from './scene/particle-container/shared/Particle.mjs';\nexport { ParticleBuffer } from './scene/particle-container/shared/ParticleBuffer.mjs';\nexport { ParticleContainer } from './scene/particle-container/shared/ParticleContainer.mjs';\nexport { ParticleContainerPipe } from './scene/particle-container/shared/ParticleContainerPipe.mjs';\nexport { particleData } from './scene/particle-container/shared/particleData.mjs';\nexport { ParticleShader } from './scene/particle-container/shared/shader/ParticleShader.mjs';\nexport { createIndicesForQuads } from './scene/particle-container/shared/utils/createIndicesForQuads.mjs';\nexport { generateParticleUpdateFunction } from './scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs';\nexport { AnimatedSprite } from './scene/sprite-animated/AnimatedSprite.mjs';\nexport { NineSliceGeometry } from './scene/sprite-nine-slice/NineSliceGeometry.mjs';\nexport { NineSlicePlane, NineSliceSprite } from './scene/sprite-nine-slice/NineSliceSprite.mjs';\nexport { NineSliceSpritePipe } from './scene/sprite-nine-slice/NineSliceSpritePipe.mjs';\nexport { tilingBit, tilingBitGl } from './scene/sprite-tiling/shader/tilingBit.mjs';\nexport { TilingSpriteShader } from './scene/sprite-tiling/shader/TilingSpriteShader.mjs';\nexport { TilingSprite } from './scene/sprite-tiling/TilingSprite.mjs';\nexport { TilingSpritePipe } from './scene/sprite-tiling/TilingSpritePipe.mjs';\nexport { applyMatrix } from './scene/sprite-tiling/utils/applyMatrix.mjs';\nexport { QuadGeometry } from './scene/sprite-tiling/utils/QuadGeometry.mjs';\nexport { setPositions } from './scene/sprite-tiling/utils/setPositions.mjs';\nexport { setUvs } from './scene/sprite-tiling/utils/setUvs.mjs';\nexport { BatchableSprite } from './scene/sprite/BatchableSprite.mjs';\nexport { Sprite } from './scene/sprite/Sprite.mjs';\nexport { SpritePipe } from './scene/sprite/SpritePipe.mjs';\nexport { AbstractBitmapFont } from './scene/text-bitmap/AbstractBitmapFont.mjs';\nexport { bitmapFontTextParser } from './scene/text-bitmap/asset/bitmapFontTextParser.mjs';\nexport { bitmapFontXMLParser } from './scene/text-bitmap/asset/bitmapFontXMLParser.mjs';\nexport { bitmapFontXMLStringParser } from './scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs';\nexport { bitmapFontCachePlugin, loadBitmapFont } from './scene/text-bitmap/asset/loadBitmapFont.mjs';\nexport { BitmapFont } from './scene/text-bitmap/BitmapFont.mjs';\nexport { BitmapFontManager } from './scene/text-bitmap/BitmapFontManager.mjs';\nexport { BitmapText } from './scene/text-bitmap/BitmapText.mjs';\nexport { BitmapTextPipe } from './scene/text-bitmap/BitmapTextPipe.mjs';\nexport { DynamicBitmapFont } from './scene/text-bitmap/DynamicBitmapFont.mjs';\nexport { getBitmapTextLayout } from './scene/text-bitmap/utils/getBitmapTextLayout.mjs';\nexport { resolveCharacters } from './scene/text-bitmap/utils/resolveCharacters.mjs';\nexport { HTMLText } from './scene/text-html/HTMLText.mjs';\nexport { HTMLTextPipe } from './scene/text-html/HTMLTextPipe.mjs';\nexport { HTMLTextRenderData, nssvg, nsxhtml } from './scene/text-html/HTMLTextRenderData.mjs';\nexport { HTMLTextStyle } from './scene/text-html/HTMLTextStyle.mjs';\nexport { HTMLTextSystem } from './scene/text-html/HTMLTextSystem.mjs';\nexport { extractFontFamilies } from './scene/text-html/utils/extractFontFamilies.mjs';\nexport { FontStylePromiseCache, getFontCss } from './scene/text-html/utils/getFontCss.mjs';\nexport { getSVGUrl } from './scene/text-html/utils/getSVGUrl.mjs';\nexport { getTemporaryCanvasFromImage } from './scene/text-html/utils/getTemporaryCanvasFromImage.mjs';\nexport { loadFontAsBase64 } from './scene/text-html/utils/loadFontAsBase64.mjs';\nexport { loadFontCSS } from './scene/text-html/utils/loadFontCSS.mjs';\nexport { loadSVGImage } from './scene/text-html/utils/loadSVGImage.mjs';\nexport { measureHtmlText } from './scene/text-html/utils/measureHtmlText.mjs';\nexport { textStyleToCSS } from './scene/text-html/utils/textStyleToCSS.mjs';\nexport { AbstractText, ensureOptions } from './scene/text/AbstractText.mjs';\nexport { CanvasTextMetrics } from './scene/text/canvas/CanvasTextMetrics.mjs';\nexport { CanvasTextPipe } from './scene/text/canvas/CanvasTextPipe.mjs';\nexport { CanvasTextSystem } from './scene/text/canvas/CanvasTextSystem.mjs';\nexport { fontStringFromTextStyle } from './scene/text/canvas/utils/fontStringFromTextStyle.mjs';\nexport { getCanvasFillStyle } from './scene/text/canvas/utils/getCanvasFillStyle.mjs';\nexport { SdfShader } from './scene/text/sdfShader/SdfShader.mjs';\nexport { localUniformMSDFBit, localUniformMSDFBitGl } from './scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs';\nexport { mSDFBit, mSDFBitGl } from './scene/text/sdfShader/shader-bits/mSDFBit.mjs';\nexport { Text } from './scene/text/Text.mjs';\nexport { TextStyle } from './scene/text/TextStyle.mjs';\nexport { ensureTextStyle } from './scene/text/utils/ensureTextStyle.mjs';\nexport { generateTextStyleKey } from './scene/text/utils/generateTextStyleKey.mjs';\nexport { getPo2TextureFromSource } from './scene/text/utils/getPo2TextureFromSource.mjs';\nexport { updateTextBounds } from './scene/text/utils/updateTextBounds.mjs';\nexport { ViewContainer } from './scene/view/ViewContainer.mjs';\nexport { Spritesheet } from './spritesheet/Spritesheet.mjs';\nexport { spritesheetAsset } from './spritesheet/spritesheetAsset.mjs';\nexport { UPDATE_PRIORITY } from './ticker/const.mjs';\nexport { Ticker } from './ticker/Ticker.mjs';\nexport { TickerListener } from './ticker/TickerListener.mjs';\nexport { detectVideoAlphaMode } from './utils/browser/detectVideoAlphaMode.mjs';\nexport { isMobile } from './utils/browser/isMobile.mjs';\nexport { isSafari } from './utils/browser/isSafari.mjs';\nexport { isWebGLSupported } from './utils/browser/isWebGLSupported.mjs';\nexport { isWebGPUSupported } from './utils/browser/isWebGPUSupported.mjs';\nexport { unsafeEvalSupported } from './utils/browser/unsafeEvalSupported.mjs';\nexport { getCanvasBoundingBox } from './utils/canvas/getCanvasBoundingBox.mjs';\nexport { DATA_URI, VERSION } from './utils/const.mjs';\nexport { default as EventEmitter } from 'eventemitter3';\nexport { cleanArray, cleanHash } from './utils/data/clean.mjs';\nexport { removeItems } from './utils/data/removeItems.mjs';\nexport { resetUids, uid } from './utils/data/uid.mjs';\nexport { updateQuadBounds } from './utils/data/updateQuadBounds.mjs';\nexport { ViewableBuffer } from './utils/data/ViewableBuffer.mjs';\nexport { ApplicationInitHook, RendererInitHook } from './utils/global/globalHooks.mjs';\nexport { deprecation, v8_0_0, v8_3_4 } from './utils/logging/deprecation.mjs';\nexport { logDebugTexture } from './utils/logging/logDebugTexture.mjs';\nexport { logRenderGroupScene, logScene } from './utils/logging/logScene.mjs';\nexport { warn } from './utils/logging/warn.mjs';\nexport { NOOP } from './utils/misc/NOOP.mjs';\nexport { Transform } from './utils/misc/Transform.mjs';\nexport { getResolutionOfUrl } from './utils/network/getResolutionOfUrl.mjs';\nexport { path } from './utils/path.mjs';\nexport { Pool } from './utils/pool/Pool.mjs';\nexport { BigPool, PoolGroupClass } from './utils/pool/PoolGroup.mjs';\nexport { sayHello } from './utils/sayHello.mjs';\nexport { default as earcut } from 'earcut';\n\n\"use strict\";\nextensions.add(browserExt, webworkerExt);\n\nexport { browserExt, extensions, webworkerExt };\n//# sourceMappingURL=index.mjs.map\n","import { browserExt } from './environment-browser/browserExt';\nimport { webworkerExt } from './environment-webworker/webworkerExt';\nimport { extensions } from './extensions/Extensions';\nimport './rendering/init';\nimport './spritesheet/init';\n\nexport * from './accessibility';\nexport * from './advanced-blend-modes';\nexport * from './app';\nexport * from './assets';\nexport * from './color';\nexport * from './compressed-textures';\nexport * from './culling';\nexport * from './environment';\nexport * from './environment-browser';\nexport * from './environment-webworker';\nexport * from './events';\nexport * from './extensions';\nexport * from './filters';\nexport * from './maths';\nexport * from './prepare';\nexport * from './rendering';\nexport * from './scene';\nexport * from './spritesheet';\nexport * from './ticker';\nexport * from './utils';\n\nextensions.add(browserExt, webworkerExt);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst browserExt = {\n  extension: {\n    type: ExtensionType.Environment,\n    name: \"browser\",\n    priority: -1\n  },\n  test: () => true,\n  load: async () => {\n    await import('./browserAll.mjs');\n  }\n};\n\nexport { browserExt };\n//# sourceMappingURL=browserExt.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the browser environment.\n * @memberof environment\n */\nexport const browserExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'browser',\n        priority: -1,\n    },\n    test: () => true,\n    load: async () =>\n    {\n        await import('./browserAll');\n    },\n};\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst webworkerExt = {\n  extension: {\n    type: ExtensionType.Environment,\n    name: \"webworker\",\n    priority: 0\n  },\n  test: () => typeof self !== \"undefined\" && self.WorkerGlobalScope !== void 0,\n  load: async () => {\n    await import('./webworkerAll.mjs');\n  }\n};\n\nexport { webworkerExt };\n//# sourceMappingURL=webworkerExt.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the webworker environment.\n * @memberof environment\n */\nexport const webworkerExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'webworker',\n        priority: 0,\n    },\n    test: () => typeof self !== 'undefined' && self.WorkerGlobalScope !== undefined,\n    load: async () =>\n    {\n        await import('./webworkerAll');\n    },\n};\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer.mjs';\nimport { Container } from '../scene/container/Container.mjs';\nimport { ApplicationInitHook } from '../utils/global/globalHooks.mjs';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _Application = class _Application {\n  /** @ignore */\n  constructor(...args) {\n    /** The root display container that's rendered. */\n    this.stage = new Container();\n    if (args[0] !== void 0) {\n      deprecation(v8_0_0, \"Application constructor options are deprecated, please use Application.init() instead.\");\n    }\n  }\n  /**\n   * @param options - The optional application and renderer parameters.\n   */\n  async init(options) {\n    options = { ...options };\n    this.renderer = await autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /** Render the current stage. */\n  render() {\n    this.renderer.render({ container: this.stage });\n  }\n  /**\n   * Reference to the renderer's canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */\n  get canvas() {\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */\n  get view() {\n    deprecation(v8_0_0, \"Application.view is deprecated, please use Application.canvas instead.\");\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */\n  get screen() {\n    return this.renderer.screen;\n  }\n  /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */\n  destroy(rendererDestroyOptions = false, options = false) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(options);\n    this.stage = null;\n    this.renderer.destroy(rendererDestroyOptions);\n    this.renderer = null;\n  }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */\n_Application._plugins = [];\nlet Application = _Application;\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ApplicationInitHook);\n\nexport { Application };\n//# sourceMappingURL=Application.mjs.map\n","import { extensions, ExtensionType } from '../extensions/Extensions';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer';\nimport { Container } from '../scene/container/Container';\nimport { ApplicationInitHook } from '../utils/global/globalHooks';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { AutoDetectOptions } from '../rendering/renderers/autoDetectRenderer';\nimport type { RendererDestroyOptions } from '../rendering/renderers/shared/system/AbstractRenderer';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { DestroyOptions } from '../scene/container/destroyTypes';\n\n/**\n * The app module provides a set of classes to use as a starting point when building applications.\n *\n * <aside>This module has a mixin for <code>TickerPlugin</code> and <code>ResizePlugin</code>.\n * These will need to be imported if you are managing your own renderer.</aside>\n *\n * ```js\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init();\n *\n * // don't forget to add the canvas to the DOM\n * document.body.appendChild(app.canvas);\n * ```\n * @namespace app\n */\n\n/**\n * Any plugin that's usable for Application should contain these methods.\n * @example\n * import { ApplicationPlugin } from 'pixi.js';\n *\n * const plugin: ApplicationPlugin = {\n *    init: (options: Partial<ApplicationOptions>) =>\n *    {\n *       // handle init here, use app options if needed\n *    },\n *    destroy: () =>\n *    {\n *       // handle destruction code here\n *    }\n * }\n * @memberof app\n * @see {@link app.ApplicationOptions}\n * @ignore\n */\nexport interface ApplicationPlugin\n{\n    /**\n     * Called when Application is constructed, scoped to Application instance.\n     * Passes in `options` as the only argument, which are Application `init()` options.\n     * @param {object} options - Application options.\n     */\n    init(options: Partial<ApplicationOptions>): void;\n    /** Called when destroying Application, scoped to Application instance. */\n    destroy(): void;\n}\n\n/**\n * Application options supplied to the {@link app.Application#init} method.\n * @memberof app\n * @example\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init({\n *    autoStart: false,\n *    resizeTo: window,\n *    sharedTicker: true,\n * });\n */\nexport interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions { }\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface Application extends PixiMixins.Application { }\n\n/**\n * Convenience class to create a new PixiJS application.\n *\n * This class automatically creates the renderer, ticker and root container.\n * @example\n * import { Application, Sprite } from 'pixi.js';\n *\n * // Create the application\n * const app = new Application();\n *\n * await app.init({ width: 800, height: 600 });\n *\n * // Add the view to the DOM\n * document.body.appendChild(app.canvas);\n *\n * // ex, add display objects\n * app.stage.addChild(Sprite.from('something.png'));\n * @memberof app\n */\nexport class Application<R extends Renderer = Renderer>\n{\n    /**\n     * Collection of installed plugins.\n     * @alias _plugins\n     */\n    public static _plugins: ApplicationPlugin[] = [];\n\n    /** The root display container that's rendered. */\n    public stage: Container = new Container();\n\n    /**\n     * WebGL renderer if available, otherwise CanvasRenderer.\n     * @member {rendering.Renderer}\n     */\n    public renderer: R;\n\n    /** Create new Application instance */\n    constructor();\n\n    /** @deprecated since 8.0.0 */\n    constructor(options?: Partial<ApplicationOptions>);\n\n    /** @ignore */\n    constructor(...args: [Partial<ApplicationOptions>] | [])\n    {\n        // #if _DEBUG\n        if (args[0] !== undefined)\n        {\n            deprecation(v8_0_0, 'Application constructor options are deprecated, please use Application.init() instead.');\n        }\n        // #endif\n    }\n\n    /**\n     * @param options - The optional application and renderer parameters.\n     */\n    public async init(options?: Partial<ApplicationOptions>)\n    {\n        // The default options\n        options = { ...options };\n\n        this.renderer = await autoDetectRenderer(options as ApplicationOptions) as R;\n\n        // install plugins here\n        Application._plugins.forEach((plugin) =>\n        {\n            plugin.init.call(this, options);\n        });\n    }\n\n    /** Render the current stage. */\n    public render(): void\n    {\n        this.renderer.render({ container: this.stage });\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @readonly\n     * @member {HTMLCanvasElement}\n     */\n    get canvas(): R['canvas']\n    {\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @member {HTMLCanvasElement}\n     * @deprecated since 8.0.0\n     */\n    get view(): R['canvas']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Application.view is deprecated, please use Application.canvas instead.');\n        // #endif\n\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n     * @readonly\n     */\n    get screen(): Rectangle\n    {\n        return this.renderer.screen;\n    }\n\n    /**\n     * Destroys the application and all of its resources.\n     * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n     * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n     * @param {object|boolean} [options=false] - The options for destroying the stage.\n     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n     * called as well. `options` will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true,\n     * it should destroy the texture of the child sprite.\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     *  If options.children is set to true,\n     * it should destroy the texture source of the child sprite.\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true,\n     * it should destroy the context of the child graphics.\n     */\n    public destroy(rendererDestroyOptions: RendererDestroyOptions = false, options: DestroyOptions = false): void\n    {\n        // Destroy plugins in the opposite order\n        // which they were constructed\n        const plugins = Application._plugins.slice(0);\n\n        plugins.reverse();\n        plugins.forEach((plugin) =>\n        {\n            plugin.destroy.call(this);\n        });\n\n        this.stage.destroy(options);\n        this.stage = null;\n\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n}\n\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ApplicationInitHook);\n","import { isWebGLSupported } from '../../utils/browser/isWebGLSupported.mjs';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported.mjs';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer.mjs';\n\n\"use strict\";\nconst renderPriority = [\"webgl\", \"webgpu\", \"canvas\"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach((item) => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === \"webgpu\" && await isWebGPUSupported()) {\n      const { WebGPURenderer } = await import('./gpu/WebGPURenderer.mjs');\n      RendererClass = WebGPURenderer;\n      finalOptions = { ...options, ...options.webgpu };\n      break;\n    } else if (rendererType === \"webgl\" && isWebGLSupported(\n      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    )) {\n      const { WebGLRenderer } = await import('./gl/WebGLRenderer.mjs');\n      RendererClass = WebGLRenderer;\n      finalOptions = { ...options, ...options.webgl };\n      break;\n    } else if (rendererType === \"canvas\") {\n      finalOptions = { ...options };\n      throw new Error(\"CanvasRenderer is not yet implemented\");\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  if (!RendererClass) {\n    throw new Error(\"No available renderer for the current environment\");\n  }\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\n\nexport { autoDetectRenderer };\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n","import { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer';\n\nimport type { WebGLOptions } from './gl/WebGLRenderer';\nimport type { WebGPUOptions } from './gpu/WebGPURenderer';\nimport type { Renderer, RendererOptions } from './types';\n\n/**\n * Options for {@link rendering.autoDetectRenderer}.\n * @memberof rendering\n */\nexport interface AutoDetectOptions extends RendererOptions\n{\n    /** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n    preference?: 'webgl' | 'webgpu'// | 'canvas';\n    /** Optional WebGPUOptions to pass only to WebGPU renderer. */\n    webgpu?: Partial<WebGPUOptions>;\n    /** Optional WebGLOptions to pass only to the WebGL renderer */\n    webgl?: Partial<WebGLOptions>;\n}\n\nconst renderPriority = ['webgl', 'webgpu', 'canvas'];\n\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @memberof rendering\n */\nexport async function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>\n{\n    let preferredOrder: string[] = [];\n\n    if (options.preference)\n    {\n        preferredOrder.push(options.preference);\n\n        renderPriority.forEach((item) =>\n        {\n            if (item !== options.preference)\n            {\n                preferredOrder.push(item);\n            }\n        });\n    }\n    else\n    {\n        preferredOrder = renderPriority.slice();\n    }\n\n    let RendererClass: new () => Renderer;\n    let finalOptions: Partial<AutoDetectOptions> = {};\n\n    for (let i = 0; i < preferredOrder.length; i++)\n    {\n        const rendererType = preferredOrder[i];\n\n        if (rendererType === 'webgpu' && (await isWebGPUSupported()))\n        {\n            const { WebGPURenderer } = await import('./gpu/WebGPURenderer');\n\n            RendererClass = WebGPURenderer;\n\n            finalOptions = { ...options, ...options.webgpu };\n\n            break;\n        }\n        else if (\n            rendererType === 'webgl'\n            && isWebGLSupported(\n                options.failIfMajorPerformanceCaveat\n                    ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n            )\n        )\n        {\n            const { WebGLRenderer } = await import('./gl/WebGLRenderer');\n\n            RendererClass = WebGLRenderer;\n\n            finalOptions = { ...options, ...options.webgl };\n\n            break;\n        }\n        else if (rendererType === 'canvas')\n        {\n            finalOptions = { ...options };\n\n            throw new Error('CanvasRenderer is not yet implemented');\n        }\n    }\n\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n\n    if (!RendererClass)\n    {\n        throw new Error('No available renderer for the current environment');\n    }\n\n    const renderer = new RendererClass();\n\n    await renderer.init(finalOptions);\n\n    return renderer;\n}\n","import { DOMAdapter } from '../../environment/adapter.mjs';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer.mjs';\n\n\"use strict\";\nlet _isWebGLSupported;\nfunction isWebGLSupported(failIfMajorPerformanceCaveat) {\n  if (_isWebGLSupported !== void 0)\n    return _isWebGLSupported;\n  _isWebGLSupported = (() => {\n    const contextOptions = {\n      stencil: true,\n      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    };\n    try {\n      if (!DOMAdapter.get().getWebGLRenderingContext()) {\n        return false;\n      }\n      const canvas = DOMAdapter.get().createCanvas();\n      let gl = canvas.getContext(\"webgl\", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension(\"WEBGL_lose_context\");\n        if (loseContext) {\n          loseContext.loseContext();\n        }\n      }\n      gl = null;\n      return success;\n    } catch (_e) {\n      return false;\n    }\n  })();\n  return _isWebGLSupported;\n}\n\nexport { isWebGLSupported };\n//# sourceMappingURL=isWebGLSupported.mjs.map\n","import { DOMAdapter } from '../../environment/adapter';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer';\n\nlet _isWebGLSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGL support.\n * @param failIfMajorPerformanceCaveat - whether to fail if there is a major performance caveat, defaults to false\n * @memberof utils\n * @function isWebGLSupported\n * @returns {boolean} Is WebGL supported.\n */\nexport function isWebGLSupported(\n    failIfMajorPerformanceCaveat?: boolean\n): boolean\n{\n    if (_isWebGLSupported !== undefined) return _isWebGLSupported;\n\n    _isWebGLSupported = ((): boolean =>\n    {\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat:\n                failIfMajorPerformanceCaveat\n                ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat,\n        };\n\n        try\n        {\n            if (!DOMAdapter.get().getWebGLRenderingContext())\n            {\n                return false;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas();\n            let gl = canvas.getContext('webgl', contextOptions);\n\n            const success = !!gl?.getContextAttributes()?.stencil;\n\n            if (gl)\n            {\n                const loseContext = gl.getExtension('WEBGL_lose_context');\n\n                if (loseContext)\n                {\n                    loseContext.loseContext();\n                }\n            }\n\n            gl = null;\n\n            return success;\n        }\n        catch (_e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGLSupported;\n}\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nlet _isWebGPUSupported;\nasync function isWebGPUSupported(options = {}) {\n  if (_isWebGPUSupported !== void 0)\n    return _isWebGPUSupported;\n  _isWebGPUSupported = await (async () => {\n    const gpu = DOMAdapter.get().getNavigator().gpu;\n    if (!gpu) {\n      return false;\n    }\n    try {\n      const adapter = await gpu.requestAdapter(options);\n      await adapter.requestDevice();\n      return true;\n    } catch (_e) {\n      return false;\n    }\n  })();\n  return _isWebGPUSupported;\n}\n\nexport { isWebGPUSupported };\n//# sourceMappingURL=isWebGPUSupported.mjs.map\n","import { DOMAdapter } from '../../environment/adapter';\n\nlet _isWebGPUSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGPU support.\n * @param options - The options for requesting a GPU adapter.\n * @memberof utils\n * @function isWebGPUSupported\n * @returns Is WebGPU supported.\n */\nexport async function isWebGPUSupported(options: GPURequestAdapterOptions = {}): Promise<boolean>\n{\n    if (_isWebGPUSupported !== undefined) return _isWebGPUSupported;\n\n    _isWebGPUSupported = await (async (): Promise<boolean> =>\n    {\n        const gpu = DOMAdapter.get().getNavigator().gpu;\n\n        if (!gpu)\n        {\n            return false;\n        }\n\n        try\n        {\n            const adapter = await gpu.requestAdapter(options) as GPUAdapter;\n\n            // TODO and one of these!\n            await adapter.requestDevice();\n\n            return true;\n        }\n        catch (_e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGPUSupported;\n}\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\nimport { loadBitmapFont, bitmapFontCachePlugin } from '../scene/text-bitmap/asset/loadBitmapFont.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\nimport { BackgroundLoader } from './BackgroundLoader.mjs';\nimport { Cache } from './cache/Cache.mjs';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray.mjs';\nimport { detectAvif } from './detections/parsers/detectAvif.mjs';\nimport { detectDefaults } from './detections/parsers/detectDefaults.mjs';\nimport { detectMp4 } from './detections/parsers/detectMp4.mjs';\nimport { detectOgv } from './detections/parsers/detectOgv.mjs';\nimport { detectWebm } from './detections/parsers/detectWebm.mjs';\nimport { detectWebp } from './detections/parsers/detectWebp.mjs';\nimport { Loader } from './loader/Loader.mjs';\nimport { loadJson } from './loader/parsers/loadJson.mjs';\nimport { loadTxt } from './loader/parsers/loadTxt.mjs';\nimport { loadWebFont } from './loader/parsers/loadWebFont.mjs';\nimport { loadSvg } from './loader/parsers/textures/loadSVG.mjs';\nimport { loadTextures } from './loader/parsers/textures/loadTextures.mjs';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures.mjs';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl.mjs';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl.mjs';\nimport { Resolver } from './resolver/Resolver.mjs';\nimport { convertToList } from './utils/convertToList.mjs';\nimport { isSingleItem } from './utils/isSingleItem.mjs';\n\n\"use strict\";\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver();\n    this.loader = new Loader();\n    this.cache = Cache;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      warn(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === \"string\") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === \"number\" ? [resolutionPref] : resolutionPref;\n    const formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Simple\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n   * const bunny = await Assets.load('bunnyBooBoo');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n   *\n   * const bunny = await Assets.load('burger');\n   * const bunny2 = await Assets.load('chicken');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny.{png,webp}',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});\n   *\n   * Assets.add({\n   *     alias: 'bunnyBooBoo',\n   *     src: [\n   *         'bunny.png',\n   *         'bunny.webp',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */\n  add(assets) {\n    this.resolver.add(assets);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = isSingleItem(urls);\n    const urlArray = convertToList(urls).map((url) => {\n      if (typeof url !== \"string\") {\n        const aliases = this.resolver.getAlias(url);\n        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {\n          this.add(url);\n        }\n        return Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      if (!this.resolver.hasKey(url))\n        this.add({ alias: url, src: url });\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === \"string\") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your initial load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === \"string\") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === \"string\") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === \"string\") {\n      return Cache.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache.get(keys[i]);\n    }\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = [...new Set(Object.values(resolveResults))];\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      keys.forEach((key) => {\n        out[key] = asset;\n      });\n      Cache.set(keys, asset);\n    });\n    return out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = convertToList(urls).map((url) => typeof url !== \"string\" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    if (options.preferredFormats) {\n      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];\n    }\n    for (const detection of options.detections) {\n      if (options.skipDetections || await detection.test()) {\n        formats = await detection.add(formats);\n      } else if (!options.skipDetections) {\n        formats = await detection.remove(formats);\n      }\n    }\n    formats = formats.filter((format, index) => formats.indexOf(format) === index);\n    return formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nextensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n  cacheTextureArray,\n  detectDefaults,\n  detectAvif,\n  detectWebp,\n  detectMp4,\n  detectOgv,\n  detectWebm,\n  loadJson,\n  loadTxt,\n  loadWebFont,\n  loadSvg,\n  loadTextures,\n  loadVideoTextures,\n  loadBitmapFont,\n  bitmapFontCachePlugin,\n  resolveTextureUrl,\n  resolveJsonUrl\n);\nconst assetKeyMap = {\n  loader: ExtensionType.LoadParser,\n  resolver: ExtensionType.ResolveParser,\n  cache: ExtensionType.CacheParser,\n  detection: ExtensionType.DetectionParser\n};\nextensions.handle(ExtensionType.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(\n    ref[key],\n    // Allow the function to optionally define it's own\n    // ExtensionMetadata, the use cases here is priority for LoaderParsers\n    { extension: ref[key].extension ?? type }\n  )));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));\n});\n\nexport { Assets, AssetsClass };\n//# sourceMappingURL=Assets.mjs.map\n","/* eslint-disable max-len */\nimport { extensions, ExtensionType } from '../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from '../scene/text-bitmap/asset/loadBitmapFont';\nimport { warn } from '../utils/logging/warn';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { Loader } from './loader/Loader';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { type LoadTextureConfig, loadTextures } from './loader/parsers/textures/loadTextures';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { AssetExtension } from './AssetExtension';\nimport type { FormatDetectionParser } from './detections/types';\nimport type { LoadSVGConfig } from './loader/parsers/textures/loadSVG';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\nimport type { ArrayOr, AssetsBundle, AssetsManifest, ResolvedAsset, UnresolvedAsset } from './types';\n\n/**\n * Callback for when progress on asset loading is made.\n * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n * of the assets loaded.\n * @memberof assets\n * @callback ProgressCallback\n * @param {number} progress - The percentage (0.0 - 1.0) of the assets loaded.\n * @returns {void}\n * @example\n * (progress) => console.log(progress * 100 + '%')\n */\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @memberof assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {}\n\n/**\n * Initialization options object for the Assets Class.\n * @memberof assets\n */\nexport interface AssetInitOptions\n{\n    // basic...\n    /** a base path for any assets loaded */\n    basePath?: string;\n\n    /** a default URL parameter string to append to all assets loaded */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * a manifest to tell the asset loader upfront what all your assets are\n     * this can be the manifest object itself, or a URL to the manifest.\n     */\n    manifest?: string | AssetsManifest;\n    /**\n     * optional preferences for which textures preferences you have when resolving assets\n     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone\n     * or you might set the resolution to 2 if the user is on a retina display\n     */\n    texturePreference?: {\n        /** the resolution order you prefer, can be an array (priority order - first is preferred) or a single resolutions  */\n        resolution?: number | number[];\n        /**\n         * the formats you prefer, by default this will be:\n         * ['avif', 'webp', 'png', 'jpg', 'jpeg', 'webm', 'mp4', 'm4v', 'ogv']\n         */\n        format?: ArrayOr<string>;\n    };\n\n    /**\n     * If true, don't attempt to detect whether browser has preferred formats available.\n     * May result in increased performance as it skips detection step.\n     */\n    skipDetections?: boolean;\n\n    /** advanced - override how bundlesIds are generated */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /** Optional loader preferences */\n    preferences?: Partial<AssetsPreferences>;\n}\n\n/**\n * A one stop shop for all Pixi resource management!\n * Super modern and easy to use, with enough flexibility to customize and do what you need!\n * @namespace assets\n *\n * Use the singleton class [Assets]{@link assets.Assets} to easily load and manage all your assets.\n *\n * ```typescript\n * import { Assets, Texture } from 'pixi.js';\n *\n * const bunnyTexture = await Assets.load<Texture>('bunny.png');\n * const sprite = new Sprite(bunnyTexture);\n * ```\n *\n * Check out the sections below for more information on how to deal with assets.\n *\n * <details id=\"assets-loading\">\n *\n * <summary>Asset Loading</summary>\n *\n * Do not be afraid to load things multiple times - under the hood, it will **NEVER** load anything more than once.\n *\n * *For example:*\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * promise1 = Assets.load('bunny.png')\n * promise2 = Assets.load('bunny.png')\n *\n * // promise1 === promise2\n * ```\n *\n * Here both promises will be the same. Once resolved... Forever resolved! It makes for really easy resource management!\n *\n * Out of the box Pixi supports the following files:\n * - Textures (**_avif_**, **_webp_**, **_png_**, **_jpg_**, **_gif_**, **_svg_**) via {@link assets.loadTextures}, {@link assets.loadSvg}\n * - Video Textures (**_mp4_**, **_m4v_**, **_webm_**, **_ogg_**, **_ogv_**, **_h264_**, **_avi_**, **_mov_**) via {@link assets.loadVideoTextures}\n * - Sprite sheets (**_json_**) via {@link assets.spritesheetAsset}\n * - Bitmap fonts (**_xml_**, **_fnt_**, **_txt_**) via {@link assets.loadBitmapFont}\n * - Web fonts (**_ttf_**, **_woff_**, **_woff2_**) via {@link assets.loadWebFont}\n * - JSON files (**_json_**) via {@link assets.loadJson}\n * - Text Files (**_txt_**) via {@link assets.loadTxt}\n * <br/>\n * More types can be added fairly easily by creating additional {@link assets.LoaderParser LoaderParsers}.\n * </details>\n *\n * <details id=\"textures\">\n *\n * <summary>Textures</summary>\n *\n * - Textures are loaded as ImageBitmap on a worker thread where possible. Leading to much less janky load + parse times.\n * - By default, we will prefer to load AVIF and WebP image files if you specify them.\n * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.\n * - Textures can also be accessed via `Texture.from()` (see {@link core.from|Texture.from})\n * and now use this asset manager under the hood!\n * - Don't worry if you set preferences for textures that don't exist\n * (for example you prefer 2x resolutions images but only 1x is available for that texture,\n * the Assets manager will pick that up as a fallback automatically)\n *\n * #### Sprite sheets\n * - It's hard to know what resolution a sprite sheet is without loading it first, to address this\n * there is a naming convention we have added that will let Pixi understand the image format and resolution\n * of the spritesheet via its file name: `my-spritesheet{resolution}.{imageFormat}.json`\n * <br><br>For example:\n *   - `my-spritesheet@2x.webp.json`* // 2x resolution, WebP sprite sheet*\n *   - `my-spritesheet@0.5x.png.json`* // 0.5x resolution, png sprite sheet*\n * - This is optional! You can just load a sprite sheet as normal.\n * This is only useful if you have a bunch of different res / formatted spritesheets.\n * </details>\n *\n * <details id=\"fonts\">\n *\n * <summary>Fonts</summary>\n *\n * Web fonts will be loaded with all weights.\n * It is possible to load only specific weights by doing the following:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Load specific weights..\n * await Assets.load({\n *     data: {\n *         weights: ['normal'], // Only loads the weight\n *     },\n *     src: `outfit.woff2`,\n * });\n *\n * // Load everything...\n * await Assets.load(`outfit.woff2`);\n * ```\n * </details>\n *\n * <details id=\"background-loading\">\n *\n * <summary>Background Loading</summary>\n *\n * Background loading will load stuff for you passively behind the scenes. To minimize jank,\n * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the\n * background loader is paused and requested assets are loaded as a priority.\n * Don't worry if something is in there that's already loaded, it will just get skipped!\n *\n * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.\n * It's just that this promise will resolve instantly if the asset\n * has already been loaded.\n * </details>\n *\n * <details id=\"manifests-and-bundles\">\n *\n * <summary>Manifest and Bundles</summary>\n *\n * - {@link assets.AssetsManifest Manifest} is a descriptor that contains a list of all assets and their properties.\n * - {@link assets.AssetsBundle Bundles} are a way to group assets together.\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Manifest Example\n * const manifest = {\n *     bundles: [\n *         {\n *             name: 'load-screen',\n *             assets: [\n *                 {\n *                     alias: 'background',\n *                     src: 'sunset.png',\n *                 },\n *                 {\n *                     alias: 'bar',\n *                     src: 'load-bar.{png,webp}',\n *                 },\n *             ],\n *         },\n *         {\n *             name: 'game-screen',\n *             assets: [\n *                 {\n *                     alias: 'character',\n *                     src: 'robot.png',\n *                 },\n *                 {\n *                     alias: 'enemy',\n *                     src: 'bad-guy.png',\n *                 },\n *             ],\n *         },\n *     ]\n * };\n *\n * await Assets.init({ manifest });\n *\n * // Load a bundle...\n * loadScreenAssets = await Assets.loadBundle('load-screen');\n * // Load another bundle...\n * gameScreenAssets = await Assets.loadBundle('game-screen');\n * ```\n * </details>\n */\n\n/**\n * The global Assets class, it's a singleton so you don't need to instantiate it.\n *\n * **The `Assets` class has four main responsibilities:**\n * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities\n * 2. Loads the resources and transforms them into assets that developers understand.\n * 3. Caches the assets and provides a way to access them.\n * 4. Allow developers to unload assets and clear the cache.\n *\n *\n * **It also has a few advanced features:**\n * 1. Allows developers to provide a {@link assets.Manifest} upfront of all assets and help manage\n * them via {@link assets.AssetsBundles Bundles}.\n * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,\n * in-game loading bars can be a thing of the past!\n * @example\n * import { Assets } from 'pixi.js';\n *\n * const bunny = await Assets.load('bunny.png');\n * @memberof assets\n * @class Assets\n */\nexport class AssetsClass\n{\n    /** the resolver to map various urls */\n    public resolver: Resolver;\n    /** The loader, loads stuff! */\n    public loader: Loader;\n    /**\n     * The global cache of all assets within PixiJS\n     * @type {assets.Cache}\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private readonly _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Best practice is to call this function before any loading commences\n     * Initiating is the best time to add any customization to the way things are loaded.\n     *\n     * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n     * @param options - options to initialize the Assets manager with\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            warn('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<AssetsManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n    }\n\n    /**\n     * Allows you to specify how to resolve any assets load requests.\n     * There are a few ways to add things here as shown below:\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Simple\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n     * const bunny = await Assets.load('bunnyBooBoo');\n     *\n     * // Multiple keys:\n     * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n     *\n     * const bunny = await Assets.load('burger');\n     * const bunny2 = await Assets.load('chicken');\n     *\n     * // passing options to to the object\n     * Assets.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny.{png,webp}',\n     *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * // Multiple assets\n     *\n     * // The following all do the same thing:\n     *\n     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});\n     *\n     * Assets.add({\n     *     alias: 'bunnyBooBoo',\n     *     src: [\n     *         'bunny.png',\n     *         'bunny.webp',\n     *    ],\n     * });\n     *\n     * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n     * @param assets - the unresolved assets to add to the resolver\n     */\n    public add(assets: (ArrayOr<UnresolvedAsset>)): void\n    {\n        this.resolver.add(assets);\n    }\n\n    /**\n     * Loads your assets! You pass in a key or URL and it will return a promise that\n     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.\n     *\n     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded\n     * once and the same promise reused behind the scenes so you can safely call this function multiple\n     * times with the same key and it will always return the same asset.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * Assets.add('thumper', 'bunny.png');\n     * Assets.add('chicko', 'chicken.png');\n     *\n     * // Load multiple assets:\n     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}\n     * @param urls - the urls to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage\n     * (0.0 - 1.0) of the assets loaded.\n     * @returns - the assets that were loaded, either a single asset or a hash of assets\n     */\n    public async load<T = any>(\n        urls: string | UnresolvedAsset,\n        onProgress?: ProgressCallback,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | UnresolvedAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    const aliases = this.resolver.getAlias(url);\n\n                    if (aliases.some((alias) => !this.resolver.hasKey(alias)))\n                    {\n                        this.add(url);\n                    }\n\n                    return Array.isArray(aliases) ? aliases[0] : aliases;\n                }\n\n                // if it hasn't been added, add it now\n                if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url });\n\n                return url;\n            }) as string[];\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can load them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const assets = await Assets.loadBundle('animals');\n     * @param bundleId - the id of the bundle to add\n     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Bundles are a way to load multiple assets at once.\n     * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n     * you can also add bundles via `addBundle`\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * await Assets.init({ manifest });\n     *\n     * // Load a bundle...\n     * loadScreenAssets = await Assets.loadBundle('load-screen');\n     * // Load another bundle...\n     * gameScreenAssets = await Assets.loadBundle('game-screen');\n     * @param bundleIds - the bundle id or ids to load\n     * @param onProgress - Optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n     * of the assets loaded. Do not use this function to detect when assets are complete and available,\n     * instead use the Promise returned by this function.\n     * @returns all the bundles assets or a hash of assets for each bundle specified\n     */\n    public async loadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n\n            total += Object.keys(resolveResult).length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n     *\n     * An example of this might be that you would background load game assets after your initial load.\n     * then when you got to actually load your game screen assets when a player goes to the game - the loading\n     * would already have stared or may even be complete, saving you having to show an interim load bar.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.backgroundLoad('bunny.png');\n     *\n     * // later on in your app...\n     * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n     * @param urls - the url / urls you want to background load\n     */\n    public async backgroundLoad(urls: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n     * this can only be used if the loader has been initiated with a manifest\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *                 name: 'load-screen',\n     *                 assets: [...],\n     *             },\n     *             ...\n     *         ],\n     *     },\n     * });\n     *\n     * Assets.backgroundLoadBundle('load-screen');\n     *\n     * // Later on in your app...\n     * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n     * @param bundleIds - the bundleId / bundleIds you want to background load\n     */\n    public async backgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,\n     * it will return undefined. So it's on you! When in doubt just use `Assets.load` instead.\n     * (Remember, the loader will never load things more than once!)\n     * @param keys - The key or keys for the assets that you want to access\n     * @returns - The assets or hash of assets requested\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: ArrayOr<string>): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolvedAsset | Record<string, ResolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[];\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            keys.forEach((key) =>\n            {\n                out[key] = asset;\n            });\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n     * this will make sure to destroy any assets and release them from memory.\n     * Once unloaded, you will need to load the asset again.\n     *\n     * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n     *\n     * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n     * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * await Assets.unload('http://some.url.com/image.png')\n     *\n     * // myImageTexture will be destroyed now.\n     *\n     * // Unload multiple assets:\n     * const textures = await Assets.unload(['thumper', 'chicko']);\n     * @param urls - the urls to unload\n     */\n    public async unload(\n        urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | ResolvedAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Bundles are a way to manage multiple assets at once.\n     * this will unload all files in a bundle.\n     *\n     * once a bundle has been unloaded, you need to load it again to have access to the assets.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle({\n     *     'thumper': 'http://some.url.com/thumper.png',\n     * })\n     *\n     * const assets = await Assets.loadBundle('thumper');\n     *\n     * // Now to unload...\n     *\n     * await Assets.unloadBundle('thumper');\n     *\n     * // All assets in the assets object will now have been destroyed and purged from the cache\n     * @param bundleIds - the bundle id or ids to unload\n     */\n    public async unloadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolvedAsset | Record<string, ResolvedAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /**\n     * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n     * the users preferred formats order.\n     * @param options - the options to use when detecting formats\n     * @param options.preferredFormats - the preferred formats to use\n     * @param options.skipDetections - if we should skip the detections altogether\n     * @param options.detections - the detections to use\n     * @returns - the detected formats\n     */\n    private async _detectFormats(options: {\n        preferredFormats: string | string[],\n        skipDetections: boolean,\n        detections: FormatDetectionParser[]\n    }): Promise<string[]>\n    {\n        let formats: string[] = [];\n\n        // set preferred formats\n        if (options.preferredFormats)\n        {\n            formats = Array.isArray(options.preferredFormats)\n                ? options.preferredFormats : [options.preferredFormats];\n        }\n\n        // we should add any formats that are supported by the browser\n        for (const detection of options.detections)\n        {\n            if (options.skipDetections || await detection.test())\n            {\n                formats = await detection.add(formats);\n            }\n            else if (!options.skipDetections)\n            {\n                formats = await detection.remove(formats);\n            }\n        }\n\n        // remove any duplicates\n        formats = formats.filter((format, index) => formats.indexOf(format) === index);\n\n        return formats;\n    }\n\n    /** All the detection parsers currently added to the Assets class. */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * General setter for preferences. This is a helper function to set preferences on all parsers.\n     * @param preferences - the preferences to set\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n    loadVideoTextures,\n    loadBitmapFont,\n\n    bitmapFontCachePlugin,\n\n    resolveTextureUrl,\n    resolveJsonUrl\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser.mjs';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams.mjs';\nimport { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { path } from '../../../utils/path.mjs';\nimport { BitmapFont } from '../BitmapFont.mjs';\nimport { bitmapFontTextParser } from './bitmapFontTextParser.mjs';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser.mjs';\n\n\"use strict\";\nconst validExtensions = [\".xml\", \".fnt\"];\nconst bitmapFontCachePlugin = {\n  extension: {\n    type: ExtensionType.CacheParser,\n    name: \"cacheBitmapFont\"\n  },\n  test: (asset) => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n      out[`${key}-bitmap`] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Normal\n  },\n  name: \"loadBitmapFont\",\n  test(url) {\n    return validExtensions.includes(path.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    const textureOptions = bitmapFontData.distanceField ? {\n      scaleMode: \"linear\",\n      alphaMode: \"premultiply-alpha-on-upload\",\n      autoGenerateMipmaps: false,\n      resolution: 1\n    } : {};\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path.join(path.dirname(src), pageFile);\n      imagePath = copySearchParams(imagePath, src);\n      textureUrls.push({\n        src: imagePath,\n        data: textureOptions\n      });\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url.src]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await DOMAdapter.get().fetch(url);\n    return await response.text();\n  },\n  async unload(bitmapFont, _resolvedAsset, loader) {\n    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n    bitmapFont.destroy();\n  }\n};\n\nexport { bitmapFontCachePlugin, loadBitmapFont };\n//# sourceMappingURL=loadBitmapFont.mjs.map\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { CacheParser } from '../../../assets/cache/CacheParser';\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParserAdvanced } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const bitmapFontCachePlugin = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheBitmapFont',\n    },\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n            out[`${key}-bitmap`] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n} satisfies CacheParser<BitmapFont>;\n\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    name: 'loadBitmapFont',\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        // if we have a distance field - we can assume this is a signed distance field font\n        // and we should use force linear filtering and no alpha premultiply\n        const textureOptions = (bitmapFontData.distanceField) ? {\n            scaleMode: 'linear',\n            alphaMode: 'premultiply-alpha-on-upload',\n            autoGenerateMipmaps: false,\n            resolution: 1,\n        } : {};\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push({\n                src: imagePath,\n                data: textureOptions\n            });\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url.src]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} satisfies LoaderParserAdvanced<string, BitmapFont, BitmapFont>;\n","import { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\n\n\"use strict\";\nclass BitmapFont extends AbstractBitmapFont {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const {\n        frame: textureFrame,\n        source: textureSource\n      } = textures[charData.page];\n      const frameReal = new Rectangle(\n        charData.x + textureFrame.x,\n        charData.y + textureFrame.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: \"none\",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from 'pixi.js';\n   *\n   * BitmapFont.install('TitleFont', {\n   *     fontFamily: 'Arial',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: 'purple',\n   * });\n   *\n   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n   */\n  static install(options) {\n    BitmapFontManager.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  static uninstall(name) {\n    BitmapFontManager.uninstall(name);\n  }\n}\n\nexport { BitmapFont };\n//# sourceMappingURL=BitmapFont.mjs.map\n","import { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont.\n * @memberof text\n */\nexport interface BitmapFontOptions\n{\n    data: BitmapFontData\n    textures: Texture[]\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * @memberof text\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /** the url of the font */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const {\n                frame: textureFrame,\n                source: textureSource,\n            } = textures[charData.page];\n\n            const frameReal = new Rectangle(\n                charData.x + textureFrame.x,\n                charData.y + textureFrame.y,\n                charData.width,\n                charData.height,\n            );\n\n            const texture = new Texture({\n                source: textureSource,\n                frame: frameReal\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n","\"use strict\";\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === \"string\" && data.startsWith(\"info face=\");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split(\"=\");\n        const key = split[0];\n        const strValue = split[1].replace(/\"/gm, \"\");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\nexport { bitmapFontTextParser };\n//# sourceMappingURL=bitmapFontTextParser.mjs.map\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser.mjs';\n\n\"use strict\";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === \"string\" && data.includes(\"<font>\")) {\n      return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n  }\n};\n\nexport { bitmapFontXMLStringParser };\n//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n","\"use strict\";\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== \"string\" && \"getElementsByTagName\" in xml && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName(\"info\")[0];\n    const common = xml.getElementsByTagName(\"common\")[0];\n    const distanceField = xml.getElementsByTagName(\"distanceField\")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute(\"fieldType\"),\n        range: parseInt(distanceField.getAttribute(\"distanceRange\"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName(\"page\");\n    const char = xml.getElementsByTagName(\"char\");\n    const kerning = xml.getElementsByTagName(\"kerning\");\n    data.fontSize = parseInt(info.getAttribute(\"size\"), 10);\n    data.fontFamily = info.getAttribute(\"face\");\n    data.lineHeight = parseInt(common.getAttribute(\"lineHeight\"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n        file: page[i].getAttribute(\"file\")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute(\"base\"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute(\"id\"), 10);\n      let letter = charNode.getAttribute(\"letter\") ?? charNode.getAttribute(\"char\") ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(charNode.getAttribute(\"x\"), 10),\n        y: parseInt(charNode.getAttribute(\"y\"), 10),\n        width: parseInt(charNode.getAttribute(\"width\"), 10),\n        height: parseInt(charNode.getAttribute(\"height\"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute(\"xoffset\"), 10),\n        yOffset: parseInt(charNode.getAttribute(\"yoffset\"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute(\"xadvance\"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute(\"first\"), 10);\n      const second = parseInt(kerning[i].getAttribute(\"second\"), 10);\n      const amount = parseInt(kerning[i].getAttribute(\"amount\"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\nexport { bitmapFontXMLParser };\n//# sourceMappingURL=bitmapFontXMLParser.mjs.map\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n","\"use strict\";\nclass BackgroundLoader {\n  /**\n   * @param loader\n   * @param verbose - should the loader log to the console\n   */\n  constructor(loader, verbose = false) {\n    this._loader = loader;\n    this._assetList = [];\n    this._isLoading = false;\n    this._maxConcurrent = 1;\n    this.verbose = verbose;\n  }\n  /**\n   * Adds an array of assets to load.\n   * @param assetUrls - assets to load\n   */\n  add(assetUrls) {\n    assetUrls.forEach((a) => {\n      this._assetList.push(a);\n    });\n    if (this.verbose) {\n      console.log(\"[BackgroundLoader] assets: \", this._assetList);\n    }\n    if (this._isActive && !this._isLoading) {\n      void this._next();\n    }\n  }\n  /**\n   * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n   *\n   * The max assets it will try to load at one time will be 4.\n   */\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = true;\n      const toLoad = [];\n      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++) {\n        toLoad.push(this._assetList.pop());\n      }\n      await this._loader.load(toLoad);\n      this._isLoading = false;\n      void this._next();\n    }\n  }\n  /**\n   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n   * @returns whether the class is active\n   */\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    if (this._isActive === value)\n      return;\n    this._isActive = value;\n    if (value && !this._isLoading) {\n      void this._next();\n    }\n  }\n}\n\nexport { BackgroundLoader };\n//# sourceMappingURL=BackgroundLoader.mjs.map\n","import type { Loader } from './loader/Loader';\nimport type { ResolvedAsset } from './types';\n\n/**\n * Quietly Loads assets in the background.\n * @memberof assets\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: ResolvedAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /** Should the loader log to the console. */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds an array of assets to load.\n     * @param assetUrls - assets to load\n     */\n    public add(assetUrls: ResolvedAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        if (this.verbose)\n        {\n            // eslint-disable-next-line no-console\n            console.log('[BackgroundLoader] assets: ', this._assetList);\n        }\n\n        if (this._isActive && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            void this._next();\n        }\n    }\n\n    /**\n     * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n     * @returns whether the class is active\n     */\n    get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst cacheTextureArray = {\n  extension: {\n    type: ExtensionType.CacheParser,\n    name: \"cacheTextureArray\"\n  },\n  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n  getCacheableAssets: (keys, asset) => {\n    const out = {};\n    keys.forEach((key) => {\n      asset.forEach((item, i) => {\n        out[key + (i === 0 ? \"\" : i + 1)] = item;\n      });\n    });\n    return out;\n  }\n};\n\nexport { cacheTextureArray };\n//# sourceMappingURL=cacheTextureArray.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nimport type { CacheParser } from '../CacheParser';\n\n/**\n * Returns an object of textures from an array of textures to be cached\n * @memberof assets\n */\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheTextureArray',\n    },\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testImageFormat } from '../utils/testImageFormat.mjs';\n\n\"use strict\";\nconst detectAvif = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 1\n  },\n  test: async () => testImageFormat(\n    // eslint-disable-next-line max-len\n    \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=\"\n  ),\n  add: async (formats) => [...formats, \"avif\"],\n  remove: async (formats) => formats.filter((f) => f !== \"avif\")\n};\n\nexport { detectAvif };\n//# sourceMappingURL=detectAvif.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the AVIF image format.\n * @memberof assets\n */\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        // eslint-disable-next-line max-len\n        'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A='\n    ),\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n","\"use strict\";\nasync function testImageFormat(imageData) {\n  if (\"Image\" in globalThis) {\n    return new Promise((resolve) => {\n      const image = new Image();\n      image.onload = () => {\n        resolve(true);\n      };\n      image.onerror = () => {\n        resolve(false);\n      };\n      image.src = imageData;\n    });\n  }\n  if (\"createImageBitmap\" in globalThis && \"fetch\" in globalThis) {\n    try {\n      const blob = await (await fetch(imageData)).blob();\n      await createImageBitmap(blob);\n    } catch (_e) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport { testImageFormat };\n//# sourceMappingURL=testImageFormat.mjs.map\n","export async function testImageFormat(imageData: string): Promise<boolean>\n{\n    // Some browsers currently do not support createImageBitmap with Blob, so new Image() is preferred when exist.\n    // See https://caniuse.com/createimagebitmap for more information.\n\n    if ('Image' in globalThis)\n    {\n        return new Promise<boolean>((resolve) =>\n        {\n            const image = new Image();\n\n            image.onload = () =>\n            {\n                resolve(true);\n            };\n            image.onerror = () =>\n            {\n                resolve(false);\n            };\n            image.src = imageData;\n        });\n    }\n\n    if ('createImageBitmap' in globalThis && 'fetch' in globalThis)\n    {\n        try\n        {\n            const blob = await (await fetch(imageData)).blob();\n\n            await createImageBitmap(blob);\n        }\n        catch (_e)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst imageFormats = [\"png\", \"jpg\", \"jpeg\"];\nconst detectDefaults = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: -1\n  },\n  test: () => Promise.resolve(true),\n  add: async (formats) => [...formats, ...imageFormats],\n  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))\n};\n\nexport { detectDefaults };\n//# sourceMappingURL=detectDefaults.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { FormatDetectionParser } from '../types';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\n/**\n * Adds some default image formats to the detection parser\n * @memberof assets\n */\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testVideoFormat } from '../utils/testVideoFormat.mjs';\n\n\"use strict\";\nconst detectMp4 = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat(\"video/mp4\"),\n  add: async (formats) => [...formats, \"mp4\", \"m4v\"],\n  remove: async (formats) => formats.filter((f) => f !== \"mp4\" && f !== \"m4v\")\n};\n\nexport { detectMp4 };\n//# sourceMappingURL=detectMp4.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the MP4 video format.\n * @memberof assets\n */\nexport const detectMp4 = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/mp4'),\n    add: async (formats) => [...formats, 'mp4', 'm4v'],\n    remove: async (formats) => formats.filter((f) => f !== 'mp4' && f !== 'm4v'),\n} as FormatDetectionParser;\n","\"use strict\";\nconst inWorker = \"WorkerGlobalScope\" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;\nfunction testVideoFormat(mimeType) {\n  if (inWorker) {\n    return false;\n  }\n  const video = document.createElement(\"video\");\n  return video.canPlayType(mimeType) !== \"\";\n}\n\nexport { testVideoFormat };\n//# sourceMappingURL=testVideoFormat.mjs.map\n","const inWorker = 'WorkerGlobalScope' in globalThis\n    && globalThis instanceof (globalThis as any).WorkerGlobalScope;\n\nexport function testVideoFormat(mimeType: string): boolean\n{\n    if (inWorker)\n    {\n        return false;\n    }\n\n    const video = document.createElement('video');\n\n    return video.canPlayType(mimeType) !== '';\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testVideoFormat } from '../utils/testVideoFormat.mjs';\n\n\"use strict\";\nconst detectOgv = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat(\"video/ogg\"),\n  add: async (formats) => [...formats, \"ogv\"],\n  remove: async (formats) => formats.filter((f) => f !== \"ogv\")\n};\n\nexport { detectOgv };\n//# sourceMappingURL=detectOgv.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the OGV video format.\n * @memberof assets\n */\nexport const detectOgv = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/ogg'),\n    add: async (formats) => [...formats, 'ogv'],\n    remove: async (formats) => formats.filter((f) => f !== 'ogv'),\n} as FormatDetectionParser;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testVideoFormat } from '../utils/testVideoFormat.mjs';\n\n\"use strict\";\nconst detectWebm = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat(\"video/webm\"),\n  add: async (formats) => [...formats, \"webm\"],\n  remove: async (formats) => formats.filter((f) => f !== \"webm\")\n};\n\nexport { detectWebm };\n//# sourceMappingURL=detectWebm.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebM video format.\n * @memberof assets\n */\nexport const detectWebm = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/webm'),\n    add: async (formats) => [...formats, 'webm'],\n    remove: async (formats) => formats.filter((f) => f !== 'webm'),\n} as FormatDetectionParser;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testImageFormat } from '../utils/testImageFormat.mjs';\n\n\"use strict\";\nconst detectWebp = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testImageFormat(\n    \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=\"\n  ),\n  add: async (formats) => [...formats, \"webp\"],\n  remove: async (formats) => formats.filter((f) => f !== \"webp\")\n};\n\nexport { detectWebp };\n//# sourceMappingURL=detectWebp.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebP image format.\n * @memberof assets\n */\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA='\n    ),\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    /** Cache loading promises that ae currently active */\n    this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n            asset = await parser2.parse(asset, data, this) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = isSingleItem(assetsToLoadIn);\n    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({\n      alias: [item],\n      src: item,\n      data: {}\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async (asset) => {\n      const url = path.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress)\n            onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load('cool.png');\n   *\n   * await Loader.unload('cool.png');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({\n      alias: [item],\n      src: item\n    }));\n    const promises = assetsToUnload.map(async (asset) => {\n      const url = path.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url];\n        await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {\n      if (!parser.name) {\n        warn(`[Assets] loadParser should have a name`);\n      } else if (hash[parser.name]) {\n        warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n      }\n      return { ...hash, [parser.name]: parser };\n    }, {});\n  }\n}\n\nexport { Loader };\n//# sourceMappingURL=Loader.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { ResolvedAsset } from '../types';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Loader\n{\n    private readonly _parsers: LoaderParser[] = [];\n    private _parserHash: Record<string, LoaderParser>;\n\n    private _parsersValidated = false;\n\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    public parsers = new Proxy(this._parsers, {\n        set: (target, key, value) =>\n        {\n            this._parsersValidated = false;\n\n            target[key as any as number] = value;\n\n            return true;\n        }\n    });\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: ResolvedAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            let parser: LoaderParser = null;\n\n            // first check to see if the user has specified a parser\n            if (data.loadParser)\n            {\n                // they have? lovely, lets use it\n                parser = this._parserHash[data.loadParser];\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n\n                    warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n                    // #endif\n                }\n            }\n\n            // no parser specified, so lets try and find one using the tests\n            if (!parser)\n            {\n                for (let i = 0; i < this.parsers.length; i++)\n                {\n                    const parserX = this.parsers[i];\n\n                    if (parserX.load && parserX.test?.(url, data, this))\n                    {\n                        parser = parserX;\n                        break;\n                    }\n                }\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    // #endif\n\n                    return null;\n                }\n            }\n\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | ResolvedAsset,\n        onProgress?: (progress: number) => void,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._parsersValidated)\n        {\n            this._validateParsers();\n        }\n\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<ResolvedAsset>(assetsToLoadIn, (item) => ({\n            alias: [item],\n            src: item,\n            data: {}\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<ResolvedAsset>(assetsToUnloadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                delete this.promiseCache[url];\n\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n    private _validateParsers()\n    {\n        this._parsersValidated = true;\n\n        this._parserHash = this._parsers\n            .filter((parser) => parser.name)\n            .reduce((hash, parser) =>\n            {\n                if (!parser.name)\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser should have a name`);\n                    // #endif\n                }\n                else if (hash[parser.name])\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n                    // #endif\n                }\n\n                return { ...hash, [parser.name]: parser };\n            }, {} as Record<string, LoaderParser>);\n    }\n}\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { checkDataUrl } from '../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from './LoaderParser.mjs';\n\n\"use strict\";\nconst validJSONExtension = \".json\";\nconst validJSONMIME = \"application/json\";\nconst loadJson = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: \"loadJson\",\n  test(url) {\n    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n  },\n  async load(url) {\n    const response = await DOMAdapter.get().fetch(url);\n    const json = await response.json();\n    return json;\n  }\n};\n\nexport { loadJson };\n//# sourceMappingURL=loadJson.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validJSONExtension = '.json';\nconst validJSONMIME = 'application/json';\n\n/**\n * A simple loader plugin for loading json data\n * @memberof assets\n */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadJson',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} satisfies LoaderParser<string>;\n","\"use strict\";\nfunction checkDataUrl(url, mimes) {\n  if (Array.isArray(mimes)) {\n    for (const mime of mimes) {\n      if (url.startsWith(`data:${mime}`))\n        return true;\n    }\n    return false;\n  }\n  return url.startsWith(`data:${mimes}`);\n}\n\nexport { checkDataUrl };\n//# sourceMappingURL=checkDataUrl.mjs.map\n","export function checkDataUrl(url: string, mimes: string | string[]): boolean\n{\n    if (Array.isArray(mimes))\n    {\n        for (const mime of mimes)\n        {\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n\n        return false;\n    }\n\n    return url.startsWith(`data:${mimes}`);\n}\n","import { path } from '../../utils/path.mjs';\n\n\"use strict\";\nfunction checkExtension(url, extension) {\n  const tempURL = url.split(\"?\")[0];\n  const ext = path.extname(tempURL).toLowerCase();\n  if (Array.isArray(extension)) {\n    return extension.includes(ext);\n  }\n  return ext === extension;\n}\n\nexport { checkExtension };\n//# sourceMappingURL=checkExtension.mjs.map\n","import { path } from '../../utils/path';\n\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext);\n    }\n\n    return ext === extension;\n}\n\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { checkDataUrl } from '../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from './LoaderParser.mjs';\n\n\"use strict\";\nconst validTXTExtension = \".txt\";\nconst validTXTMIME = \"text/plain\";\nconst loadTxt = {\n  name: \"loadTxt\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low,\n    name: \"loadTxt\"\n  },\n  test(url) {\n    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n  },\n  async load(url) {\n    const response = await DOMAdapter.get().fetch(url);\n    const txt = await response.text();\n    return txt;\n  }\n};\n\nexport { loadTxt };\n//# sourceMappingURL=loadTxt.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validTXTExtension = '.txt';\nconst validTXTMIME = 'text/plain';\n\n/**\n * A simple loader plugin for loading text data\n * @memberof assets\n */\nexport const loadTxt = {\n\n    name: 'loadTxt',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadTxt',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} satisfies LoaderParser<string>;\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { path } from '../../../utils/path.mjs';\nimport { Cache } from '../../cache/Cache.mjs';\nimport { checkDataUrl } from '../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from './LoaderParser.mjs';\n\n\"use strict\";\nconst validWeights = [\n  \"normal\",\n  \"bold\",\n  \"100\",\n  \"200\",\n  \"300\",\n  \"400\",\n  \"500\",\n  \"600\",\n  \"700\",\n  \"800\",\n  \"900\"\n];\nconst validFontExtensions = [\".ttf\", \".otf\", \".woff\", \".woff2\"];\nconst validFontMIMEs = [\n  \"font/ttf\",\n  \"font/otf\",\n  \"font/woff\",\n  \"font/woff2\"\n];\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction getFontFamilyName(url) {\n  const ext = path.extname(url);\n  const name = path.basename(url, ext);\n  const nameWithSpaces = name.replace(/(-|_)/g, \" \");\n  const nameTokens = nameWithSpaces.toLowerCase().split(\" \").map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n  let valid = nameTokens.length > 0;\n  for (const token of nameTokens) {\n    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {\n      valid = false;\n      break;\n    }\n  }\n  let fontFamilyName = nameTokens.join(\" \");\n  if (!valid) {\n    fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, \"\\\\$&\")}\"`;\n  }\n  return fontFamilyName;\n}\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\nfunction encodeURIWhenNeeded(uri) {\n  if (validURICharactersRegex.test(uri)) {\n    return uri;\n  }\n  return encodeURI(uri);\n}\nconst loadWebFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: \"loadWebFont\",\n  test(url) {\n    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n  },\n  async load(url, options) {\n    const fonts = DOMAdapter.get().getFontFaceSet();\n    if (fonts) {\n      const fontFaces = [];\n      const name = options.data?.family ?? getFontFamilyName(url);\n      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? [\"normal\"];\n      const data = options.data ?? {};\n      for (let i = 0; i < weights.length; i++) {\n        const weight = weights[i];\n        const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n          ...data,\n          weight\n        });\n        await font.load();\n        fonts.add(font);\n        fontFaces.push(font);\n      }\n      Cache.set(`${name}-and-url`, {\n        url,\n        fontFaces\n      });\n      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n    }\n    warn(\"[loadWebFont] FontFace API is not supported. Skipping loading font\");\n    return null;\n  },\n  unload(font) {\n    (Array.isArray(font) ? font : [font]).forEach((t) => {\n      Cache.remove(`${t.family}-and-url`);\n      DOMAdapter.get().getFontFaceSet().delete(t);\n    });\n  }\n};\n\nexport { getFontFamilyName, loadWebFont };\n//# sourceMappingURL=loadWebFont.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { path } from '../../../utils/path';\nimport { Cache } from '../../cache/Cache';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { ResolvedAsset } from '../../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = [\n    'normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFontExtensions = ['.ttf', '.otf', '.woff', '.woff2'];\nconst validFontMIMEs = [\n    'font/ttf',\n    'font/otf',\n    'font/woff',\n    'font/woff2',\n];\n\n/**\n * Data for loading a font\n * @memberof assets\n */\nexport type LoadFontData = {\n    /** Font family name */\n    family: string;\n    /** A set of optional descriptors passed as an object. It can contain any of the descriptors available for @font-face: */\n    display: string;\n    /**\n     * The featureSettings property of the FontFace interface retrieves or sets infrequently used\n     * font features that are not available from a font's variant properties.\n     */\n    featureSettings: string;\n    /** The stretch property of the FontFace interface retrieves or sets how the font stretches. */\n    stretch: string;\n    /** The style property of the FontFace interface retrieves or sets the font's style. */\n    style: string;\n    /**\n     * The unicodeRange property of the FontFace interface retrieves or sets the range of\n     * unicode code points encompassing the font.\n     */\n    unicodeRange: string;\n    /** The variant property of the FontFace interface programmatically retrieves or sets font variant values. */\n    variant: string;\n    /** The weight property of the FontFace interface retrieves or sets the weight of the font. */\n    weights: string[];\n};\n\n/**\n * RegExp for matching CSS <ident-token>. It doesn't consider escape and non-ASCII characters, but enough for us.\n * @see {@link https://www.w3.org/TR/css-syntax-3/#ident-token-diagram}\n */\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/titan-one.woff' turns into 'Titan One'\n * @param url - File url\n * @memberof assets\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = path.extname(url);\n    const name = path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTokens = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n\n    let valid = nameTokens.length > 0;\n\n    for (const token of nameTokens)\n    {\n        if (!token.match(CSS_IDENT_TOKEN_REGEX))\n        {\n            valid = false;\n            break;\n        }\n    }\n\n    let fontFamilyName = nameTokens.join(' ');\n\n    if (!valid)\n    {\n        fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, '\\\\$&')}\"`;\n    }\n\n    return fontFamilyName;\n}\n\n// See RFC 3986 Chapter 2. Characters\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\n\n/**\n * Encode URI only when it contains invalid characters.\n * @param uri - URI to encode.\n */\nfunction encodeURIWhenNeeded(uri: string)\n{\n    if (validURICharactersRegex.test(uri))\n    {\n        return uri;\n    }\n\n    return encodeURI(uri);\n}\n\n/**\n * A loader plugin for handling web fonts\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *   alias: 'font',\n *   src: 'fonts/titan-one.woff',\n *   data: {\n *     family: 'Titan One',\n *     weights: ['normal', 'bold'],\n *   }\n * })\n * @memberof assets\n */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    name: 'loadWebFont',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n    },\n\n    async load(url: string, options?: ResolvedAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        const fonts = DOMAdapter.get().getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            Cache.set(`${name}-and-url`, {\n                url,\n                fontFaces,\n            });\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        (Array.isArray(font) ? font : [font])\n            .forEach((t) =>\n            {\n                Cache.remove(`${t.family}-and-url`);\n                DOMAdapter.get().getFontFaceSet().delete(t);\n            });\n    }\n} satisfies LoaderParser<FontFace | FontFace[]>;\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validSVGExtension = \".svg\";\nconst validSVGMIME = \"image/svg+xml\";\nconst loadSvg = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low,\n    name: \"loadSVG\"\n  },\n  name: \"loadSVG\",\n  config: {\n    crossOrigin: \"anonymous\",\n    parseAsGraphicsContext: false\n  },\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async load(url, asset, loader) {\n    if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {\n      return loadAsGraphics(url);\n    }\n    return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n  },\n  unload(asset) {\n    asset.destroy(true);\n  }\n};\nasync function loadAsTexture(url, asset, loader, crossOrigin) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const blobUrl = URL.createObjectURL(blob);\n  const image = new Image();\n  image.src = blobUrl;\n  image.crossOrigin = crossOrigin;\n  await image.decode();\n  URL.revokeObjectURL(blobUrl);\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n  const width = asset.data?.width ?? image.width;\n  const height = asset.data?.height ?? image.height;\n  canvas.width = width * resolution;\n  canvas.height = height * resolution;\n  context.drawImage(image, 0, 0, width * resolution, height * resolution);\n  const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};\n  const base = new ImageSource({\n    resource: canvas,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    resolution,\n    ...rest\n  });\n  return createTexture(base, loader, url);\n}\nasync function loadAsGraphics(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const svgSource = await response.text();\n  const context = new GraphicsContext();\n  context.svg(svgSource);\n  return context;\n}\n\nexport { loadSvg };\n//# sourceMappingURL=loadSVG.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { type LoaderParser, LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\n\n/**\n * Configuration for the [loadSVG]{@link assets.loadSVG} plugin.\n * @see assets.loadSVG\n * @memberof assets\n */\nexport interface LoadSVGConfig\n{\n    /**\n     * The crossOrigin value to use for loading the SVG as an image.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n    /**\n     * When set to `true`, loading and decoding images will happen with `new Image()`,\n     * @default false\n     */\n    parseAsGraphicsContext: boolean;\n}\n\n/**\n * Regular expression for SVG XML document.\n * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n * @readonly\n */\nconst validSVGExtension = '.svg';\nconst validSVGMIME = 'image/svg+xml';\n\n/**\n * A simple loader plugin for loading json data\n * @memberof assets\n */\nexport const loadSvg: LoaderParser<Texture | GraphicsContext, TextureSourceOptions & LoadSVGConfig, LoadSVGConfig> = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadSVG',\n    },\n\n    name: 'loadSVG',\n\n    config: {\n        crossOrigin: 'anonymous',\n        parseAsGraphicsContext: false,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n    },\n\n    async load(\n        url: string,\n        asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n        loader: Loader\n    ): Promise<Texture | GraphicsContext>\n    {\n        if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext)\n        {\n            return loadAsGraphics(url);\n        }\n\n        return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n\n    unload(asset: Texture | GraphicsContext): void\n    {\n        asset.destroy(true);\n    }\n\n};\n\nasync function loadAsTexture(\n    url: string,\n    asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n    loader: Loader,\n    crossOrigin: HTMLImageElement['crossOrigin']\n): Promise<Texture>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const blobUrl = URL.createObjectURL(blob);\n\n    const image = new Image();\n\n    image.src = blobUrl;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n\n    URL.revokeObjectURL(blobUrl);\n\n    // convert to canvas...\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n\n    const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n\n    canvas.width = width * resolution;\n    canvas.height = height * resolution;\n\n    context.drawImage(image, 0, 0, width * resolution, height * resolution);\n\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};\n    const base = new ImageSource({\n        resource: canvas,\n        alphaMode: 'premultiply-alpha-on-upload',\n        resolution,\n        ...rest,\n    });\n\n    return createTexture(base, loader, url);\n}\n\nasync function loadAsGraphics(url: string): Promise<GraphicsContext>\n{\n    const response = await DOMAdapter.get().fetch(url);\n    const svgSource = await response.text();\n\n    const context = new GraphicsContext();\n\n    context.svg(svgSource);\n\n    return context;\n}\n","import { Resolver } from '../../assets/resolver/Resolver.mjs';\n\n\"use strict\";\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = Resolver.RETINA_PREFIX?.exec(url);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue;\n}\n\nexport { getResolutionOfUrl };\n//# sourceMappingURL=getResolutionOfUrl.mjs.map\n","import { Resolver } from '../../assets/resolver/Resolver';\n\n/**\n * get the resolution / device pixel ratio of an asset by looking for the prefix\n * used by spritesheets and image urls\n * @memberof utils\n * @function getResolutionOfUrl\n * @param {string} url - the image path\n * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.\n * @returns {number} resolution / device pixel ratio of an asset\n */\nexport function getResolutionOfUrl(url: string, defaultValue = 1): number\n{\n    const resolution = Resolver.RETINA_PREFIX?.exec(url);\n\n    if (resolution)\n    {\n        return parseFloat(resolution[1]);\n    }\n\n    return defaultValue;\n}\n","import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { Cache } from '../../../../cache/Cache.mjs';\n\n\"use strict\";\nfunction createTexture(source, loader, url) {\n  source.label = url;\n  source._sourceOrigin = url;\n  const texture = new Texture({\n    source,\n    label: url\n  });\n  const unload = () => {\n    delete loader.promiseCache[url];\n    if (Cache.has(url)) {\n      Cache.remove(url);\n    }\n  };\n  texture.source.once(\"destroy\", () => {\n    if (loader.promiseCache[url]) {\n      warn(\"[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.\");\n      unload();\n    }\n  });\n  texture.once(\"destroy\", () => {\n    if (!source.destroyed) {\n      warn(\"[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.\");\n      unload();\n    }\n  });\n  return texture;\n}\n\nexport { createTexture };\n//# sourceMappingURL=createTexture.mjs.map\n","import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { Cache } from '../../../../cache/Cache';\n\nimport type { TextureSource } from '../../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Loader } from '../../../Loader';\n\n/**\n * Creates a texture from a source and adds it to the cache.\n * @param source - source of the texture\n * @param loader - loader\n * @param url - url of the texture\n * @ignore\n */\nexport function createTexture(source: TextureSource, loader: Loader, url: string)\n{\n    source.label = url;\n    source._sourceOrigin = url;\n\n    const texture = new Texture({\n        source,\n        label: url,\n    });\n\n    const unload = () =>\n    {\n        delete loader.promiseCache[url];\n\n        if (Cache.has(url))\n        {\n            Cache.remove(url);\n        }\n    };\n\n    // remove the promise from the loader and the url from the cache when the texture is destroyed\n    texture.source.once('destroy', () =>\n    {\n        if (loader.promiseCache[url])\n        {\n            // #if _DEBUG\n            warn('[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! '\n           + 'Use Assets.unload() instead of destroying the TextureSource.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    texture.once('destroy', () =>\n    {\n        if (!source.destroyed)\n        {\n            // #if _DEBUG\n            warn('[Assets] A Texture managed by Assets was destroyed instead of unloaded! '\n             + 'Use Assets.unload() instead of destroying the Texture.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    return texture;\n}\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { WorkerManager } from '../../workers/WorkerManager.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validImageExtensions = [\".jpeg\", \".jpg\", \".png\", \".webp\", \".avif\"];\nconst validImageMIMEs = [\n  \"image/jpeg\",\n  \"image/png\",\n  \"image/webp\",\n  \"image/avif\"\n];\nasync function loadImageBitmap(url, asset) {\n  const response = await DOMAdapter.get().fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  return asset?.data?.alphaMode === \"premultiplied-alpha\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \"none\" }) : createImageBitmap(imageBlob);\n}\nconst loadTextures = {\n  name: \"loadTextures\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High,\n    name: \"loadTextures\"\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: \"anonymous\"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {\n        src = await WorkerManager.loadImageBitmap(url, asset);\n      } else {\n        src = await loadImageBitmap(url, asset);\n      }\n    } else {\n      src = await new Promise((resolve, reject) => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n          src.onerror = reject;\n        }\n      });\n    }\n    const base = new ImageSource({\n      resource: src,\n      alphaMode: \"premultiply-alpha-on-upload\",\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      ...asset.data\n    });\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexport { loadImageBitmap, loadTextures };\n//# sourceMappingURL=loadTextures.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { WorkerManager } from '../../workers/WorkerManager';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the [loadTextures]{@link assets.loadTextures} plugin.\n * @see assets.loadTextures\n * @memberof assets\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n * @ignore\n */\nexport async function loadImageBitmap(url: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n\n    return asset?.data?.alphaMode === 'premultiplied-alpha'\n        ? createImageBitmap(imageBlob, { premultiplyAlpha: 'none' })\n        : createImageBitmap(imageBlob);\n}\n\n/**\n * A simple plugin to load our textures!\n * This makes use of imageBitmaps where available.\n * We load the `ImageBitmap` on a different thread using workers if possible.\n * We can then use the `ImageBitmap` as a source for a Pixi texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * Which can be found [here]{@link assets.LoadTextureConfig}\n * ```js\n * // Set the config\n * import { loadTextures } from 'pixi.js';\n *\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap,\n *    // we'll also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @memberof assets\n */\nexport const loadTextures: LoaderParser<Texture, TextureSourceOptions, LoadTextureConfig> = {\n\n    name: 'loadTextures',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadTextures',\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: ResolvedAsset<TextureSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url, asset);\n            }\n            else\n            {\n                src = await loadImageBitmap(url, asset);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve, reject) =>\n            {\n                src = new Image();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                    src.onerror = reject;\n                }\n            });\n        }\n\n        const base = new ImageSource({\n            resource: src,\n            alphaMode: 'premultiply-alpha-on-upload',\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n};\n","import WorkerInstance from '../../../_virtual/checkImageBitmap.worker.mjs';\nimport WorkerInstance$1 from '../../../_virtual/loadImageBitmap.worker.mjs';\n\n\"use strict\";\nlet UUID = 0;\nlet MAX_WORKERS;\nclass WorkerManagerClass {\n  constructor() {\n    this._initialized = false;\n    this._createdWorkers = 0;\n    this._workerPool = [];\n    this._queue = [];\n    this._resolveHash = {};\n  }\n  isImageBitmapSupported() {\n    if (this._isImageBitmapSupported !== void 0)\n      return this._isImageBitmapSupported;\n    this._isImageBitmapSupported = new Promise((resolve) => {\n      const { worker } = new WorkerInstance();\n      worker.addEventListener(\"message\", (event) => {\n        worker.terminate();\n        WorkerInstance.revokeObjectURL();\n        resolve(event.data);\n      });\n    });\n    return this._isImageBitmapSupported;\n  }\n  loadImageBitmap(src, asset) {\n    return this._run(\"loadImageBitmap\", [src, asset?.data?.alphaMode]);\n  }\n  async _initWorkers() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n  }\n  _getWorker() {\n    if (MAX_WORKERS === void 0) {\n      MAX_WORKERS = navigator.hardwareConcurrency || 4;\n    }\n    let worker = this._workerPool.pop();\n    if (!worker && this._createdWorkers < MAX_WORKERS) {\n      this._createdWorkers++;\n      worker = new WorkerInstance$1().worker;\n      worker.addEventListener(\"message\", (event) => {\n        this._complete(event.data);\n        this._returnWorker(event.target);\n        this._next();\n      });\n    }\n    return worker;\n  }\n  _returnWorker(worker) {\n    this._workerPool.push(worker);\n  }\n  _complete(data) {\n    if (data.error !== void 0) {\n      this._resolveHash[data.uuid].reject(data.error);\n    } else {\n      this._resolveHash[data.uuid].resolve(data.data);\n    }\n    this._resolveHash[data.uuid] = null;\n  }\n  async _run(id, args) {\n    await this._initWorkers();\n    const promise = new Promise((resolve, reject) => {\n      this._queue.push({ id, arguments: args, resolve, reject });\n    });\n    this._next();\n    return promise;\n  }\n  _next() {\n    if (!this._queue.length)\n      return;\n    const worker = this._getWorker();\n    if (!worker) {\n      return;\n    }\n    const toDo = this._queue.pop();\n    const id = toDo.id;\n    this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n    worker.postMessage({\n      data: toDo.arguments,\n      uuid: UUID++,\n      id\n    });\n  }\n}\nconst WorkerManager = new WorkerManagerClass();\n\nexport { WorkerManager };\n//# sourceMappingURL=WorkerManager.mjs.map\n","import CheckImageBitmapWorker from 'worker:./checkImageBitmap.worker.ts';\nimport LoadImageBitmapWorker from 'worker:./loadImageBitmap.worker.ts';\n\nimport type { TextureSourceOptions } from '../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { ResolvedAsset } from '../../types';\n\nlet UUID = 0;\nlet MAX_WORKERS: number;\n\ntype LoadImageBitmapResult = {\n    data?: ImageBitmap,\n    error?: Error,\n    uuid: number,\n    id: string,\n};\n\nclass WorkerManagerClass\n{\n    public worker: Worker;\n    private _resolveHash: {\n        [key: string]: {\n            resolve: (...param: any[]) => void;\n            reject: (...param: any[]) => void;\n        }\n    };\n    private readonly _workerPool: Worker[];\n    private readonly _queue: {\n        id: string;\n        arguments: any[];\n        resolve: (...param: any[]) => void;\n        reject: (...param: any[]) => void;\n    }[];\n    private _initialized = false;\n    private _createdWorkers = 0;\n    private _isImageBitmapSupported?: Promise<boolean>;\n\n    constructor()\n    {\n        this._workerPool = [];\n        this._queue = [];\n\n        this._resolveHash = {};\n    }\n\n    public isImageBitmapSupported(): Promise<boolean>\n    {\n        if (this._isImageBitmapSupported !== undefined) return this._isImageBitmapSupported;\n\n        this._isImageBitmapSupported = new Promise((resolve) =>\n        {\n            const { worker } = new CheckImageBitmapWorker();\n\n            worker.addEventListener('message', (event: MessageEvent<boolean>) =>\n            {\n                worker.terminate();\n                CheckImageBitmapWorker.revokeObjectURL();\n                resolve(event.data);\n            });\n        });\n\n        return this._isImageBitmapSupported;\n    }\n\n    public loadImageBitmap(src: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src, asset?.data?.alphaMode]) as Promise<ImageBitmap>;\n    }\n\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    private _getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this._workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new LoadImageBitmapWorker().worker;\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this._complete(event.data);\n\n                this._returnWorker(event.target as Worker);\n                this._next();\n            });\n        }\n\n        return worker;\n    }\n\n    private _returnWorker(worker: Worker)\n    {\n        this._workerPool.push(worker);\n    }\n\n    private _complete(data: LoadImageBitmapResult): void\n    {\n        if (data.error !== undefined)\n        {\n            this._resolveHash[data.uuid].reject(data.error);\n        }\n        else\n        {\n            this._resolveHash[data.uuid].resolve(data.data);\n        }\n\n        this._resolveHash[data.uuid] = null;\n    }\n\n    private async _run(id: string, args: any[]): Promise<any>\n    {\n        await this._initWorkers();\n        // push into the queue...\n\n        const promise = new Promise((resolve, reject) =>\n        {\n            this._queue.push({ id, arguments: args, resolve, reject });\n        });\n\n        this._next();\n\n        return promise;\n    }\n\n    private _next(): void\n    {\n        // nothing to do\n        if (!this._queue.length) return;\n\n        const worker = this._getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this._queue.pop();\n\n        const id = toDo.id;\n\n        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n}\n\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n","const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const WHITE_PNG = \\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\\"function\\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (_e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=checkImageBitmap.worker.mjs.map\n","const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    async function loadImageBitmap(url, alphaMode) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      return alphaMode === \\\"premultiplied-alpha\\\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \\\"none\\\" }) : createImageBitmap(imageBlob);\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=loadImageBitmap.worker.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource.mjs';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validVideoExtensions = [\".mp4\", \".m4v\", \".webm\", \".ogg\", \".ogv\", \".h264\", \".avi\", \".mov\"];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\nfunction crossOrigin(element, url, crossorigin) {\n  if (crossorigin === void 0 && !url.startsWith(\"data:\")) {\n    element.crossOrigin = determineCrossOrigin(url);\n  } else if (crossorigin !== false) {\n    element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n  }\n}\nfunction preloadVideo(element) {\n  return new Promise((resolve, reject) => {\n    element.addEventListener(\"canplaythrough\", loaded);\n    element.addEventListener(\"error\", error);\n    element.load();\n    function loaded() {\n      cleanup();\n      resolve();\n    }\n    function error(err) {\n      cleanup();\n      reject(err);\n    }\n    function cleanup() {\n      element.removeEventListener(\"canplaythrough\", loaded);\n      element.removeEventListener(\"error\", error);\n    }\n  });\n}\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith(\"data:\")) {\n    return \"\";\n  }\n  loc || (loc = globalThis.location);\n  const parsedUrl = new URL(url, document.baseURI);\n  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {\n    return \"anonymous\";\n  }\n  return \"\";\n}\nconst loadVideoTextures = {\n  name: \"loadVideo\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    name: \"loadVideo\"\n  },\n  test(url) {\n    const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n    const isValidExtension = checkExtension(url, validVideoExtensions);\n    return isValidDataUrl || isValidExtension;\n  },\n  async load(url, asset, loader) {\n    const options = {\n      ...VideoSource.defaultOptions,\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n      ...asset.data\n    };\n    const videoElement = document.createElement(\"video\");\n    const attributeMap = {\n      preload: options.autoLoad !== false ? \"auto\" : void 0,\n      \"webkit-playsinline\": options.playsinline !== false ? \"\" : void 0,\n      playsinline: options.playsinline !== false ? \"\" : void 0,\n      muted: options.muted === true ? \"\" : void 0,\n      loop: options.loop === true ? \"\" : void 0,\n      autoplay: options.autoPlay !== false ? \"\" : void 0\n    };\n    Object.keys(attributeMap).forEach((key) => {\n      const value = attributeMap[key];\n      if (value !== void 0)\n        videoElement.setAttribute(key, value);\n    });\n    if (options.muted === true) {\n      videoElement.muted = true;\n    }\n    crossOrigin(videoElement, url, options.crossorigin);\n    const sourceElement = document.createElement(\"source\");\n    let mime;\n    if (url.startsWith(\"data:\")) {\n      mime = url.slice(5, url.indexOf(\";\"));\n    } else if (!url.startsWith(\"blob:\")) {\n      const ext = url.split(\"?\")[0].slice(url.lastIndexOf(\".\") + 1).toLowerCase();\n      mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n    }\n    sourceElement.src = url;\n    if (mime) {\n      sourceElement.type = mime;\n    }\n    return new Promise((resolve) => {\n      const onCanPlay = async () => {\n        const base = new VideoSource({ ...options, resource: videoElement });\n        videoElement.removeEventListener(\"canplay\", onCanPlay);\n        if (asset.data.preload) {\n          await preloadVideo(videoElement);\n        }\n        resolve(createTexture(base, loader, url));\n      };\n      videoElement.addEventListener(\"canplay\", onCanPlay);\n      videoElement.appendChild(sourceElement);\n    });\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo };\n//# sourceMappingURL=loadVideoTextures.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { VideoSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validVideoExtensions = ['.mp4', '.m4v', '.webm', '.ogg', '.ogv', '.h264', '.avi', '.mov'];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\n\n/**\n * Set cross origin based detecting the url and the crossorigin\n * @param element - Element to apply crossOrigin\n * @param url - URL to check\n * @param crossorigin - Cross origin value to use\n * @memberof assets\n */\nexport function crossOrigin(element: HTMLImageElement | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n{\n    if (crossorigin === undefined && !url.startsWith('data:'))\n    {\n        element.crossOrigin = determineCrossOrigin(url);\n    }\n    else if (crossorigin !== false)\n    {\n        element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    }\n}\n\n/**\n * Preload a video element\n * @param element - Video element to preload\n */\nexport function preloadVideo(element: HTMLVideoElement): Promise<void>\n{\n    return new Promise((resolve, reject) =>\n    {\n        element.addEventListener('canplaythrough', loaded);\n        element.addEventListener('error', error);\n\n        element.load();\n\n        function loaded(): void\n        {\n            cleanup();\n            resolve();\n        }\n\n        function error(err: ErrorEvent): void\n        {\n            cleanup();\n            reject(err);\n        }\n\n        function cleanup(): void\n        {\n            element.removeEventListener('canplaythrough', loaded);\n            element.removeEventListener('error', error);\n        }\n    });\n}\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns The crossOrigin value to use (or empty string for none).\n * @memberof assets\n */\nexport function determineCrossOrigin(url: string, loc: Location = globalThis.location): string\n{\n    // data: and javascript: urls are considered same-origin\n    if (url.startsWith('data:'))\n    {\n        return '';\n    }\n\n    // default is window.location\n    loc ||= globalThis.location;\n\n    const parsedUrl = new URL(url, document.baseURI);\n\n    // if cross origin\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol)\n    {\n        return 'anonymous';\n    }\n\n    return '';\n}\n\n/**\n * A simple plugin to load video textures.\n *\n * You can pass VideoSource options to the loader via the .data property of the asset descriptor\n * when using Asset.load().\n * ```js\n * // Set the data\n * const texture = await Assets.load({\n *     src: './assets/city.mp4',\n *     data: {\n *         preload: true,\n *         autoPlay: true,\n *     },\n * });\n * ```\n * @memberof assets\n */\nexport const loadVideoTextures = {\n\n    name: 'loadVideo',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        name: 'loadVideo',\n    },\n\n    test(url: string): boolean\n    {\n        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n        const isValidExtension = checkExtension(url, validVideoExtensions);\n\n        return isValidDataUrl || isValidExtension;\n    },\n\n    async load(url: string, asset: ResolvedAsset<VideoSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        // --- Merge default and provided options ---\n        const options: VideoSourceOptions = {\n            ...VideoSource.defaultOptions,\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n            ...asset.data,\n        };\n\n        // --- Create and configure HTMLVideoElement ---\n        const videoElement = document.createElement('video');\n\n        // Set attributes based on options\n        const attributeMap = {\n            preload: options.autoLoad !== false ? 'auto' : undefined,\n            'webkit-playsinline': options.playsinline !== false ? '' : undefined,\n            playsinline: options.playsinline !== false ? '' : undefined,\n            muted: options.muted === true ? '' : undefined,\n            loop: options.loop === true ? '' : undefined,\n            autoplay: options.autoPlay !== false ? '' : undefined\n        };\n\n        Object.keys(attributeMap).forEach((key) =>\n        {\n            const value = attributeMap[key as keyof typeof attributeMap];\n\n            if (value !== undefined) videoElement.setAttribute(key, value);\n        });\n\n        if (options.muted === true)\n        {\n            videoElement.muted = true;\n        }\n\n        crossOrigin(videoElement, url, options.crossorigin); // Assume crossOrigin is globally available\n\n        // --- Set up source and MIME type ---\n        const sourceElement = document.createElement('source');\n\n        // Determine MIME type\n        let mime: string | undefined;\n\n        if (url.startsWith('data:'))\n        {\n            mime = url.slice(5, url.indexOf(';'));\n        }\n        else if (!url.startsWith('blob:'))\n        {\n            const ext = url.split('?')[0].slice(url.lastIndexOf('.') + 1).toLowerCase();\n\n            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n        }\n\n        sourceElement.src = url;\n\n        if (mime)\n        {\n            sourceElement.type = mime;\n        }\n\n        // this promise will make sure that video is ready to play - as in we have a valid width, height and it can be\n        // uploaded to the GPU. Our textures are kind of dumb now, and don't want to handle resizing right now.\n        return new Promise((resolve) =>\n        {\n            const onCanPlay = async () =>\n            {\n                const base = new VideoSource({ ...options, resource: videoElement });\n\n                videoElement.removeEventListener('canplay', onCanPlay);\n\n                if (asset.data.preload)\n                {\n                    await preloadVideo(videoElement);\n                }\n\n                resolve(createTexture(base, loader, url));\n            };\n\n            videoElement.addEventListener('canplay', onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} satisfies LoaderParser<Texture, VideoSourceOptions>;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Resolver } from '../Resolver.mjs';\nimport { resolveTextureUrl } from './resolveTextureUrl.mjs';\n\n\"use strict\";\nconst resolveJsonUrl = {\n  extension: {\n    type: ExtensionType.ResolveParser,\n    priority: -2,\n    name: \"resolveJson\"\n  },\n  test: (value) => Resolver.RETINA_PREFIX.test(value) && value.endsWith(\".json\"),\n  parse: resolveTextureUrl.parse\n};\n\nexport { resolveJsonUrl };\n//# sourceMappingURL=resolveJsonUrl.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Resolver } from '../Resolver';\nimport { resolveTextureUrl } from './resolveTextureUrl';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a json urls resolution for spritesheets\n * e.g. `assets/spritesheet@1x.json`\n * @memberof assets\n */\nexport const resolveJsonUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        priority: -2,\n        name: 'resolveJson',\n    },\n    test: (value: string): boolean =>\n        Resolver.RETINA_PREFIX.test(value) && value.endsWith('.json'),\n    parse: resolveTextureUrl.parse,\n} satisfies ResolveURLParser;\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures.mjs';\nimport { Resolver } from '../Resolver.mjs';\n\n\"use strict\";\nconst resolveTextureUrl = {\n  extension: {\n    type: ExtensionType.ResolveParser,\n    name: \"resolveTexture\"\n  },\n  test: loadTextures.test,\n  parse: (value) => ({\n    resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n    format: value.split(\".\").pop(),\n    src: value\n  })\n};\n\nexport { resolveTextureUrl };\n//# sourceMappingURL=resolveTextureUrl.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures';\nimport { Resolver } from '../Resolver';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a texture url\n * @memberof assets\n */\nexport const resolveTextureUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        name: 'resolveTexture',\n    },\n    test: loadTextures.test,\n    parse: (value: string) =>\n        ({\n            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} satisfies ResolveURLParser;\n","import { AbstractText, ensureOptions } from './AbstractText.mjs';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics.mjs';\nimport { TextStyle } from './TextStyle.mjs';\n\n\"use strict\";\nclass Text extends AbstractText {\n  constructor(...args) {\n    const options = ensureOptions(args, \"Text\");\n    super(options, TextStyle);\n    this.renderPipeId = \"text\";\n  }\n  /** @private */\n  updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const canvasMeasurement = CanvasTextMetrics.measureText(\n      this._text,\n      this._style\n    );\n    const { width, height } = canvasMeasurement;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n}\n\nexport { Text };\n//# sourceMappingURL=Text.mjs.map\n","import { AbstractText, ensureOptions } from './AbstractText';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics';\nimport { TextStyle } from './TextStyle';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from './AbstractText';\nimport type { TextStyleOptions } from './TextStyle';\n\n/**\n * A Text Object will create a line or multiple lines of text.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and givae the `wordWrapWidth` property a value.\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n * @example\n * import { Text } from 'pixi.js';\n *\n * const text = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n * @memberof scene\n */\nexport class Text\n    extends AbstractText<TextStyle, TextStyleOptions>\n    implements View\n{\n    public override readonly renderPipeId: string = 'text';\n\n    /**\n     * @param {text.TextOptions} options - The options of the text.\n     */\n    constructor(options?: TextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<TextStyle>);\n    constructor(...args: [TextOptions?] | [TextString, Partial<TextStyle>])\n    {\n        const options = ensureOptions(args, 'Text');\n\n        super(options, TextStyle);\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const bounds = this._bounds;\n        const anchor = this._anchor;\n\n        const canvasMeasurement = CanvasTextMetrics.measureText(\n            this._text,\n            this._style\n        );\n\n        const { width, height } = canvasMeasurement;\n\n        bounds.minX = (-anchor._x * width);\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * height);\n        bounds.maxY = bounds.minY + height;\n    }\n}\n","import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../view/ViewContainer.mjs';\n\n\"use strict\";\nclass AbstractText extends ViewContainer {\n  constructor(options, styleClass) {\n    const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n    super({\n      ...rest\n    });\n    this.batched = true;\n    this._resolution = null;\n    this._autoResolution = true;\n    this._didTextUpdate = true;\n    this._styleClass = styleClass;\n    this.text = text ?? \"\";\n    this.style = style;\n    this.resolution = resolution ?? null;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor)\n      this.anchor = anchor;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from 'pixi.js';\n   *\n   * const text = new Text('hello world');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** Set the copy for the text object. To split a line you can use '\\n'. */\n  set text(value) {\n    value = value.toString();\n    if (this._text === value)\n      return;\n    this._text = value;\n    this.onViewUpdate();\n  }\n  get text() {\n    return this._text;\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   * @default 1\n   */\n  set resolution(value) {\n    this._autoResolution = value === null;\n    this._resolution = value;\n    this.onViewUpdate();\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  get style() {\n    return this._style;\n  }\n  /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */\n  set style(style) {\n    style || (style = {});\n    this._style?.off(\"update\", this.onViewUpdate, this);\n    if (style instanceof this._styleClass) {\n      this._style = style;\n    } else {\n      this._style = new this._styleClass(style);\n    }\n    this._style.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this.bounds.width;\n  }\n  set width(value) {\n    this._setWidth(value, this.bounds.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this.bounds.height;\n  }\n  set height(value) {\n    this._setHeight(value, this.bounds.height);\n  }\n  /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this.bounds.width;\n    out.height = Math.abs(this.scale.y) * this.bounds.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this.bounds.width);\n    height !== void 0 && this._setHeight(height, this.bounds.height);\n  }\n  /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this.bounds.width;\n    const height = this.bounds.height;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (point.y >= y1 && point.y <= y1 + height)\n        return true;\n    }\n    return false;\n  }\n  onViewUpdate() {\n    if (!this.didViewUpdate)\n      this._didTextUpdate = true;\n    super.onViewUpdate();\n  }\n  _getKey() {\n    return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n  }\n  /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this.owner = null;\n    this._bounds = null;\n    this._anchor = null;\n    if (typeof options === \"boolean\" ? options : options?.style) {\n      this._style.destroy(options);\n    }\n    this._style = null;\n    this._text = null;\n  }\n}\nfunction ensureOptions(args, name) {\n  let options = args[0] ?? {};\n  if (typeof options === \"string\" || args[1]) {\n    deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n    options = {\n      text: options,\n      style: args[1]\n    };\n  }\n  return options;\n}\n\nexport { AbstractText, ensureOptions };\n//# sourceMappingURL=AbstractText.mjs.map\n","import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { ViewContainer } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HTMLTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @memberof text\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * @memberof text\n * @see text.TextStyle\n * @see text.HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * @memberof text\n * @see text.TextStyleOptions\n * @see text.HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for the {@link scene.Text} class.\n * @example\n * const text = new Text({\n *    text: 'Hello Pixi!',\n *    style: {\n *       fontFamily: 'Arial',\n *       fontSize: 24,\n *    fill: 0xff1010,\n *    align: 'center',\n *  }\n * });\n * @memberof text\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ContainerOptions\n{\n    /** The anchor point of the text. */\n    anchor?: PointData | number;\n    /** The copy for the text object. To split a line you can use '\\n'. */\n    text?: TextString;\n    /** The resolution of the text. */\n    resolution?: number;\n    /**\n     * The text style\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see scene.Text\n * @see scene.BitmapText\n * @see scene.HTMLText\n * @memberof scene\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ViewContainer implements View\n{\n    public batched = true;\n    public _anchor: ObservablePoint;\n\n    public _resolution: number = null;\n    public _autoResolution: boolean = true;\n\n    public _style: TEXT_STYLE;\n    public _didTextUpdate = true;\n\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Text } from 'pixi.js';\n     *\n     * const text = new Text('hello world');\n     * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    set resolution(value: number)\n    {\n        this._autoResolution = value === null;\n        this._resolution = value;\n        this.onViewUpdate();\n    }\n\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style ||= {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Text.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this.bounds.width);\n        height !== undefined && this._setHeight(height, this.bounds.height);\n    }\n\n    /**\n     * Checks if the text contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public override onViewUpdate()\n    {\n        if (!this.didViewUpdate) this._didTextUpdate = true;\n        super.onViewUpdate();\n    }\n\n    public _getKey(): string\n    {\n        return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n    }\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n     * @param {boolean} [options.style=false] - Should it destroy the style of the text\n     */\n    public override destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n}\n\nexport function ensureOptions<\n    TEXT_STYLE extends TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions\n>(\n    args: any[],\n    name: string\n): TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>\n{\n    let options = (args[0] ?? {}) as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n    }\n\n    return options;\n}\n","import { Application } from \"pixi.js\";\r\nimport { ReelManager } from \"./reelManager\";\r\nimport { ResourceManager } from \"./resourceManager\";\r\nimport { ReelConfig } from \"./types\";\r\nimport { SymbolManager } from \"./symbolManager\";\r\nimport { UIManager } from \"./uiManager\";\r\n\r\nexport class Game {\r\n    protected _resourceManager: ResourceManager;\r\n    protected _symbolManager: SymbolManager;\r\n    protected _reelManager: ReelManager;\r\n    protected _uiManager: UIManager;\r\n\r\n    protected _isRunning: boolean = false;\r\n\r\n    constructor(pixiApp: Application, reelConfig: ReelConfig) {\r\n        this._resourceManager = new ResourceManager();\r\n        this._symbolManager = new SymbolManager();\r\n        this._reelManager = new ReelManager(reelConfig, pixiApp, this._symbolManager);\r\n        this._uiManager = new UIManager(pixiApp);\r\n    }\r\n\r\n    public async init() {\r\n        await this._resourceManager.init();\r\n        this._reelManager.init();\r\n\r\n        // add callback for spin\r\n        this._uiManager.init(() => {\r\n            if ( this._isRunning ) return;\r\n            this._isRunning = true;\r\n            this._reelManager.start(() => this._isRunning = false);\r\n        });\r\n    }\r\n}","import { Application, Container } from \"pixi.js\";\r\nimport { Reel, ReelConfig, ReelTween } from \"./types\";\r\nimport { SymbolManager, symbolMap } from \"./symbolManager\";\r\n\r\nexport class ReelManager {\r\n    protected _reels: Reel[] = [];\r\n    protected _tweening: ReelTween[] = [];\r\n\r\n    constructor(\r\n        protected _reelConfig: ReelConfig,\r\n        protected _pixiApp: Application,\r\n        protected _symbolManager: SymbolManager\r\n    ) { }\r\n\r\n    public init(): void {\r\n        this.initReels();\r\n        this.initTicker();\r\n    }\r\n\r\n    public start(endCallback: Function): void {\r\n        for (let i = 0; i < this._reels.length; i++) {\r\n            const reel = this._reels[i];\r\n            const target = reel.position + 10 + i * 5;\r\n            const time = 1000 + i * 300;\r\n\r\n            this.tweenTo(\r\n                reel,\r\n                reel.position,\r\n                target,\r\n                time,\r\n                backout(0.5),\r\n                i === this._reelConfig.reel - 1 ?\r\n                    () => { endCallback() } :\r\n                    null);\r\n        }\r\n    }\r\n\r\n    protected initReels(): void {\r\n        // Build the reels\r\n        const reelsContainer = new Container();\r\n\r\n        for (let i = 0; i < this._reelConfig.reel; i++) {\r\n            const reelContainer = new Container();\r\n\r\n            reelContainer.x = i * this._reelConfig.reelWidth;\r\n            reelContainer.y = this._reelConfig.symbolSize;\r\n            reelsContainer.addChild(reelContainer);\r\n\r\n            const reel: Reel = {\r\n                symbols: [],\r\n                container: reelContainer,\r\n                position: 0\r\n            };\r\n\r\n            // Build the symbols, last row is bumper symbol\r\n            for (let j = 0; j < this._reelConfig.row + 1; j++) {\r\n\r\n                const randomSymbolId = getRandomSymbolId();\r\n                const symbol = this._symbolManager.createSymbol(randomSymbolId);\r\n                symbol.y = j * this._reelConfig.symbolSize;\r\n                reelContainer.addChild(symbol.container);\r\n                reel.symbols.push(symbol);\r\n            }\r\n\r\n            this._reels.push(reel);\r\n        }\r\n\r\n        this._pixiApp.stage.addChild(reelsContainer);\r\n\r\n        const marginTop = 200;\r\n        const reelsWidth = this._reelConfig.reelWidth * this._reelConfig.reel;\r\n\r\n        reelsContainer.y = marginTop - this._reelConfig.symbolSize / 2;\r\n        reelsContainer.x = this._pixiApp.screen.width / 2 - reelsWidth / 2 + this._reelConfig.symbolSize / 2;\r\n\r\n    }\r\n\r\n    protected initTicker(): void {\r\n        // Listen for animate update.\r\n        this._pixiApp.ticker.add(() => {\r\n\r\n            // reel tweener\r\n            const now = Date.now();\r\n            const remove = [];\r\n\r\n            for (let i = 0; i < this._tweening.length; i++) {\r\n                const tween = this._tweening[i];\r\n                const phase = Math.min(1, (now - tween.start) / tween.time);\r\n\r\n                tween.reel.position = lerp(tween.value, tween.target, tween.easing(phase));\r\n\r\n                if (phase === 1) {\r\n                    tween.reel.position = tween.target;\r\n                    if (tween.complete) tween.complete(tween);\r\n                    remove.push(tween);\r\n                }\r\n            }\r\n            for (let i = 0; i < remove.length; i++) {\r\n                this._tweening.splice(this._tweening.indexOf(remove[i]), 1);\r\n            }\r\n\r\n\r\n            // Update the slots.\r\n            for (let i = 0; i < this._reels.length; i++) {\r\n                const reel = this._reels[i];\r\n\r\n                // Update symbol positions on reel.\r\n                for (let j = 0; j < reel.symbols.length; j++) {\r\n                    const symbol = reel.symbols[j];\r\n                    const prevy = symbol.y;\r\n\r\n                    symbol.y = ((reel.position + j) % reel.symbols.length) * this._reelConfig.symbolSize - this._reelConfig.symbolSize;\r\n                    if (symbol.y < 0 && prevy > this._reelConfig.symbolSize) {\r\n                        symbol.setSymbol(getRandomSymbolId())\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    protected tweenTo(\r\n        reel: Reel,\r\n        value: number,\r\n        target: number,\r\n        time: number,\r\n        easing: (t: number) => number,\r\n        oncomplete: Function | null\r\n    ): void {\r\n        const tween: ReelTween = {\r\n            reel,\r\n            value,\r\n            target,\r\n            easing,\r\n            time,\r\n            complete: oncomplete,\r\n            start: Date.now(),\r\n        };\r\n\r\n        this._tweening.push(tween);\r\n    }\r\n}\r\n\r\n\r\n// Basic lerp funtion.\r\nfunction lerp(a1: number, a2: number, t: number): number {\r\n    return a1 * (1 - t) + a2 * t;\r\n}\r\n\r\n// Backout function from tweenjs.\r\n// https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js\r\nfunction backout(amount: number) {\r\n    return (t: number) => --t * t * ((amount + 1) * t + amount) + 1;\r\n}\r\n\r\nfunction getRandomSymbolId(): number {\r\n    return Math.floor(Math.random() * Object.keys(symbolMap).length);\r\n}","import { Symbol } from \"./symbol\";\r\n\r\nexport const symbolMap: { [key: number] : string } = {\r\n    0: '9',\r\n    1: '10',\r\n    2: 'J',\r\n    3: 'Q',\r\n    4: 'K',\r\n    5: 'A',\r\n    6: 'M1',\r\n    7: 'M2',\r\n    8: 'M3',\r\n    9: 'M4',\r\n    10: 'M5',\r\n    11: 'H1',\r\n    12: 'H2',\r\n    13: 'H3',\r\n    14: 'H4',\r\n    15: 'H5'\r\n}\r\n\r\nexport class SymbolManager {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    public createSymbol(symbolId: number): Symbol {\r\n        return new Symbol(symbolId);\r\n    }\r\n}","import { Container, Sprite, Texture } from \"pixi.js\";\r\nimport { getTextureByName } from \"./resourceManager\";\r\nimport { symbolMap } from \"./symbolManager\";\r\n\r\nexport class Symbol {\r\n\r\n    protected _container: Container;\r\n    protected _mainTexture: Texture = new Texture();\r\n    protected _winTexture: Texture = new Texture();\r\n    protected _sprite: Sprite = new Sprite();\r\n\r\n    constructor(public _id: number) {\r\n        this._container = new Container();\r\n        this.initTextures();\r\n    }\r\n\r\n    public get container(): Container {\r\n        return this._container;\r\n    }\r\n\r\n    public get x(): number {\r\n        return this._container.x;\r\n    }\r\n\r\n    public get y(): number {\r\n        return this._container.y;\r\n    }\r\n\r\n    public set x(x: number) {\r\n        this._container.x = x;\r\n    }\r\n\r\n    public set y(y: number) {\r\n        this._container.y = y;\r\n    }\r\n\r\n    public setSymbol(symbolId: number) {\r\n        this._id = symbolId;\r\n        this.setTextures();\r\n    }\r\n\r\n    public win(): void {\r\n        this._sprite.texture = this._winTexture;\r\n    }\r\n\r\n    public stop(): void {\r\n        this._sprite.texture = this._mainTexture;\r\n    }\r\n\r\n    protected initTextures(): void {\r\n        this.setTextures();\r\n        this._sprite.anchor = 0.5;\r\n        this._container.addChild(this._sprite);        \r\n        this._container.scale = 0.5;\r\n    }\r\n\r\n    protected setTextures(): void {\r\n        const symbolName = symbolMap[this._id];\r\n        this._mainTexture = Texture.from(getTextureByName(symbolName));\r\n        this._winTexture = Texture.from(getTextureByName(symbolName, true));\r\n        this._sprite.texture = this._mainTexture;\r\n    }\r\n}","import { Assets } from \"pixi.js\";\r\nimport { symbolMap } from \"./symbolManager\";\r\n\r\nexport function getTextureByName(name: string, connect: boolean = false): string {\r\n    return `./${name}${connect ? '_connect' : ''}.png`\r\n}\r\n\r\nexport class ResourceManager {\r\n    public async init(): Promise<Record<string, any>> {\r\n        let assetsNames: string[] = [];\r\n\r\n        Object.values(symbolMap).forEach(symbolName => {\r\n            assetsNames.push(\r\n                getTextureByName(symbolName),\r\n                getTextureByName(symbolName, true)\r\n            )\r\n        });\r\n        \r\n        return await Assets.load(assetsNames);\r\n    }\r\n}\r\n","import { Application, Graphics, Text, TextStyle } from \"pixi.js\";\r\n\r\nexport class UIManager {\r\n    constructor(protected _pixiApp: Application) {\r\n\r\n    }\r\n\r\n    public init(spinCallback: () => void): void {\r\n        const marginTop = 200;\r\n        const top = new Graphics().rect(0, 0, this._pixiApp.screen.width, marginTop).fill({ color: 0x0 });\r\n        const bottom = new Graphics().rect(0, 0, this._pixiApp.screen.width, marginTop).fill({ color: 0x0 });\r\n        bottom.y = 500;\r\n\r\n        this._pixiApp.stage.addChild(top);\r\n        this._pixiApp.stage.addChild(bottom);\r\n\r\n        const style = new TextStyle({\r\n            fontFamily: 'Arial',\r\n            fontSize: 36,\r\n            fontWeight: 'bold',\r\n            fill: 0xffffff,\r\n        });\r\n\r\n        // Header\r\n        const headerText = new Text('AvatarUX Test', style);\r\n        headerText.x = Math.round((top.width - headerText.width) / 2);\r\n        headerText.y = Math.round((marginTop - headerText.height) / 2);\r\n        top.addChild(headerText);\r\n\r\n        // Spin Button\r\n        const playText = new Text('Spin', style);\r\n        playText.x = Math.round((bottom.width - playText.width) / 2);\r\n        playText.y = 20;\r\n        bottom.addChild(playText);\r\n\r\n        bottom.eventMode = 'static';\r\n        bottom.cursor = 'pointer';\r\n        bottom.addListener('pointerdown', () => {\r\n            spinCallback();\r\n        });\r\n    }\r\n}"],"names":["$6aefe7eac43bec6d$var$_isWebGLSupported","$2fd62251d0455c2b$var$_isWebGPUSupported","$87b21a3c09db871d$var$MAX_WORKERS","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$ef7689007096c8a0$export$6503ec6e8aabbaf","$ef7689007096c8a0$export$f7ad0328861e2f03","$ef7689007096c8a0$var$mapping","Map","baseUrl","manifest","i","length","path","resolved","URL","toString","$c8c99521170b225f$export$4f037c6ec2da4eeb","$c8c99521170b225f$export$cc3e2d3244e01b7f","ExtensionType2","$c8c99521170b225f$var$normalizeExtension","ext","extension","type","ref","$c8c99521170b225f$export$ba4241979983e013","defaultPriority","priority","_addHandlers","_removeHandlers","_queue","remove","extensions2","map","forEach","add","handlers","queue","push","handle","onAdd","onRemove","addHandlers","removeHandlers","handleByMap","name","handleByNamedList","findIndex","item","value","sort","b","index","splice","handleByList","list","includes","indexOf","$hffE7","Promise","all","then","resolve","$kFA6i","$hMWwR","$6yBjn","$c9Hg5","$eiaM4","$9HCqA","$hRHFw","$9QDRe","extensions","AlphaMask","ColorMask","StencilMask","VideoSource","ImageSource","CanvasSource","BufferImageSource","$0b3ed93070685547$export$3c32667be409917c","$6NgLT","$7tYoJ","$ey5hm","constructor","options","inverse","pipe","mask","renderMaskToTexture","Sprite","renderable","includeInBuild","measurable","reset","addBounds","bounds","skipUpdateTransform","addMaskBounds","addLocalBounds","localRoot","addMaskLocalBounds","containsPoint","point","hitTestFn","destroy","test","ExtensionType","MaskEffect","$ba0fb74591e28f6d$export$3075603db8e6204c","$dq7e0","$4YnyE","$04UFt","$aCdt0","$4ndcs","ViewContainer","Texture","EMPTY","texture","anchor","roundPixels","width","height","rest","label","renderPipeId","batched","_visualBounds","minX","maxX","minY","maxY","_anchor","ObservablePoint","_onUpdate","onViewUpdate","defaultAnchor","allowChildren","from","source","skipCache","currentTexture","_texture","dynamic","off","on","_width","_setWidth","orig","_height","_setHeight","visualBounds","updateQuadBounds","sourceBounds","deprecation","updateBounds","_bounds","_x","_y","destroyTextureSource","textureSource","copyFrom","Math","abs","scale","x","y","getSize","out","setSize","$ffac4789f4a1c62b$export$3755aaad3fd42e52","observer","_observer","clone","p","copyTo","equals","$4b15df50dcdad398$export$5431306cf43de24a","$6p5EE","$bvDrV","$ec4lc","$fTJzX","$87q4u","$3dWsL","$aDwba","frame","trim","defaultBorders","rotate","uid","uvs","x0","y0","x1","y1","x2","y2","x3","y3","Rectangle","noFrame","isTexture","TextureSource","_source","destroyed","updateUvs","update","emit","textureMatrix","_textureMatrix","TextureMatrix","nX","nY","nW","nH","w2","h2","cX","cY","groupD8","NW","uX","uY","destroySource","removeAllListeners","baseTexture","v8_0_0","NOOP","WHITE","resource","Uint8Array","alphaMode","$4a9976ca6ebf6735$var$has","prototype","hasOwnProperty","$4a9976ca6ebf6735$var$prefix","$4a9976ca6ebf6735$var$Events","$4a9976ca6ebf6735$var$EE","fn","context","once","$4a9976ca6ebf6735$var$addListener","emitter","event","TypeError","listener","evt","_events","_eventsCount","$4a9976ca6ebf6735$var$clearEvent","$4a9976ca6ebf6735$var$EventEmitter","create","__proto__","eventNames","events","names","slice","getOwnPropertySymbols","concat","listeners","l","ee","Array","listenerCount","a1","a2","a3","a4","a5","args","len","arguments","removeListener","undefined","apply","j","addListener","prefixed","EventEmitter","$337e48ae514d7a47$export$b7bb6a2a8d203102","$0kbcf","$337e48ae514d7a47$var$ux","$337e48ae514d7a47$var$uy","$337e48ae514d7a47$var$vx","$337e48ae514d7a47$var$vy","$337e48ae514d7a47$var$rotationCayley","$337e48ae514d7a47$var$rotationMatrices","$337e48ae514d7a47$var$signum","sign","$337e48ae514d7a47$var$init","row","_ux","_uy","_vx","_vy","k","mat","Matrix","E","SE","S","SW","W","N","NE","MIRROR_VERTICAL","MAIN_DIAGONAL","MIRROR_HORIZONTAL","REVERSE_DIAGONAL","ind","vX","vY","inv","rotation","rotationSecond","rotationFirst","sub","rotate180","isVertical","byDirection","dx","dy","matrixAppendRotationInv","matrix","tx","ty","append","$95b114128aa969d0$export$5b12bf1653c0dd85","$c3fGK","$hbjPo","c","d","array","fromArray","toArray","transpose","Float32Array","pos","newPos","Point","applyInverse","translate","angle","cos","sin","c1","tx1","b1","d1","appendFrom","b2","c2","d2","setTransform","pivotX","pivotY","scaleX","scaleY","skewX","skewY","prepend","decompose","transform","pivot","atan2","delta","PI_2","skew","sqrt","position","invert","isIdentity","identity","IDENTITY","$95b114128aa969d0$var$identityMatrix","shared","$95b114128aa969d0$var$tempMatrix","$0e5495c98c03d570$export$59ed0a0a5de1084b","$0e5495c98c03d570$export$3f91627dc85c5d57","$0e5495c98c03d570$export$870617f62e3187f1","PI","$55bdd69a4fa64f9d$export$baf26146a414f24a","$55bdd69a4fa64f9d$var$tempPoint","$ce149bca869fe98f$export$4617fb02663045ef","$ce149bca869fe98f$var$tempPoints","Number","left","right","top","bottom","isEmpty","copyFromBounds","rectangle","contains","strokeContains","strokeWidth","alignment","strokeWidthOuter","strokeWidthInner","intersects","other","x02","x12","y02","y12","lt","lb","rt","rb","max","min","nx","ny","n00","n10","n01","n11","mx","my","m00","m10","m01","m11","pad","paddingX","paddingY","fit","ceil","resolution","eps","floor","enlarge","getBounds","$e72449b3eae4b368$export$e2a22331486dcca0","$e72449b3eae4b368$var$uidCache","$2e9be43e91eceed5$export$dc79da96439604f0","$2e9be43e91eceed5$export$e88af00f5d3e8bcc","$2e9be43e91eceed5$export$afd31d834b512e89","$2e9be43e91eceed5$var$warnings","version","message","ignoreDepth","stack","console","warn","split","join","groupCollapsed","groupEnd","$e74451cf129b5abc$export$5702a91a6f42969f","$7a8074626802e18f$export$1872462350fcb7cd","buffer","format","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","uploadMethodId","Uint8ClampedArray","$3d8d2c0928be477e$export$8498e6a2e655d3d8","$7qPGY","$exB5W","$9lBUA","$3d8d2c0928be477e$var$_TextureSource","_TextureSource","_resourceType","_resourceId","_resolution","pixelWidth","pixelHeight","sampleCount","mipLevelCount","autoGenerateMipmaps","dimension","antialias","_touched","_batchTick","_textureBindLocation","defaultOptions","autoGarbageCollect","resourceWidth","resourceHeight","dimensions","style","TextureStyle","definedProps","_refreshPOT","_style","_onStyleChange","addressMode","repeatMode","magFilter","minFilter","mipmapFilter","lodMinClamp","lodMaxClamp","resize","unload","naturalWidth","videoWidth","displayWidth","naturalHeight","videoHeight","displayHeight","newPixelWidth","round","newPixelHeight","updateMipmaps","wrapMode","scaleMode","isPowerOfTwo","isPow2","_resource","$986fb9110aa90cb3$export$f0d90cf68bd426eb","$986fb9110aa90cb3$export$eb50b9c078eb6ae7","$b011cb4bb21573b4$export$801feaffb936a09d","obj","result","key","$90a34299e1fe538e$export$1ce1d0c10d3de5d5","$90a34299e1fe538e$var$idHash","$90a34299e1fe538e$var$_TextureStyle","_TextureStyle","_maxAnisotropy","addressModeU","addressModeV","addressModeW","compare","maxAnisotropy","_sharedResourceId","_generateResourceId","bigKey","$90a34299e1fe538e$var$createResourceIdFromString","$57b4ac32d55b0fe4$export$dbea3135e9da48cb","$57b4ac32d55b0fe4$var$tempMat","clampMargin","mapCoord","uClampFrame","uClampOffset","_textureID","_updateID","clampOffset","isSimple","multiplyUvs","tex","texBase","margin","offset","$4941c1f3fc750b3e$export$558ce66aa5723f1d","sourceWidth","sourceHeight","$41020eb0c9bcc845$export$19fb617b96998849","$dtW0p","$gRXu9","Container","canBundle","_roundPixels","_lastUsed","Bounds","_boundsDirty","_didViewChangeTick","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","collectRenderablesSimple","instructionSet","renderer","currentLayer","renderPipes","renderableGC","blendMode","setBlendMode","groupBlendMode","rp","addRenderable","children","collectRenderables","$65a637ce5da3d941$export$c4e9d269599ab4b4","$65a637ce5da3d941$var$defaultMatrix","Infinity","_rectangle","clear","addFrame","addRect","rect","addBoundsMask","applyMatrix","fitBounds","isPositive","isValid","addVertexData","vertexData","beginOffset","endOffset","localX","localY","$2dde9d72d383d3dd$export$f8ede8d8bf091ab5","$2dde9d72d383d3dd$export$e4801e7edc7582f","$2dde9d72d383d3dd$export$83db162b74637ea","$2dde9d72d383d3dd$export$42a852a2b6b56249","$hFslp","$7tfc3","$dLv5L","$eURp4","$5XZI5","$8aDma","$fWc5r","$ggihy","$6OcmO","$h3CH0","$cVzTv","$b7mtY","$b2N3G","$knQy3","$2WbnL","$eSqzB","$2dde9d72d383d3dd$var$defaultSkew","$2dde9d72d383d3dd$var$defaultPivot","$2dde9d72d383d3dd$var$defaultScale","_updateFlags","parentRenderGroupIndex","didChange","relativeRenderGroupDepth","parent","updateTick","localTransform","relativeGroupTransform","groupTransform","_position","_scale","_pivot","_skew","_cx","_sx","_cy","_sy","_rotation","localColor","localAlpha","groupAlpha","groupColor","groupColorAlpha","localBlendMode","localDisplayStatus","globalDisplayStatus","_didContainerChangeTick","_didLocalTransformChangeId","effects","assignWithIgnore","child","addChild","mixin","defineProperties","getOwnPropertyDescriptors","_didChangeId","structureDidChange","removeChild","sortableChildren","sortDirty","_zIndex","depthOfChildModified","parentRenderLayer","detach","_updateSkew","onChildUpdate","isRenderGroup","enableRenderGroup","disableRenderGroup","BigPool","RenderGroup","_updateIsSimple","return","worldTransform","_worldTransform","RAD_TO_DEG","DEG_TO_RAD","getLocalBounds","localWidth","localHeight","size","updateTransform","opts","setFromMatrix","updateLocalTransform","localTransformChangeId","sx","sy","px","py","alpha","tint","bgr","tempColor","Color","setValue","toBgrNumber","bgr2rgb","visible","culled","isRenderable","oldChildren","removeChildren","removeFromParent","_maskEffect","_filterEffect","destroyChildren","childrenHelperMixin","getFastGlobalBoundsMixin","toLocalGlobalMixin","onRenderMixin","measureMixin","effectsMixin","findMixin","sortMixin","cullingMixin","cacheAsTextureMixin","getGlobalMixin","collectRenderablesMixin","$ce14d1440ee922b4$export$892596cec99bc70e","$hgnOi","$40ez6","extend","$ce14d1440ee922b4$var$_Color","_Color","_value","_components","fill","_int","red","green","blue","_cloneSource","_isSourceEqual","_normalize","isArray","ArrayBuffer","isView","value1","value2","type1","every","keys1","keys","keys2","toRgba","r","g","toRgb","toRgbaString","toUint8RgbArray","_arrayRgb","_arrayRgba","toRgbArray","toNumber","toLittleEndianNumber","multiply","_temp","_refreshInt","premultiply","applyToRGB","toPremultiplied","toHex","hexString","substring","toHexa","alphaString","alphaValue","setAlpha","_clamp","int","match","HEX_PATTERN","exec","color","colord","rgba","isColorLike","h","$44b44bc546a4a126$export$c8efe09109f9cb9e","$44b44bc546a4a126$export$8b58be045bf06082","$44b44bc546a4a126$var$r","grad","turn","rad","$44b44bc546a4a126$var$t","$44b44bc546a4a126$var$n","t","pow","$44b44bc546a4a126$var$e","$44b44bc546a4a126$var$u","isFinite","$44b44bc546a4a126$var$a","$44b44bc546a4a126$var$o","$44b44bc546a4a126$var$i","$44b44bc546a4a126$var$s","$44b44bc546a4a126$var$h","u","o","$44b44bc546a4a126$var$b","$44b44bc546a4a126$var$g","$44b44bc546a4a126$var$d","$44b44bc546a4a126$var$f","$44b44bc546a4a126$var$c","$44b44bc546a4a126$var$l","$44b44bc546a4a126$var$p","$44b44bc546a4a126$var$v","$44b44bc546a4a126$var$m","$44b44bc546a4a126$var$y","string","parseInt","substr","object","$44b44bc546a4a126$var$N","$44b44bc546a4a126$var$M","$44b44bc546a4a126$var$H","$44b44bc546a4a126$var$$","$44b44bc546a4a126$export$4d30ed660ff08d0","parsed","$44b44bc546a4a126$var$x","brightness","isDark","isLight","toRgbString","toHsl","toHslString","toHsv","saturate","desaturate","grayscale","lighten","darken","hue","isEqual","$44b44bc546a4a126$var$S","$cf19add7623c5dc6$export$2e2bcd8739ae039","f","white","bisque","cadetblue","chartreuse","chocolate","coral","antiquewhite","aqua","azure","whitesmoke","papayawhip","plum","blanchedalmond","black","gold","goldenrod","gainsboro","cornsilk","cornflowerblue","burlywood","aquamarine","beige","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkkhaki","darkgray","darkgreen","darkgrey","peachpuff","darkmagenta","darkred","darkorchid","darkorange","darkslateblue","gray","darkslategray","darkslategrey","deeppink","deepskyblue","wheat","firebrick","floralwhite","ghostwhite","darkviolet","magenta","dodgerblue","grey","honeydew","hotpink","blueviolet","forestgreen","lawngreen","indianred","indigo","fuchsia","brown","maroon","mediumblue","lightcoral","darkturquoise","lightcyan","ivory","lightyellow","lightsalmon","lightseagreen","linen","mediumaquamarine","lemonchiffon","lime","khaki","mediumseagreen","limegreen","mediumspringgreen","lightskyblue","lightblue","midnightblue","lightpink","mistyrose","moccasin","mintcream","lightslategray","lightslategrey","navajowhite","navy","mediumvioletred","powderblue","palegoldenrod","oldlace","paleturquoise","mediumturquoise","mediumorchid","rebeccapurple","lightsteelblue","mediumslateblue","thistle","tan","orchid","mediumpurple","purple","pink","skyblue","springgreen","palegreen","yellow","slateblue","lavenderblush","peru","palevioletred","violet","teal","slategray","slategrey","aliceblue","darkseagreen","darkolivegreen","greenyellow","seagreen","seashell","tomato","silver","sienna","lavender","lightgreen","orange","orangered","steelblue","royalblue","turquoise","yellowgreen","salmon","saddlebrown","sandybrown","rosybrown","darksalmon","lightgoldenrodyellow","snow","lightgrey","lightgray","dimgray","dimgrey","olivedrab","olive","toName","closest","toLowerCase","$baf6669d7bf5ea3c$export$dce76d4f0fd249ed","cullArea","cullable","cullableChildren","$489893e6d10c5383$export$8249372279066210","$h8Jx4","_poolsByClass","prepopulate","Class","total","classPool","getPool","data","pool","ClassType","has","Pool","stats","_classType","ID","free","totalFree","used","totalUsed","totalSize","$64b1c68c385378e9$export$14963ee5c8637e11","initialSize","_pool","_count","_index","$aca394a50e66740d$export$9660f593b1298e75","isCachedAsTexture","cacheAsTexture","val1","enableCacheAsTexture","updateCacheTexture","cacheAsBitmap","val","$4caa91b2de1a4670$export$64cca9f0c2df174a","$cGrD4","beginIndex","endIndex","end","range","removed","removeItems","RangeError","removeChildAt","getChildAt","setChildIndex","getChildIndex","addChildAt","currentIndex","swapChildren","child2","index1","index2","reparentChild","reparentChildAt","childMat","newMatrix","$cc86715a5454533e$export$8d47c0e1ce445404","arr","startIdx","removeCount","$b192be86e57e3f3d$export$e50be97f8cd670d0","sortChildren","addRenderGroup","collectRenderablesWithEffects","effect","pop","$2bf418dded26abfd$export$eec5e288a9d02a7c","$4kixb","$jYxJQ","_maskOptions","_markStructureAsChanged","addEffect","removeEffect","MaskEffectManager","returnMaskEffect","getMaskEffect","setMask","filters","FilterEffect","hasFilters","hadFilters","freeze","filterArea","$43a253ac8857703b$export$d66c06ffe23037ab","$0a1a5b6c8f3dafa1$export$1eb319167fe02d04","_effectClasses","_tests","_initialized","maskClass","$f6ff4915d88a2281$export$468b0762e1bfbd64","getChildByName","deep","getChildByLabel","RegExp","found","getChildrenByLabel","$25c6b62480252a55$export$993f17c9646405e3","$6cT41","$25c6b62480252a55$var$tempMatrix","getFastGlobalBounds","factorRenderLayers","_getGlobalBoundsRecursive","localBounds","manageEffects","boundsPool","boundsArea","viewBounds","advanced","$99c34bfe5b9aeddd$export$3849005ba4dacf72","$99c34bfe5b9aeddd$export$9194656040c1dc42","$30d4b960a98e31d7$export$110f9f26b10ddb4a","$30d4b960a98e31d7$export$c7c22dc0c465d95a","$71eSK","$8KIbM","getGlobalAlpha","skipUpdate","worldAlpha","current","getGlobalTransform","parentTransform","updateTransformBackwards","matrixPool","getGlobalTint","worldColor","multiplyColors","$52b40ad2e47511ad$export$f4412a6981d97baa","$52b40ad2e47511ad$export$2022bc48a49dd6d2","target","pooledMatrix","$52b40ad2e47511ad$export$ca70956e64971628","parentBounds","preserveBounds","$c36832d976b8765d$export$a82a3ae2e3118160","$goP77","localBGRColor","parentBGRColor","multiplyHexColors","$138f4e5b5df40592$export$815d7ea0395de72c","color1","color2","r1","g1","$6d18ce597b58af2d$export$285e6e72e8e62f0","$4316K","$5mqu4","$6d18ce597b58af2d$var$tempMatrix","_localBoundsCacheId","_localBoundsCacheData","localBoundsCacheData","checkChildrenDidChange","getGlobalBounds","$96a1f8bfb39ffa81$export$ffaf4f504c4c5c9c","relativeMatrix","$96a1f8bfb39ffa81$var$_getLocalBounds","rootContainer","isRoot","relativeTransform","$11b7177c8c78d236$export$c106dd0671a0fc2d","$11b7177c8c78d236$var$warnCount","$ed41ab72624317d2$export$fd5aadbd3827bcf1","container","previousData","$640f79b52c3d06e9$export$2a5246d1114cb81d","_onRender","onRender","func","removeOnRender","addOnRender","$63b0caf6b82b3b6e$export$eb4acdd9f4781aed","zIndex","$63b0caf6b82b3b6e$var$sortChildren","$c06aeab6644a02d4$export$38fa7a987602e8dd","getGlobalPosition","toGlobal","globalMatrix","toLocal","$492f7157f88f2b52$export$94d273f8d74f2a5","$9nXu5","$2zAQe","root","renderGroupParent","renderGroupChildren","worldColorAlpha","childrenToUpdate","gcTick","childrenRenderablesToUpdate","InstructionSet","_onRenderContainers","textureNeedsUpdate","_matrixDirty","textureOptions","disableCacheAsTexture","TexturePool","returnTexture","childrenAtDepth","addRenderGroupChild","renderGroupChild","_removeRenderGroupChild","updateRenderable","runOnRender","getChildren","_getChildren","invalidateMatrices","inverseWorldTransform","_inverseWorldTransform","textureOffsetInverseTransform","_textureOffsetInverseTransform","_textureBounds","inverseParentTextureTransform","_inverseParentTextureTransform","parentCacheAsTexture","_parentCacheAsTextureRenderGroup","cacheToLocalTransform","$fb419862fbc6d473$export$2946bd01f10dd922","instructions","instructionSize","renderables","instruction","log","table","$42bc20cf880db7b3$export$686d8ddcd5ee6cd2","$42bc20cf880db7b3$var$count","_poolKeyHash","_texturePool","enableFullScreen","createTexture","getOptimalTexture","frameWidth","frameHeight","po2Width","po2Height","nextPow2","getSameSizeTexture","renderTexture","destroyTextures","textures","$4387f8955fa34540$export$59d0441a278e5935","ignore","$c7cd9b90cecfc44d$export$12af48852c6ac574","$c7cd9b90cecfc44d$var$tempBounds","$a634088f289c5bfb$export$7416ac774b1f1a33","$c9aw6","boundsToMask","tempMatrix","relativeMask","$a634088f289c5bfb$export$1536bde1a0bf3cb9","$00b6ade177b7356f$export$1e2a2c76374c2542","$72f778d04e679ab7$export$abd85894695764cb","$10fc6e11e1e5c557$export$ca65ccf5708c6a0c","$d0V4H","DOMAdapter","createCanvas","autoDensity","resizeCanvas","transparent","didResize","HTMLCanvasElement","OffscreenCanvas","context2D","_context2D","getContext","$ddd3a207703846cf$export$d988306fa84f7b44","$ddd3a207703846cf$var$currentAdapter","$fR5mS","BrowserAdapter","adapter","$01603200690869e7$export$e467cc3399500025","canvas","document","createElement","getCanvasRenderingContext2D","CanvasRenderingContext2D","getWebGLRenderingContext","WebGLRenderingContext","getNavigator","navigator","getBaseUrl","baseURI","location","href","getFontFaceSet","fonts","fetch","url","parseXML","xml","parser","DOMParser","parseFromString","$5fe2d0b53155b128$export$280e9a68c3ffd919","HTMLImageElement","drawImage","ImageBitmap","VideoFrame","$1291ac6120483f91$export$f3a17123d80000c5","$k3VU1","$jQhdF","$1291ac6120483f91$var$_VideoSource","_VideoSource","isReady","_autoUpdate","_isConnectedToTicker","_updateFPS","updateFPS","_msToNextUpdate","autoPlay","_videoFrameRequestCallback","bind","_videoFrameRequestCallbackHandle","_load","_resolve","_reject","_onCanPlay","_onCanPlayThrough","_onError","_onPlayStart","_onPlayStop","_onSeeked","autoLoad","load","updateFrame","elapsedMS","Ticker","playbackRate","requestVideoFrameCallback","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","complete","addEventListener","_isSourceReady","_mediaReady","preload","detectVideoAlphaMode","reject","preloadTimeoutMs","_preloadTimeout","setTimeout","ErrorEvent","removeEventListener","_isSourcePlaying","paused","ended","_configureAutoUpdate","clearTimeout","play","pause","src","autoUpdate","cancelVideoFrameCallback","HTMLVideoElement","crossorigin","loop","muted","playsinline","MIME_TYPES","ogv","mov","m4v","$bc96cdd8749a7803$export$39c54bcc89dcee11","$dqvqc","$gsmTo","$bc96cdd8749a7803$var$_Ticker","_Ticker","autoStart","deltaTime","lastTime","speed","started","_requestId","_maxElapsedMS","_minElapsedMS","_protected","_lastFrame","_head","TickerListener","deltaMS","targetFPMS","_tick","time","next","requestAnimationFrame","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","UPDATE_PRIORITY","NORMAL","_addListener","addOnce","previous","connect","count","stop","currentTime","head","FPS","minFPS","fps","minFPMS","maxFPS","_shared","system","_system","$31c5039e1c9d5112$export$688aaf132ba9b379","UPDATE_PRIORITY2","$a0729dc3dd2f4c84$export$579021a5759a260f","_destroyed","_fn","_context","_once","ticker","redirect","hard","$0a777883e8dc2369$var$promise","$0a777883e8dc2369$export$8df68d58aae31877","gl","video","video2","onloadeddata","onerror","autoplay","crossOrigin","bindTexture","TEXTURE_2D","framebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","texImage2D","RGBA","UNSIGNED_BYTE","pixel","readPixels","deleteFramebuffer","deleteTexture","getExtension","loseContext","$6n8as","$bd3dd523c9bd39bd$var$sources","$bd3dd523c9bd39bd$var$textureSourceFrom","hasResource","res","Source","Cache","$bd3dd523c9bd39bd$export$3b748ed6327ec85b","$5e185831a7060818$export$94affb487e701bf2","$anknw","_parsers","_cache","_cacheMap","cacheableAssets","convertToList","parsers","getCacheableAssets","cacheableMap","entries","key2","cacheKeys","cachedAssets","cacheMap","delete","$9e74290aa41ef06d$export$b01be8e180bf3d9b","input","forceTransform","$a9cWg","spritesheetAsset","$4eef9ce476ca77e7$export$46dcda4f1cdd80fe","$4Gouu","$em7uH","$abXd6","$gOHW1","$dvQOG","$4eef9ce476ca77e7$var$validImages","Asset","cache","asset","Spritesheet","$4eef9ce476ca77e7$var$getCacheableAssets","ignoreMultiPack","basePath","dirname","linkedSheets","assign","meta","related_multi_packs","resolver","ResolveParser","tempURL","parse","parseFloat","Resolver","RETINA_PREFIX","loader","LoadParser","LoaderParserPriority","Normal","testParse","extname","frames","imageTexture","imageFilename","lastIndexOf","imagePath","copySearchParams","image","assets","spritesheet","multiPacks","promises","itemUrl","filter","sp","_resolvedAsset","_sourceOrigin","$98c7bf0715e5eba0$export$820ed6348c4f2750","LoaderParserPriority2","$18afcceb16531a4f$export$8b4c839865b08288","$c284d","$bBvqO","_defaultBundleIdentifierOptions","connector","createBundleAssetId","bundleId","assetId","_bundleIdConnector","extractAssetIdFromBundle","assetBundleId","replace","_createBundleAssetId","_extractAssetIdFromBundle","_assetMap","_preferredOrder","_resolverHash","_bundles","setBundleIdentifier","bundleIdentifier","prefer","preferOrders","params","_basePath","rootPath","_rootPath","_manifest","_defaultSearchParams","setDefaultSearchParams","searchParams","encodeURIComponent","queryValues","getAlias","alias","addManifest","bundles","bundle","addBundle","assetNames","convertedAssets","ids","srcs","aliases","bundleAssetId","bundleIds","keyCheck","hasKey","assetArray","loadParser","srcsToUse","src2","createStringVariations","aliasesToUse","resolvedAssets","formattedAsset","_buildResolvedAsset","resolveBundle","singleAsset","isSingleItem","results","resolveUrl","preferredOrder","_getPreferredOrder","priorityKey","filteredAssets","hasBundle","preferred","find","preference","_appendDefaultSearchParams","paramConnector","assetData","toAbsolute","shift","$843d7bf2b54bdd7d$export$bb654e07daaf8c3a","$843d7bf2b54bdd7d$var$assertPath","path2","JSON","stringify","$843d7bf2b54bdd7d$var$removeUrlParams","re","toPosix","str","isUrl","isDataUrl","isBlobUrl","startsWith","hasProtocol","getProtocol","matchFile","matchProtocol","customBaseUrl","customRootUrl","rootUrl","rootname","isAbsolute","normalize","protocol","trailingSeparator","endsWith","$843d7bf2b54bdd7d$var$normalizeStringPosix","allowAboveRoot","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","segments","joined","arg","prevArg","joinExtensions","hasRoot","matchedSlash","proto","origpath","basename","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","dir","base","sep","delimiter","$8c10bb5b06f25484$export$738117acc6638004","tags","vars","$8c10bb5b06f25484$var$processX","depth","$a9e658f99f1b9d1e$export$16a80d27953452d4","$300312e7105a88be$export$f57b97ef8be10dda","targetUrl","sourceUrl","$aee523b97dd2ab9f$export$674d2eb4debbef0c","$aee523b97dd2ab9f$var$_Spritesheet","_Spritesheet","animations","metaResolution","_frames","_frameKeys","_batchIndex","_callback","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","sourceSize","trimmed","w","rotated","spriteSourceSize","borders","animName","frameName","callback","destroyBase","$919233a2fae5198d$export$58ab3ed211eed562","$eYZeV","$bjxKI","$7gR5c","$4EOMD","$919233a2fae5198d$var$defaultRunners","$919233a2fae5198d$var$_AbstractRenderer","_AbstractRenderer","config","runners","_initOptions","_systemsHash","combinedRunners","_addRunners","_unsafeEvalCheck","skip","skipExtensionImports","manageImports","systemName","loadEnvironmentExtensions","_addSystems","systems","_addPipes","renderPipeAdaptors","items","render","deprecated","view","renderTarget","_lastObjectRendered","clearColor","background","colorRgba","clearBeforeRender","isRGBAArray","prerender","renderStart","renderEnd","postrender","desiredScreenWidth","desiredScreenHeight","previousResolution","screen","resolutionChange","CLEAR","ALL","lastObjectRendered","renderingToScreen","runnerIds","runnerId","SystemRunner","_addSystem","ClassRef","pipes","pipeAdaptors","adaptors","reduce","acc","adaptor","PipeClass","Adaptor","reverse","values","runner","generateTexture","textureGenerator","unsafeEvalSupported","resetState","failIfMajorPerformanceCaveat","$dfc22c56eea0b6b6$export$3b30260a318c769f","$dfc22c56eea0b6b6$var$environments","env","Environment","$c98ba44347fdd13b$var$unsafeEval","$c98ba44347fdd13b$export$70c0711f29adc5cf","Function","_e","$213211d020523f6c$export$6c4d37c7f376a1de","CLEAR2","$a9ab149507b541d6$export$ff5f2fe687fe3979","_name","a0","a6","a7","removeAll","empty","$7ebc6c78daad8ca3$export$918f3e4d2b801859","$7ebc6c78daad8ca3$export$5fba6e443d2fb64","$2wPJh","__PIXI_APP_INIT__","VERSION","Application","_renderer","__PIXI_RENDERER_INIT__","WebGLSystem","WebGPUSystem","$96ae7b02363e72a9$export$a4ad2735b021c132","$13872b1604cc36b4$export$d2ee57cdc0e1ed7f","$2oqF9","$1Fy2M","$c57nt","$8VyWJ","$13872b1604cc36b4$var$fontCount","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","chars","padding","skipKerning","getFont","text","fontFamilyKey","fontFamily","overrideFill","_fill","_stroke","styleKey","dropShadow","fnt","DynamicBitmapFont","overrideSize","dynamicFont","ensureCharacters","getLayout","trimEnd","bitmapFont","getBitmapTextLayout","measureText","install","textStyle","TextStyle","font","flatChars","resolveCharacters","uninstall","cacheKey","$3db57088bb20238a$export$1df879243bf2e42d","$faWAK","$iKeQS","$lfe2w","$jzyMN","$7oI6r","$3db57088bb20238a$var$_TextStyle","_TextStyle","$3db57088bb20238a$var$convertV7Tov8Style","oldStyle","defaults","defaultDropShadow","dropShadowAlpha","dropShadowAngle","blur","dropShadowBlur","dropShadowColor","distance","dropShadowDistance","strokeThickness","stroke","FillGradient","FillPattern","fillGradientStops","fontSize","defaultTextStyle","gradientFill","fills","number","ratio","addColorStop","fullStyle","align","_align","breakWords","_breakWords","_dropShadow","_createProxy","_fontFamily","_fontSize","fontStyle","_fontStyle","fontVariant","_fontVariant","fontWeight","_fontWeight","leading","_leading","letterSpacing","_letterSpacing","lineHeight","_lineHeight","_padding","_trim","textBaseline","_textBaseline","whiteSpace","_whiteSpace","wordWrap","_wordWrap","wordWrapWidth","_wordWrapWidth","_originalFill","_isFillStyle","GraphicsContext","defaultFillStyle","toFillStyle","_originalStroke","defaultStrokeStyle","toStrokeStyle","_generateKey","_styleKey","generateTextStyleKey","defaultStyle","cb","Proxy","property","newValue","$986bc8a8a4c2a5b3$export$722a6ea8c60ca86","$986bc8a8a4c2a5b3$var$_FillGradient","_FillGradient","gradientStops","buildLinearGradient","defaultSize","defaultTextureSize","ctx","gradient","createLinearGradient","fillStyle","fillRect","m","dist","stops","$4ebf970abba832e6$export$3d1378c7410cd8e","$4ebf970abba832e6$var$repetitionMap","repeat","repetition","$17adac14b4ad4eee$export$cde35afe8b5f985","$d32rq","$aplex","$17adac14b4ad4eee$var$tmpPoint","$17adac14b4ad4eee$var$tempMatrix","$17adac14b4ad4eee$var$_GraphicsContext","_GraphicsContext","dirty","batchMode","_activePath","GraphicsPath","_transform","_fillStyle","_strokeStyle","_stateStack","strokeStyle","setFillStyle","setStrokeStyle","dw","dh","action","onUpdate","beginPath","lastInstruction","_initNextPathLocation","getLastPoint","moveTo","cut","holePath","hole","addPath","arc","radius","startAngle","endAngle","counterclockwise","arcTo","arcToSvg","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","smoothness","closePath","ellipse","radiusX","radiusY","circle","lineTo","transformedX","transformedY","quadraticCurveTo","cpx","cpy","roundRect","poly","points","close","regularPoly","sides","roundPoly","corner","roundShape","useQuadratic","filletRect","fillet","chamferRect","chamfer","star","innerRadius","svg","SVGParser","restore","state","save","getTransform","resetTransform","outerPadding","hasHit","shapes","shapePath","shapePrimitives","shape","transformedPoint","holes","holeShapes","customShader","miterLimit","cap","pixelLine","$8f14847d3669f69c$export$7e54506375634c19","$f9kKY","$krLTT","_dirty","SVGToGraphicsPath","_shapePath","ShapePath","buildPath","bezierCurveToShort","last","lastPoint","currentX","currentY","quadraticCurveToShort","cpx1","cpy1","polygon","newGraphicsPath2D","cpx2","cpy2","$8f14847d3669f69c$var$adjustTransform","currentMatrix","$7a56f5fc0fada619$export$14a4a8042d02aa8d","$fcYjq","svgPath","commands","subpaths","currentSubPath","lastX","lastY","command","startX","startY","$b126c2cb4bd2f87c$var$segment","_","numbers","$b126c2cb4bd2f87c$var$number","$b126c2cb4bd2f87c$var$length","unshift","q","z","$137401cd8060a2ad$export$148534a3c727230b","$aXuc6","$dAKnc","$beTo1","$j2N26","$dVeJc","$7VTKT","$9HsoA","$iiH2h","$t0jfs","$97zsF","$137401cd8060a2ad$var$tempRectangle","graphicsPath2D","_currentPoly","_graphicsPath2D","startPoly","_ensurePoly","fromX","fromY","buildArc","buildArcTo","buildArcToSvg","currentPoly","buildAdaptiveBezier","smoothing","buildAdaptiveQuadratic","endPoly","finish","drawShape","Circle","Polygon","internalAngle","roundedShapeQuadraticCurve","roundedShapeArc","maxFillet","inset","Ellipse","RoundedRectangle","lastShape","lx","ly","tempX","shapePrimitive","boundsRect","$b67928a604dbb421$export$c89a927ffc67e6fa","r2","outerWidth","$604e3e1f5c82e53e$export$80b0269ab108fa11","halfWidth","halfHeight","normx","normy","strokeOuterWidth","strokeInnerWidth","innerHorizontal","innerVertical","outerHorizontal","outerVertical","normalizedX","normalizedY","innerEllipse","outerEllipse","$2dbc06dd0b1d055c$export$7d31b617c820d435","$4UUML","flat","il","inside","xi","yi","xj","yj","strokeWidthSquared","rightWidthSquared","leftWidthSquared","iterationLength","distanceSquared","squaredDistanceToLineSegment","pointsDesc","currentPoint","$e33a1a10321a9001$export$db32ff20ff695a","xx","yy","lenSq","param","dot","$709fb74830b2b0ca$export$d55ab2e3dc5a4263","$709fb74830b2b0ca$var$isCornerWithinStroke","pX","pY","cornerX","cornerY","radius2","innerX","innerY","innerWidth","innerHeight","rightBound","bottomBound","$2a5e53fd99b4041c$export$7dab5eac414ecba2","$inK6t","sX","sY","eX","eY","distanceTolerance","$2a5e53fd99b4041c$var$PATH_DISTANCE_EPSILON","GraphicsContextSystem","bezierSmoothness","$2a5e53fd99b4041c$var$recursive","x4","y4","level","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","d3","$c6470e81ca790c51$export$f2f3ca33e4c65172","$4ukOR","$c0cbH","$7gnh5","$c6470e81ca790c51$export$e3e348c254036d55","batches","geometryData","vertices","indices","$c6470e81ca790c51$export$9b6a6c5b37fc8f49","batcher","DefaultBatcher","geometry","v8_3_4","$c6470e81ca790c51$var$_GraphicsContextSystem","_GraphicsContextSystem","_gpuContextHash","_graphicsDataContextHash","addManagedHash","getContextRenderData","_initContextRenderData","updateGpuContext","gpuContext","_initContext","_cleanGraphicsContextData","buildContextBatches","isBatchable","getGpuContext","graphicsData","vertexSize","indexSize","applyTransform","ensureAttributeBuffer","ensureIndexBuffer","begin","batch","indexBuffer","setDataWithSize","buffers","attributeBuffer","float32View","attributeSize","drawBatches","bindGroup","getTextureBatchBindGroup","onGraphicsContextDestroy","CanvasSystem","$49422cac07553829$export$84c26df82650dc9b","$lc03N","$2nbUJ","$49422cac07553829$var$cachedGroups","imul","$49422cac07553829$var$generateTextureBatchBindGroup","bindGroupResources","bindIndex","$49422cac07553829$var$maxTextures","getMaxTexturesPerBatch","BindGroup","$8dd82b22d6c6be67$export$6f452ee382def63c","resources","setResource","_updateKey","keyParts","_key","currentResource","onResourceChange","getResource","_touch","tick","$9709da504abace0e$export$313b92466c30ee73","$cQZoA","$hsqkK","$9709da504abace0e$var$maxTexturesPerBatchCache","getTestContext","getParameter","MAX_TEXTURE_IMAGE_UNITS","checkMaxIfStatementsInShader","$57c7d5024495d73f$var$context","$57c7d5024495d73f$export$f034b2d55f8df08b","isContextLost","$fa0b436be19527d6$export$fb6ad4e758d74cc0","maxIfs","shader","createShader","FRAGMENT_SHADER","fragmentSrc","$fa0b436be19527d6$var$fragTemplate","$fa0b436be19527d6$var$generateIfTestSrc","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","$929d647851e09b11$export$34bf80542893bcb","$cdPyH","$52hCV","$VBW7g","$929d647851e09b11$var$defaultShader","$929d647851e09b11$var$_DefaultBatcher","_DefaultBatcher","Batcher","BatchGeometry","DefaultShader","maxTextures","packAttributes","element","uint32View","textureId","textureIdAndRound","wt","positions","argb","attributeOffset","i2","packQuadAttributes","w0","w1","h0","h1","$6dd97214b150f91d$export$704b12ddc1dacdd2","$3S0BG","$iOvyc","$ccFr4","$4iag5","$6dd97214b150f91d$export$33b107562567fc47","BatchTextureArray","topology","gpuBindGroup","$6dd97214b150f91d$var$batchPool","$6dd97214b150f91d$var$batchPoolIndex","$6dd97214b150f91d$var$getBatchFromPool","$6dd97214b150f91d$var$BATCH_TICK","$6dd97214b150f91d$var$_Batcher","_Batcher","batchIndex","_elements","attributesInitialSize","indicesInitialSize","ViewableBuffer","elementSize","elementStart","$6dd97214b150f91d$var$returnBatchToPool","_batchIndexStart","_batchIndexSize","batchableObject","_indexStart","_attributeStart","_batcher","checkAndUpdateTexture","_batch","_textureId","updateElement","packAsQuad","break","elements","textureBatch","firstElement","getAdjustedBlendModeBlend","_resizeAttributeBuffer","_resizeIndexBuffer","f32","u32","adjustedBlendMode","breakRequired","packQuadIndex","packIndex","_finishBatch","indexStart","newSize","newArrayBuffer","fastCopy","rawBinaryData","newIndexBuffer","BYTES_PER_ELEMENT","indicesOffset","indexOffset","$5270473618e0032a$export$4fdbf0662aa3047a","sizeOrBuffer","byteLength","int8View","_int8View","uint8View","_uint8View","int16View","_int16View","int32View","_int32View","float64View","_float64Array","Float64Array","bigUint64View","_bigUint64Array","BigUint64Array","uint16View","sizeOf","$607c9d28533128bf$export$c691b0c42debe682","sourceBuffer","destinationBuffer","lengthDouble","sourceFloat64View","destinationFloat64View","remainingBytes","sourceUint8View","destinationUint8View","$e4ad5d3a4270ea86$export$ab2fc5cf3fe899fe","$6MbTD","BLEND_TO_NPM","$9609253dda04f98f$export$8c0bd2ccaa4a8d5e","$9609253dda04f98f$export$c250b85d73a91bdf","normal","STENCIL_MODES2","$2f1e6c41cc08f185$export$aa760e0febf1a758","$10a242cb20b9e4c2$export$449e8d355fd68e43","$3wxNZ","$iZU4m","$gT67d","$10a242cb20b9e4c2$var$placeHolderBufferData","$10a242cb20b9e4c2$var$placeHolderIndexData","Geometry","Buffer","usage","BufferUsage","VERTEX","COPY_DST","shrinkToFit","attributes","aPosition","stride","aUV","aColor","aTextureIdAndRound","INDEX","$c5f6ca81ecc0d8c6$export$a143d493d941bafc","_dataInt32","_data","mappedAtCreation","descriptor","dataInt32","static","STATIC","syncGPU","_updateSize","oldData","sizeInBytes","$ed51a487692b4c37$export$f8deb2be8632fd10","BufferUsage2","$31912b62f4ce0357$export$2db6c17465f94a2","$5TxGW","$h12Mt","_layoutKey","instanceCount","addAttribute","addIndex","onBufferUpdate","getAttribute","getIndex","getBuffer","attribute","attributeOption","ensureIsBuffer","getGeometryBounds","destroyBuffers","$9370c4358dc389fa$export$e02adcb3cf335e03","$df6ac467d48f0069$export$ca8be28ec6402f29","attributeId","byteSize","$55348d9ef4e3c13a$export$5ee16216350ebcbc","$ir0EQ","$1e9Az","$raSIq","$V3X84","$7hpxC","$kmaR2","Shader","glProgram","compileHighShaderGlProgram","bits","colorBitGl","generateTextureBatchBitGl","roundPixelsBitGl","gpuProgram","compileHighShaderGpuProgram","colorBit","generateTextureBatchBit","roundPixelsBit","batchSamplers","getBatchSamplersUniformGroup","$7760537e44928577$export$af9d352c01aa9018","$7760537e44928577$export$477b8252c7ecdf2","$022Ud","$4WM3f","$aa9WS","$lrogc","$hJgms","compileHighShader","template","fragment","fragmentGPUTemplate","vertex","vertexGPUTemplate","globalUniformsBit","GpuProgram","entryPoint","GlProgram","compileHighShaderGl","vertexGlTemplate","fragmentGlTemplate","globalUniformsBitGl","$b1097531dd0c3de5$export$64881d9ea0a969d7","$eOVk3","$5T1DG","$1tHpx","$dGqzH","$aRhge","$93xFd","$b1097531dd0c3de5$var$processes","stripVersion","$2dc9W","ensurePrecision","addProgramDefines","setProgramName","insertVersion","$b1097531dd0c3de5$var$programCache","$b1097531dd0c3de5$var$_GlProgram","_GlProgram","isES300","preprocessorOptions","requestedFragmentPrecision","preferredFragmentPrecision","requestedVertexPrecision","preferredVertexPrecision","maxSupportedVertexPrecision","maxSupportedFragmentPrecision","getMaxFragmentPrecision","processKey","processOptions","transformFeedbackVaryings","createIdFromString","_attributeData","_uniformData","_uniformBlockData","$835fabfe4cff138c$export$1e452c36dfe36a93","$835fabfe4cff138c$var$idCounts","$835fabfe4cff138c$var$idHash","groupId","$d5b8e1bbaf57a0cb$var$maxFragmentPrecision","$d5b8e1bbaf57a0cb$export$428c38e64838140","getShaderPrecisionFormat","shaderFragment","HIGH_FLOAT","precision","$26bc2fd1c7ae4ff2$export$fba00ea8bc676dd1","isFragment","$71413d144ba7fc37$export$899bdffb1b617f8b","maxSupportedPrecision","$5fb6a3bda79c7c4d$export$df5409633d2e06a0","$630fbc96c5656f65$export$fcd35f5a80d5e29b","$630fbc96c5656f65$var$fragmentNameCache","$630fbc96c5656f65$var$VertexNameCache","nameCache","shaderName","$0319ae549f9fc051$export$f71406e7a553e9e5","$45a80282ba06b89e$export$b7a31a3cdd61870","$6HCQ5","$7Y09y","$icfjv","$6NVlJ","$BD5CG","$45a80282ba06b89e$var$programCache","_attributeLocationsKey","layout","gpuLayout","structsAndGroups","extractStructAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","removeStructAndGroupDuplicates","generateLayoutHash","generateGpuLayoutGroups","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","attributeData","extractAttributesFromGpuProgram","$ee782742ab296bf5$export$b0efe5f01c53f69f","$6Obke","$ee782742ab296bf5$var$WGSL_TO_VERTEX_TYPES","vec2f","vec3f","vec4f","i32","bool","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","getAttributeInfoFromFormat","instance","$17269f0d797fcd62$export$4da509c30cc6be33","$17269f0d797fcd62$var$attributeFormatData","uint8x2","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","$89b56e8bab7cfe10$export$368e99a200562975","wgsl","groupPattern","bindingPattern","namePattern","typePattern","structMemberPattern","structName","groups","group","binding","isUniform","structs","struct","members","member","name2","some","$afb6646ee191edf9$export$950011c0dc347495","$8DNdW","visibility","ShaderStage","FRAGMENT","sampler","sampleType","viewDimension","multisampled","$5c29b72d1e8b38f6$export$34a0cafc5a97ef31","ShaderStage2","$f04b8ec34b92ebbe$export$6a0f9650f9d4f875","$36305da6dd616aba$export$5f344e20ddfaa2d6","structNameSet","Set","dupeGroupKeySet","$a09ce791f9044ff5$export$86219fd7a1c584d2","$a09ce791f9044ff5$export$ff7039b165d48f97","$bbcL9","$aedhe","$90Bnm","$5iGoe","$22J0r","$a09ce791f9044ff5$var$cacheMap","$a09ce791f9044ff5$var$bitCacheMap","$a09ce791f9044ff5$var$CACHE_UID","cacheId","$a09ce791f9044ff5$var$generateCacheId","$a09ce791f9044ff5$var$compileInputsAndOutputs","vertexFragments","shaderBit","fragmentFragments","compiledVertex","compileInputs","compileOutputs","$a09ce791f9044ff5$var$compileBits","highFragment","vertexParts","compileHooks","fragmentParts","addBits","injectBits","$b701e37d650c1a99$export$38c21fb192fe3d9","srcParts","parts","part","toLocaleLowerCase","sanitisedPart","$3eac7173799a5f62$export$17705ba43ca63936","$3eac7173799a5f62$export$a564a4c9984eee7d","programSrc","partMatches","hook","$a0beb39fbe2ad372$var$extractInputs","fragmentSource","regex","$a0beb39fbe2ad372$export$aa47df9391ef0455","fragments","header","mainInput","finalString","inValue","cleanedString","$600c78bd5d8f61e0$var$extractOutputs","$600c78bd5d8f61e0$export$ae19cc473c7ab18","mainStruct","mainStart","mainEnd","$600c78bd5d8f61e0$var$extractVariableName","compiledCode","$bc3b940d9a709dcf$export$83c47c7340456c75","templateSrc","toInject","$bed2a13363946350$export$61ecfa8d2718163a","$bed2a13363946350$export$922d1073ee2ef930","$bed2a13363946350$export$99b0f79e15be8ede","$bed2a13363946350$export$3f7784dd6a13ff5a","$5e85aae35546a721$export$435d64b3a14c5a51","$5e85aae35546a721$export$38608853d4735d51","$700ff614ceb8a845$export$a62becfe5fe4ad2","$700ff614ceb8a845$export$93189e9821cf4459","main","$5b427ea70439968f$export$aff2d36945cda647","$5b427ea70439968f$export$204e46d9a7a4f835","$5b427ea70439968f$var$textureBatchBitGpuCache","$5b427ea70439968f$var$generateBindingSrc","bindingIndex","$5b427ea70439968f$var$generateSampleSrc","$5b427ea70439968f$var$textureBatchBitGlCache","$5b427ea70439968f$var$generateSampleGlSrc","$efc830b01ee153af$export$22150169726f7b1","$efc830b01ee153af$export$222909710f39cc5","$aab0094da40bc4f5$export$5fc8295c6cba6ffe","$7ZovY","$aab0094da40bc4f5$var$batchSamplersUniformGroupHash","batchSamplersUniformGroup","sampleValues","UniformGroup","uTextures","isStatic","$b7a36644826acc4c$export$6601a7a2dcf79bf5","$eWkxx","$drtAS","$b7a36644826acc4c$var$_UniformGroup","_UniformGroup","uniformStructures","isUniformGroup","_dirtyId","uniforms","uniformData","UNIFORM_TYPES_MAP","UNIFORM_TYPES_VALUES","getDefaultUniformValue","ubo","_signature","$ac75ba180d87b736$export$94ae83f3c0da5990","$ac75ba180d87b736$export$97ddd6675231876e","$3a47707a42582d68$export$7febdb6905805c3d","$e117696f3660e480$export$462bb059fed9d9e5","$28usv","_uniformBindMap","_ownedBindGroups","compatibleRenderers","groupMap","RendererType","WEBGPU","WEBGL","nameHash","uniformName","groupData","bindTick","_buildResourceAccessor","addResource","groupIndex","_a","_b","uniformsOut","destroyPrograms","gpu","$b2ee0ab0ac3d7eb3$export$2ca8315eebe81c3d","RendererType2","$a080d24481b48164$export$e3c00f31a053d231","$bpDQR","$4bCwI","$8qV09","$4E0Cg","$g2xO2","$ijujD","$gUSTb","$dBiOc","$7xJUK","$2l6S5","$a080d24481b48164$export$ab760b0d495e92a1","ShapeBuilder","buildRectangle","buildPolygon","buildTriangle","buildCircle","buildEllipse","buildRoundedRectangle","$a080d24481b48164$var$tempRect","$a080d24481b48164$var$addTextureToGeometryData","vertOffset","build","transformVertices","triangulate","textureUvs","graphicsBatch","BatchableGraphics","baseColor","isStroke","$a080d24481b48164$var$addShapePathToGeometryData","lastIndex","lineStyle","buildPixelLine","buildLine","holeIndices","otherPoints","holeArrays","$a080d24481b48164$var$getHoleArrays","holePrimitives","holePrimitive","holePoints","holeBuilder","triangulateWithHoles","uvsOffset","buildUvs","buildSimpleUvs","$95cacfd53eb3ccd8$export$2027711a0ff70dc2","verticesStride","verticesOffset","uvsStride","$95cacfd53eb3ccd8$export$580e3d8462b9fe52","$19ba6607450189cd$export$cbe36b8a8d6e3d3","$ff44f43bf11d19a8$export$91d2a08bbf21546b","$ff44f43bf11d19a8$var$identityMatrix","batcherName","rgb","gpuBuffer","$97ec315115ac3792$export$a3541b2d8ecbfcf2","$97ec315115ac3792$export$d35b00c6ec9534ca","$97ec315115ac3792$export$4b54fce47d2ae7f4","roundedRect","j1","j2","j3","j4","y22","x22","centerX","centerY","centerIndex","$c90f5af949c3c3c8$export$45986ccf08e93b0b","$8XZU4","$49rEx","$c90f5af949c3c3c8$var$square","innerWeight","outerWeight","clockwise","verts","exx","eyy","eix","ix","eiy","iy","eox","ox","eoy","oy","$c90f5af949c3c3c8$var$round","cx","cy","ex","ey","cx2p0x","cy2p0y","angle0","angle1","angleDiff","segCount","angleInc","flipAlignment","closed","closePointEps","orientation","getOrientationOfPoints","firstPoint","closedPath","midPointX","midPointY","indexCount","widthSquared","miterLimitSquared","perpX","perpY","perp1x","perp1y","dx0","dy0","dx1","dy1","cross","pDist","imx","imy","omx","omy","insideWeight","smallerInsideSegmentSq","eps2","curveEps","$cee639fae63999ed$export$7159a7c43f12984","$cee639fae63999ed$export$51a946149243709","$bb7bdc23d7522b8b$export$38856eae80d480e1","area","$f4df5f0a8f32dff9$export$44c058937667e9f0","fx","fy","$f448119daf614740$export$4c2d12f7b210f357","$f448119daf614740$var$emptyArray","$a990f8e145b4ff90$export$5a241bf9c2c3d94b","$fPquT","triangles","$b8602c4416cfa89b$var$earcut","dim","invSize","hasHoles","outerLen","outerNode","$b8602c4416cfa89b$var$linkedList","prev","$b8602c4416cfa89b$var$eliminateHoles","steiner","$b8602c4416cfa89b$var$getLeftmost","leftmost","$b8602c4416cfa89b$var$compareX","$b8602c4416cfa89b$var$eliminateHole","bridge","$b8602c4416cfa89b$var$findHoleBridge","hx","hy","qx","tanMin","$b8602c4416cfa89b$var$pointInTriangle","$b8602c4416cfa89b$var$locallyInside","$b8602c4416cfa89b$var$area","bridgeReverse","$b8602c4416cfa89b$var$splitPolygon","$b8602c4416cfa89b$var$filterPoints","$b8602c4416cfa89b$var$earcutLinked","ear","pass","$b8602c4416cfa89b$var$indexCurve","$b8602c4416cfa89b$var$zOrder","prevZ","nextZ","$b8602c4416cfa89b$var$sortLinked","tail","numMerges","pSize","qSize","inSize","$b8602c4416cfa89b$var$isEarHashed","ax","bx","ay","by","minZ","maxZ","$b8602c4416cfa89b$var$isEar","$b8602c4416cfa89b$var$removeNode","$b8602c4416cfa89b$var$cureLocalIntersections","$b8602c4416cfa89b$var$equals","$b8602c4416cfa89b$var$intersects","$b8602c4416cfa89b$var$splitEarcut","$b8602c4416cfa89b$var$intersectsPolygon","$b8602c4416cfa89b$var$middleInside","$b8602c4416cfa89b$var$signedArea","$b8602c4416cfa89b$var$insertNode","again","p1","p2","q1","q2","o1","$b8602c4416cfa89b$var$sign","o2","o3","o4","$b8602c4416cfa89b$var$onSegment","num","$b8602c4416cfa89b$var$Node","an","bp","sum","deviation","polygonArea","trianglesArea","flatten","holeIndex","$36305308a01a4676$export$cbe813d11f2192b2","rectData","verticesIndex","$08a3d6b4d84ddeca$export$8eb75cb9f614d270","$7659ce92f0cf3dda$export$d53ce9debfe7a6c2","$7659ce92f0cf3dda$var$PATH_DISTANCE_EPSILON","$7659ce92f0cf3dda$var$recursive","$14262346713351f6$export$ed8eebdc6998f0f6","steps","cs","sn","$326462c7d762b226$export$d46b7933b415e02f","mm","dd","cc","tt","k1","k2","qy","$6a3337fbe0a64811$export$71ccaa6dca53075e","$6a3337fbe0a64811$var$TAU","$6a3337fbe0a64811$var$out","ang1","ang2","$6a3337fbe0a64811$var$mapToEllipse","cosPhi","sinPhi","out2","xp","yp","$6a3337fbe0a64811$var$vectorAngle","ux","uy","vx","vy","acos","$6a3337fbe0a64811$var$getArcCenter","pxp","pyp","rxSq","rySq","pxpSq","pypSq","radicant","centerXp","centerYp","vx1","vy1","lambda","outCurvePoint","curve","$6a3337fbe0a64811$var$approxUnitArc","$0af85e9981f3b299$export$ae1f43bc280f09be","vecFrom","pp","sharpCorner","cRadius","pRadius","p3","v1","v2","asin","radDirection","drawDirection","halfAngle","lenOut","$0af85e9981f3b299$export$cf503f371c53af9e","pointLerp","numPoints","thisPoint","nextPoint","lastEdgeLength","lastOffsetDistance","nextEdgeLength","nextOffsetDistance","$c2c8874c335d60c2$export$2cc2aaca18109aab","graphicsContext","div","innerHTML","querySelector","$c2c8874c335d60c2$var$renderChildren","session","graphicsPath","f1","s1","$c2c8874c335d60c2$var$parseStyle","useFill","useStroke","styleParts","stylePart","$c2c8874c335d60c2$var$parseFloatAttribute","nodeName","pointsString","info","defaultValue","$bc8ed156a4cf9235$export$b254764c5530994a","$bc8ed156a4cf9235$export$64975ed44b74a62b","$bc8ed156a4cf9235$var$isFillPattern","$bc8ed156a4cf9235$var$isFillGradient","$bc8ed156a4cf9235$var$handleFillPattern","$bc8ed156a4cf9235$var$handleFillGradient","$bc8ed156a4cf9235$var$handleColorLike","temp","objectStyle","$bc8ed156a4cf9235$var$handleFillObject","sourceStyle","$358ccb3cd87ceb9c$export$8a3681e2b47964bb","$358ccb3cd87ceb9c$var$valuesToIterateForKeys","prop","$358ccb3cd87ceb9c$var$addFillStyleKey","$63e2c593b9d26d3b$export$bce21273d0a2e6c7","$02IUF","$dzZFt","$hjHBC","$clKJs","$4vQUT","$63e2c593b9d26d3b$var$_DynamicBitmapFont","_DynamicBitmapFont","AbstractBitmapFont","pages","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","_textureSize","textureSize","_mipmap","mipmap","applyFillAsTint","requestedFontSize","baseMeasurementFontSize","fontStringFromTextStyle","baseRenderedFontSize","fontMetrics","CanvasTextMetrics","measureFont","pageData","charList","char","_nextPage","canvasAndContext","fontScale","maxCharHeight","skipTexture","maxTextureWidth","maxTextureHeight","metrics","textureGlyphWidth","paddedWidth","paddedHeight","pageData2","xAdvance","codePointAt","xOffset","yOffset","kerning","_drawGlyph","_applyKerning","pageTextures","newChars","measureCache","first","second","amount","textureResolution","CanvasPool","getOptimalCanvasAndContext","_setupContext","lineWidth","lineJoin","getCanvasFillStyle","shadowOptions","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","fontProperties","descent","strokeText","fillText","returnCanvasAndContext","$aab25ca12e1b7da5$export$e56d0a06781accc9","canvasOptions","_canvasPool","_createCanvasAndContext","minWidth","minHeight","clearRect","$f9c250956f0e8c12$export$b12f6bdc825d944f","$f9c250956f0e8c12$var$contextSettings","willReadFrequently","$f9c250956f0e8c12$var$_CanvasTextMetrics","_CanvasTextMetrics","experimentalLetterSpacingSupported","_experimentalLetterSpacingSupported","lines","lineWidths","maxLineWidth","_canvas","textKey","_measurementCache","ascent","__context","outputText","_measureText","useExperimentalLetterSpacing","experimentalLetterSpacing","textLetterSpacing","metricWidth","actualBoundingBoxLeft","boundsWidth","actualBoundingBoxRight","graphemeSegmenter","line","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","characters","wordWrapSplit","lastChar","nextChar","canBreakChars","characterWidth","isLastToken","newLine","_trimRight","_newlines","_nextChar","_breakingSpaces","_token","_char","_fonts","METRICS_STRING","BASELINE_SYMBOL","properties","actualBoundingBoxAscent","actualBoundingBoxDescent","clearMetrics","__canvas","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","Intl","Segmenter","segmenter","segment","$d6b4d0f570937df8$export$b7b5edb82ac3fc66","$d6b4d0f570937df8$var$genericFontFamilies","fontSizeString","fontFamilies","$a1ab4fe444eeacdc$export$c31af9427fa8602b","fillPattern","pattern","createPattern","fillGradient","$74858068d5eabacd$export$70779aee6e4c1309","baseLineOffset","distanceField","distanceFieldRange","distanceFieldType","page","$7c5532b9fd92ef8a$export$221291e5031b03d8","startCode","endCode","String","fromCharCode","$c196de50aab0a4f4$export$beeb37b3e20d3ee4","layoutData","offsetY","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","nextLine","adjustedLetterSpacing","adjustedWordWrapWidth","isEnd","charData","isSpace","nextCharWidth","$c196de50aab0a4f4$var$alignCenter","measurementData","$c196de50aab0a4f4$var$alignRight","$c196de50aab0a4f4$var$alignJustify","indy","spaceIndex","totalSpaces","newSpaceWidth","$fa8815e339f41f96$export$29d3e417456abdad","_ownedContext","_callContextMethod","method","rotateTransform","scaleTransform","translateTransform","beginFill","endFill","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","$46e9c21fe5524152$export$a6aad6334ef58a1c","$aac24c264e299d39$export$ee43dd1acddf6cf8","WorkerGlobalScope","$bk2f9","$2fd62251d0455c2b$export$216169f30082c873","requestAdapter","requestDevice","$07d6276735060a75$var$renderPriority","$07d6276735060a75$export$3583b92ab8150eb6","RendererClass","finalOptions","rendererType","WebGPURenderer","webgpu","contextOptions","stencil","AbstractRenderer","success","getContextAttributes","WebGLRenderer","webgl","$d6zIN","$70be694526cfb04e$var$_Application","_Application","stage","_plugins","plugin","rendererDestroyOptions","plugins","$70be694526cfb04e$export$16975c34e60e1e61","ApplicationInitHook","$lQbVo","$608bb1638a6e0695$export$17957a09927cadc7","textureFrame","frameReal","BitmapFontManager","$cc969505651ddcf2$export$4c1815a0944ccac0","txt","rawData","common","kernings","attributeList","itemData","strValue","floatValue","isNaN","distanceRange","fieldType","face","file","charNode","letter","xoffset","yoffset","xadvance","$63c6e7573b16fe40$export$7a7adbcafc5cf8e3","getElementsByTagName","$d01f5a28b28b471d$export$bfc0a19e2e2cc16","$3a63b46ae10c80ec$var$validExtensions","$3a63b46ae10c80ec$export$778a313228f06f6c","CacheParser","$3a63b46ae10c80ec$export$402edee29ac8bed4","bitmapFontData","textureUrls","pageFile","loadedTextures","_options","response","$ad1b17b1723c6966$export$1949379a83b843d5","verbose","_loader","_assetList","_isLoading","_maxConcurrent","assetUrls","_isActive","_next","toLoad","toLoadAmount","active","$bf4d6dd69eb87956$export$407b4625a915919d","$7230094aaee53210$export$7c459e568e7cea2c","imageData","Image","onload","blob","createImageBitmap","$e4069250bf4ed59b$export$a60d2d4a3c570783","DetectionParser","formats","$4703260a04e3ad03$var$imageFormats","$4703260a04e3ad03$export$b106d7c2de3b4d89","$af36fa8e7d058b2d$var$inWorker","$af36fa8e7d058b2d$export$7a571c147b03abb1","mimeType","canPlayType","$e23ff61575e7ef80$export$7726d83fee274e25","$90a31412308a1b55$export$5a1da481121f806a","$8d16b6a6892fe269$export$a041d698a1896657","$3a1b830066a7e872$export$d19529a9ed9823d4","$ff34eee7c47ead35$export$3b0d6d7590275603","_parsersValidated","promiseCache","_getLoadPromiseAndParser","promise","_parserHash","parserX","parser2","assetsToLoadIn","onProgress","_validateParsers","assetsToLoad","assetsToUnloadIn","assetsToUnload","loadPromise","loadedAsset","hash","$de3f53883a0bbf0f$export$7ff8b059fb914323","mimes","mime","$3ee4ccd3e32414b6$export$fd0180357b95b812","$74c666bcc10ff43e$export$e7c8553478f3aac7","Low","json","$87210ffa948e76ea$export$3835b7ee6dbebde8","$99a8f3f35449bcfa$var$validWeights","$99a8f3f35449bcfa$var$validFontExtensions","$99a8f3f35449bcfa$var$validFontMIMEs","$99a8f3f35449bcfa$var$CSS_IDENT_TOKEN_REGEX","$99a8f3f35449bcfa$var$validURICharactersRegex","$99a8f3f35449bcfa$export$129ed93ad26b0298","fontFaces","family","$99a8f3f35449bcfa$export$c461ca8f39d93d9b","nameTokens","nameWithSpaces","charAt","toUpperCase","valid","fontFamilyName","weights","weight","FontFace","encodeURI","$2db229c57d4198d2$export$8695ab2f322d2637","$131715eb1eeb8d1a$export$37b981a8c575f415","$5122d03721d5b815$export$b6a2e78b63791dfa","parseAsGraphicsContext","$5122d03721d5b815$var$loadAsGraphics","$5122d03721d5b815$var$loadAsTexture","blobUrl","createObjectURL","decode","revokeObjectURL","_p","svgSource","$65f3f1a8dbdc7d8d$var$WORKER_URL","$65f3f1a8dbdc7d8d$export$2e2bcd8739ae039","Blob","worker","Worker","$4bbe6d132e00c6a2$var$WORKER_URL","$4bbe6d132e00c6a2$export$2e2bcd8739ae039","$87b21a3c09db871d$var$UUID","$87b21a3c09db871d$export$bcff6015853c67ce","_createdWorkers","_workerPool","_resolveHash","isImageBitmapSupported","_isImageBitmapSupported","terminate","loadImageBitmap","_run","_initWorkers","_getWorker","hardwareConcurrency","_complete","_returnWorker","error","uuid","toDo","postMessage","$659928910a21979a$var$validImageExtensions","$659928910a21979a$var$validImageMIMEs","$659928910a21979a$export$c614e6247302006d","ok","status","statusText","imageBlob","premultiplyAlpha","$659928910a21979a$export$897b113ee8307cd0","High","preferWorkers","preferCreateImageBitmap","$cfb1b656613615e1$var$validVideoExtensions","$cfb1b656613615e1$var$validVideoMIMEs","$cfb1b656613615e1$export$68fa0976ba667d63","isValidDataUrl","isValidExtension","videoElement","attributeMap","setAttribute","$cfb1b656613615e1$export$292083da55c5b406","loc","parsedUrl","hostname","port","sourceElement","onCanPlay","loaded","cleanup","appendChild","$919dd6816e91d631$export$cc356fa83de02bea","$b994a900f223e232$export$2b5cca0b89cb089c","$237b9dbd6c58e9b4$export$c8eca95e306f7116","_detections","_backgroundLoader","defaultSearchParams","resolutionPref","texturePreference","_detectFormats","preferredFormats","skipDetections","detections","preferences","setPreferences","urls","urlArray","resolveResults","_mapLoadToResolve","loadBundle","_onProgress","resolveResult","resolveResult2","backgroundLoad","backgroundLoadBundle","resolveArray","loadedAssets","_unloadFromResolved","unloadBundle","detection","$237b9dbd6c58e9b4$var$assetKeyMap","$3binI","$d1bbd571f88f6097$export$daf74670712de91","styleClass","_autoResolution","_didTextUpdate","_styleClass","_text","_getKey","owner","$e18e9fe6681a60c8$export$5f1af8db9871e1d6","$f3289b285438d34f$export$53a61779c1fcd190","$f3289b285438d34f$export$60667f9de734e56","assetsNames","$72762a06a728e4a1$export$1114c7e4bc5b368c","symbolName","$40a1f344e0cf63d9$export$3e25e887b7a5b37b","_id","_mainTexture","_winTexture","_sprite","_container","initTextures","setSymbol","symbolId","setTextures","win","$72762a06a728e4a1$export$d548f983b9413d19","createSymbol","$e2bcf89fe38d2db5$export$daee430848a3913d","_reelConfig","_pixiApp","_symbolManager","_reels","_tweening","initReels","initTicker","endCallback","reel","tweenTo","reelsContainer","reelContainer","reelWidth","symbolSize","symbols","randomSymbolId","$e2bcf89fe38d2db5$var$getRandomSymbolId","symbol","reelsWidth","marginTop","Date","tween","phase","easing","prevy","oncomplete","random","$fbd10fc1f281616b$export$2524c4960ed9dff2","spinCallback","Graphics","headerText","playText","eventMode","cursor","$546bb75ca3527d11$export$985739bfa5723e08","pixiApp","reelConfig","_isRunning","_resourceManager","_reelManager","_uiManager","app","resizeTo","body","game","STENCIL_MODES","CheckImageBitmapWorker","LoadImageBitmapWorker"],"version":3,"file":"index.28167d82.js.map"}